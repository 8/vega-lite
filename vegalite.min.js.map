{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/vl","vegalite.js","node_modules/browserify/node_modules/process/browser.js","node_modules/datalib/src/bin.js","node_modules/datalib/src/date-units.js","node_modules/datalib/src/generate.js","node_modules/datalib/src/histogram.js","node_modules/datalib/src/import/formats/csv.js","node_modules/datalib/src/import/formats/index.js","node_modules/datalib/src/import/formats/json.js","node_modules/datalib/src/import/formats/topojson.js","node_modules/datalib/src/import/formats/treejson.js","node_modules/datalib/src/import/formats/tsv.js","node_modules/datalib/src/import/load.js","node_modules/datalib/src/import/loaders.js","node_modules/datalib/src/import/read.js","node_modules/datalib/src/index.js","node_modules/datalib/src/stats.js","node_modules/datalib/src/summary.js","node_modules/datalib/src/template.js","node_modules/datalib/src/util.js","src/Encoding.js","src/compile/aggregate.js","src/compile/axis.js","src/compile/bin.js","src/compile/compile.js","src/compile/facet.js","src/compile/filter.js","src/compile/group.js","src/compile/layout.js","src/compile/legend.js","src/compile/marks.js","src/compile/scale.js","src/compile/sort.js","src/compile/stack.js","src/compile/style.js","src/compile/subfacet.js","src/compile/template.js","src/compile/time.js","src/consts.js","src/data.js","src/enc.js","src/field.js","src/globals.js","src/schema/schema.js","src/schema/schemautil.js","src/util.js"],"names":["e","exports","module","define","amd","f","window","global","self","vl","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"util","consts","extend","Encoding","compile","data","field","enc","schema","toShorthand","shorthand","./Encoding","./compile/compile","./consts","./data","./enc","./field","./globals","./schema/schema","./util",2,3,"drainQueue","draining","currentQueue","len","queue","noop","process","nextTick","fun","push","setTimeout","title","browser","env","argv","version","versions","on","addListener","once","off","removeListener","removeAllListeners","emit","binding","name","cwd","chdir","dir","umask",4,"bin","opt","step","logb","level","minstep","precision","v","eps","maxb","maxbins","base","Math","log","div","min","max","span","steps","bisect","ceil","pow","round","floor","start","stop","unit","value","index","x","lo","hi","mid","cmp","this","EPSILON","date_value","date","date_index","units","dmin","dmax","minb","minbins","find","bins","raw","./date-units",5,"STEPS","entries","type","format","d","Date","UTC","isNumber","getUTCFullYear","getUTCMonth","minuteOfHour","getUTCMinutes","hourOfDay","getUTCHours","dayOfWeek","getUTCDay","dayOfMonth","getUTCDate","monthOfYear","second","minute","hour","day","month","year","timesteps",6,"gen","repeat","val","Array","zeros","range","arguments","Infinity","j","random","uniform","undefined","samples","map","integer","b","normal","mean","stdev","next","rds","c","y","sqrt",7,"infer","values","types","isString","isNotNull","isDate","numerical","h","count","isFinite","categorical","sort","stats","unique","counts","keys","k","comparator","options","isFunction","ext","extent","./bin","./generate","./stats",8,"d3","csv","parse","toString",9,"json","tsv","topojson","treejson","./csv","./json","./topojson","./treejson","./tsv",10,"isObject","isBuffer","JSON","property","accessor","../../util",11,"obj","feature","objects","features","mesh",12,"toTable","root","childrenField","visit","node","parent","table","children",13,14,"sanitizeUrl","url","file","fileProtocol","baseURL","protocol_re","test","startsWith","isNode","defaultProtocol","domainWhiteList","domain","origin","parts","hostname","document","createElement","href","host","toLowerCase","location","whiteListed","some","idx","lastIndexOf","load","callback","error","err","slice","http","xhr","xhrHasResponse","request","responseType","response","responseText","respond","status","async","XMLHttpRequest","XDomainRequest","onload","onerror","onreadystatechange","readyState","open","send","fs","readFile","readFileSync","body","statusCode","getBody","../util","sync-request",15,"read","formats","reduce","out","./load","./read",16,"infer_type","TESTS","splice","infer_types","fields","PARSERS","cols","parsers","clen","duplicate","boolean","number","string","identity","isBoolean","isNaN","./formats",17,"dl","histogram","summary","template","dateunits","./histogram","./import/load","./import/loaders","./import/read","./summary","./template",18,"results","isArray","distinct","nulls","median","filter","half","quantile","p","H","delta","variance","M2","modeskew","avg","med","std","dot","sum","rank","mu","tie","cor","fn","mua","mub","sda","sdb","ra","rb","dist","aa","bb","ab","X","Y","A","mat","B","exp","abs","m","R","M","entropy","N","LN2","normalized","mutual","z","px","py","I","profile","sd","vals","iqr",19,"printSummary","profiles","str","forEach","printCategoricalProfile","printQuantitativeProfile","join","list","top","concat",20,"text","src","source","Function","bind","context","variable","regex","template_re","replace","match","interpolate","offset","template_escaper","template_escapeChar","template_var","strcall","stringCast","filters","split","prop","shift","trim","pidx","args","indexOf","template_format","time","template_escapes","pattern","fmt","format_map","truncate","clearFormatCache","'","\\","\r","\n"," "," ",21,"util_escape_str","escape_str_re","truncateOnWord","rev","cnt","tok","truncate_word_re","reverse","w","Buffer","stderr","Object","prototype","parseFloat","array","stringify","equal","toMap","keystr","apply","mutator","sign","NaN","numcmp","stablesort","sortBy","keyFn","indices","sa","sb","String","searchString","pos","word","ellipsis","l1","l2","_process","buffer",22,"vlfield","vlenc","marktype","config","theme","defaults","instantiate","spec","dataTypes","specExtended","merge","_data","_marktype","_enc","_config","_filter","proto","is","has","encType","et","filterNull","fieldList","fieldName","Q","containsType","T","O","operands","operator","nodata","nofn","aggr","fieldTitle","isCount","displayName","toUpperCase","scale","axis","band","bandSize","useSmallBand","ROW","COL","size","MAXBINS_DEFAULT","legend","isType","byCode","toggleSort","support","qField","init","role","TEXT","font","fieldDef","isOrdinalScale","encoding","isDimension","isMeasure","isAggregate","alwaysNoOcclusion","isStack","color","cardinality","isRaw","toSpec","excludeConfig","dataTypeNames","subtract","assign","delim","fromShorthand","specFromShorthand","fromSpec","transpose","oldenc","row","col","direction","useTypeCode","mode","get","toggleFilterNullO","./compile/time",23,"aggregates","dims","meas","detail","facets","op","preaggregatedData","transform","groupby","details","aggregated","../globals",24,"axis_title","def","layout","maxlength","cellWidth","cellHeight","setter","angle","align","baseline","dy","height","titleOffset","axisTitleOffset","axis_labels","hasScale","textTemplatePath","maxLabelLength","getter","names","props","defs","isCol","isRow","rowOffset","cellPadding","grid","layer","stroke","x2","group","mult","opacity","orient","ticks","./time",25,"binning","output",26,"marks","aggregate","facet","stack","style","subfacet","mark","mdefs","mdef","addFilters","sorting","hasRow","hasCol","lineType","line","aggResult","hasDetails","from","by","legends","scales","properties","update","axes","filterLessThanZero","../Encoding","./aggregate","./axis","./facet","./filter","./group","./layout","./legend","./marks","./scale","./sort","./stack","./style","./subfacet",27,"faceting","axesGrp","enter","facetKeys","cellAxes","fill","unshift","groupdef","width","trans",28,"BINARY",">",">=","=","!=","<","<=","condition","op1","op2","console","warn",29,"_name",30,"vllayout","box","hasX","hasY","xCardinality","yCardinality","padding","colCardinality","rowCardinality","getMaxLength","maxLength","../field","../schema/schema",31,"COLOR","SIZE","SHAPE","shape","labels",32,"bar_props","xc","y2","yc","ALPHA","point_props","strokeWidth","line_props","area_props","tick_props","filled_point_props","text_props","fontSize","fontWeight","fontStyle","bg","TABLE","bar","requiredEncoding","supportedEncoding","alpha","area","tick","circle","square","point",33,"scale_domain","getbins","STACKED","getDataset","scale_range","bandWidth","zero","nice","colorRange","outerPadding","points",34,"addSortTransforms","datasetMapping","counter","byClause","dataName","transforms","RAW",35,"stacking","dim","isXMeasure","isYMeasure","stacked","y1","y0",36,"estimateOpacity","numPoints","numMultiples",37,"subfaceting","g",38,"dataUrl","vldata","getUrl","../data",39,"timeFields","timeFn","tf","fieldFn","func","stat","yearstat","formula","expr","labelLength","substr","isOrdinalFn","isColor",40,"encodingTypes","DETAIL",41,"binSize","query","getStats","sample","datalib",42,"encTypes","countRetinal","arr","convertType","enctype",43,"getIsType","byName","shorthands","timefns","typeOrder","G","order","typeThenName","original","typeThenCardinality",44,"INDEX",45,"enum","supportedEnums","supportedTypes","minimum","default","getSupportedRole","supportedRole","defaultTimeFn","scale_type","clone","typicalField","description","onlyOrdinalField","dimension","axisMixin","supportedMarktypes","sortMixin","items","required","bandMixin","legendMixin","textMixin","margin","weight","family","sizeMixin","colorMixin","alphaMixin","maximum","shapeMixin","detailMixin","rowMixin","colMixin","facetMixin","requiredNameType","multiRoleField","measure","quantitativeField","onlyQuantitativeField","formatType","vegaServer","viewport","gridColor","singleHeight","singleWidth","largeBandSize","smallBandSize","largeBandMaxCardinality","cellGridColor","cellBackgroundColor","textCellWidth","timeScaleLabelLength","characterWidth","$schema","./schemautil",46,"dest","hasOwnProperty","constructor","schemautil","isEmpty","instance","changes","ins",47,"isin","item","thisArg","noaugment","msg","datalib/src/bin","datalib/src/generate","datalib/src/util"],"mappings":"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","file":"vegalite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar globals = require('./globals'),\n    util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compile = require('./compile/compile');\nvl.data = require('./data');\nvl.field = require('./field');\nvl.enc = require('./enc');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\n\nmodule.exports = vl;\n","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.vl=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar globals = require('./globals'),\n    util = require('./util'),\n    consts = require('./consts');\n\nvar vl = {};\n\nutil.extend(vl, consts, util);\n\nvl.Encoding = require('./Encoding');\nvl.compile = require('./compile/compile');\nvl.data = require('./data');\nvl.field = require('./field');\nvl.enc = require('./enc');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\n\nmodule.exports = vl;\n\n},{\"./Encoding\":22,\"./compile/compile\":26,\"./consts\":40,\"./data\":41,\"./enc\":42,\"./field\":43,\"./globals\":44,\"./schema/schema\":45,\"./util\":47}],2:[function(require,module,exports){\n\n},{}],3:[function(require,module,exports){\n// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],4:[function(require,module,exports){\nvar util = require('./util');\nvar units = require('./date-units');\nvar EPSILON = 1e-15;\n\nfunction bin(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, logb, level, minstep, precision, v, i, eps;\n\n  if (opt.step != null) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n};\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n};\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbin.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin);\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      bins = bin({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  bins.unit = unit;\n  bins.index = date_index;\n  if (!opt.raw) bins.value = date_value;\n  return bins;\n};\n\nmodule.exports = bin;\n\n},{\"./date-units\":5,\"./util\":21}],5:[function(require,module,exports){\nvar util = require('./util');\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nvar entries = [\n  {\n    type: \"second\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M:%S.%L\",\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: \"minute\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M\",\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: \"hour\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:00\",\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: \"day\",\n    minstep: 1,\n    step: [1, 7],\n    format: \"%Y %b %-d\",\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: \"month\",\n    minstep: 1,\n    step: [1, 3, 6],\n    format: \"%b %Y\",\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (util.isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: \"year\",\n    minstep: 1,\n    format: \"%Y\",\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (util.isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: \"minuteOfHour\",\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: \"%M\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: \"hourOfDay\",\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: \"%H\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: \"dayOfWeek\",\n  min: 0,\n  max: 6,\n  step: [1],\n  format: \"%a\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: \"dayOfMonth\",\n  min: 1,\n  max: 31,\n  step: [1],\n  format: \"%-d\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: \"monthOfYear\",\n  min: 0,\n  max: 11,\n  step: [1],\n  format: \"%b\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  \"second\":       entries[0],\n  \"minute\":       entries[1],\n  \"hour\":         entries[2],\n  \"day\":          entries[3],\n  \"month\":        entries[4],\n  \"year\":         entries[5],\n  \"minuteOfHour\": minuteOfHour,\n  \"hourOfDay\":    hourOfDay,\n  \"dayOfWeek\":    dayOfWeek,\n  \"dayOfMonth\":   dayOfMonth,\n  \"monthOfYear\":  monthOfYear,\n  \"timesteps\":    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n\n},{\"./util\":21}],6:[function(require,module,exports){\nvar gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n\t\tmax = min;\n\t\tmin = 0;\n\t}\n\tvar d = max - min;\n\tvar f = function() {\n\t\treturn min + d * Math.random();\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.integer = function(a, b) {\n\tif (b === undefined) {\n\t\tb = a;\n\t\ta = 0;\n\t}\n  var d = b - a;\n\tvar f = function() {\n\t\treturn a + Math.floor(d * Math.random());\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.normal = function(mean, stdev) {\n\tmean = mean || 0;\n\tstdev = stdev || 1;\n\tvar next = undefined;\n\tvar f = function() {\n\t\tvar x = 0, y = 0, rds, c;\n\t\tif (next !== undefined) {\n\t\t\tx = next;\n\t\t\tnext = undefined;\n\t\t\treturn x;\n\t\t}\n\t\tdo {\n\t\t\tx = Math.random()*2-1;\n\t\t\ty = Math.random()*2-1;\n\t\t\trds = x*x + y*y;\n\t\t} while (rds == 0 || rds > 1);\n\t\tc = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n\t\tnext = mean + y*c*stdev;\n\t\treturn mean + x*c*stdev;\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n},{}],7:[function(require,module,exports){\nvar stats = require('./stats');\nvar util = require('./util');\nvar bin = require('./bin');\nvar gen = require('./generate');\n\nmodule.exports = function(values, f, options) {\n  if (options === undefined && !util.isFunction(f)) { options = f; f = null; }\n\n  var type = options && options.type || infer(values, f);\n  if (type !== 'number' && type !== 'date' && type !== 'integer') {\n    return categorical(values, f, options && options.sort);\n  }\n\n  var ext = stats.extent(values, f),\n      opt = util.extend({min: ext[0], max: ext[1]}, options);\n  if (type === 'integer' && opt.minstep == null) opt.minstep = 1;\n  var b = type === 'date' ? bin.date(opt) : bin(opt);\n  return numerical(values, f, b);\n};\n\nfunction infer(values, f) {\n  var v = null, i;\n\n  // if data array has type annotations, use them\n  if (values.types) {\n    v = f(values.types);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0; !util.isNotNull(v) && i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n  return util.isDate(v) ? 'date' : util.isNumber(v) ? 'number' : 'string';\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var c = stats.unique(values, f).counts;\n  return util.keys(c)\n    .map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? \"-count\" : \"+value\"));\n}\n},{\"./bin\":4,\"./generate\":6,\"./stats\":18,\"./util\":21}],8:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.csv.parse(data ? data.toString() : data);\n  return d;\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],9:[function(require,module,exports){\nmodule.exports = {\n  json: require('./json'),\n  csv: require('./csv'),\n  tsv: require('./tsv'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson')\n};\n},{\"./csv\":8,\"./json\":10,\"./topojson\":11,\"./treejson\":12,\"./tsv\":13}],10:[function(require,module,exports){\nvar util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data)\n    ? data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n\n},{\"../../util\":21}],11:[function(require,module,exports){\n(function (global){\nvar json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error(\"TopoJSON library not loaded.\"); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if (obj = t.objects[format.feature]) {\n      return topojson.feature(t, obj).features\n    } else {\n      throw Error(\"Invalid TopoJSON object: \"+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if (obj = t.objects[format.mesh]) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error(\"Invalid TopoJSON object: \" + format.mesh);\n    }\n  } else {\n    throw Error(\"Missing TopoJSON feature or mesh parameter.\");\n  }\n\n  return [];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./json\":10}],12:[function(require,module,exports){\nvar json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || \"children\";\n  var table = [];\n  \n  function visit(node, parent) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}\n},{\"./json\":10}],13:[function(require,module,exports){\n(function (global){\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.tsv.parse(data ? data.toString() : data);\n  return d;\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],14:[function(require,module,exports){\nvar util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host == \"\") {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function (d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; };\n  \n  try {\n    var url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== \"text\"\n      ? request.response // null on error\n      : request.responseText; // \"\" on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest;\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest\n      && !(\"withCredentials\" in request)\n      && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest;\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    \"onload\" in request\n      ? request.onload = request.onerror = respond\n      : request.onreadystatechange = function() { request.readyState > 3 && respond(); };\n  }\n  \n  request.open(\"GET\", url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(file, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(file, 'utf8');\n  }\n  require('fs').readFile(file, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n\n},{\"../util\":21,\"fs\":2,\"request\":2,\"sync-request\":2,\"url\":2}],15:[function(require,module,exports){\nvar util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) opt = {url: opt};\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n\n},{\"../util\":21,\"./load\":14,\"./read\":16}],16:[function(require,module,exports){\nvar util = require('../util');\nvar formats = require('./formats');\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  util.identity\n};\n\nvar TESTS = {\n  boolean: function(x) { return x===\"true\" || x===\"false\" || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction read(data, format) {\n  var type = (format && format.type) || \"json\";\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction infer_type(values, f) {\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isNotNull(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction infer_types(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer_type(data, util.accessor(f));\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? infer_types(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return PARSERS[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  data.types = types;\n}\n\nread.type = infer_type;\nread.types = infer_types;\nread.formats = formats;\nread.parse = parse;\nmodule.exports = read;\n\n},{\"../util\":21,\"./formats\":9}],17:[function(require,module,exports){\nvar util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  bin:       require('./bin'),\n  histogram: require('./histogram'),\n  summary:   require('./summary'),\n  template:  require('./template'),\n  dateunits: require('./date-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/loaders'));\n\nmodule.exports = dl;\n},{\"./bin\":4,\"./date-units\":5,\"./generate\":6,\"./histogram\":7,\"./import/load\":14,\"./import/loaders\":15,\"./import/read\":16,\"./stats\":18,\"./summary\":19,\"./template\":20,\"./util\":21}],18:[function(require,module,exports){\nvar util = require('./util');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values and associated counts.\n// Output: an array of unique values, in observed order\n// The array includes an additional 'counts' property,\n// which is a hash from unique values to occurrence counts.\nstats.unique = function(values, f, results) {\n  if (!util.isArray(values) || values.length===0) return [];\n  results = results || [];\n  var u = {}, v, i;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      u[v] += 1;\n    } else {\n      u[v] = 1;\n      results.push(v);\n    }\n  }\n  results.counts = u;\n  return results;\n};\n\n// Count the number of non-null values.\nstats.count = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\nstats.count.distinct = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var u = {}, v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Count the number of null or undefined values.\nstats.count.nulls = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  if (f) values = values.map(f);\n  values = values.filter(util.isNotNull).sort(util.cmp);\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    v = (typeof v === 'string') ? v.length : v;\n    if (util.isNotNull(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    v = (typeof v === 'string') ? v.length : v;\n    if (util.isNotNull(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  var a, b, x, y, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    v = (typeof v === 'string') ? v.length : v;\n    if (util.isNotNull(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    v = (typeof v === 'string') ? v.length : v;\n    if (util.isNotNull(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error(\"Array lengths must match.\");\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!isNaN(v)) sum += v;\n    }\n  } else {\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  var a = values.map(function(v, i) {\n      return {\n        idx: i,\n        val: (f ? f(v) : v)\n      };\n    })\n    .sort(util.comparator(\"val\"));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(b) : a,\n  a = fn ? values.map(a) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(a) : values,\n      Y = b ? values.map(b) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      n = values.length, s = 0, d, i;\n\n  if (e === 2 || e === undefined) {\n    for (i=0; i<n; ++i) {\n      d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n      s += d*d;\n    }\n    return Math.sqrt(s);\n  } else {\n    for (i=0; i<n; ++i) {\n      d = Math.abs(f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]));\n      s += Math.pow(d, e);\n    }\n    return Math.pow(s, 1/e);\n  }\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  var i, p, s = 0, H = 0, N = counts.length;\n  for (i=0; i<N; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<N; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p > 0) H += p * Math.log(p) / Math.LN2;\n  }\n  return -H;\n};\n\n// Compute the normalized Shannon entropy (log base 2) of an array of counts.\nstats.entropy.normalized = function(counts, f) {\n  var H = stats.entropy(counts, f);\n  return H===0 ? 0 : H * Math.LN2 / Math.log(counts.length);\n};\n\n// Compute the mutual information between two discrete variables.\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.entropy.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(a) : values,\n      y = counts ? values.map(b) : a,\n      z = counts ? values.map(counts) : b;\n\n  var px = {},\n\t    py = {},\n\t    i, xx, yy, zz, s = 0, t, N = z.length, p, I = 0;\n\n\tfor (i=0; i<N; ++i) {\n\t  px[x[i]] = 0;\n\t  py[y[i]] = 0;\n  }\n\n\tfor (i=0; i<N; ++i) {\n\t\tpx[x[i]] += z[i];\n\t\tpy[y[i]] += z[i];\n\t\ts += z[i];\n\t}\n\n\tt = 1 / (s * Math.LN2);\n\tfor (i=0; i<N; ++i) {\n\t\tif (z[i] === 0) continue;\n\t\tp = (s * z[i]) / (px[x[i]] * py[y[i]]);\n\t\tI += z[i] * t * Math.log(p);\n\t}\n\n\treturn I;\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var p = {},\n      mean = 0,\n      count = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x, half, h, h2;\n\n  // compute summary stats\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (util.isNotNull(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n\n      delta = x - mean;\n      mean = mean + delta / (++count);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (count - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    unique:   u,\n    count:    count,\n    nulls:    values.length - count,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd,\n    iqr:      [stats.quantile(vals, 0.25), stats.quantile(vals, 0.75)]\n  };\n};\n\nmodule.exports = stats;\n},{\"./generate\":6,\"./util\":21}],19:[function(require,module,exports){\nvar util = require('./util');\nvar stats = require('./stats');\n\n// Compute profiles for all variables in a data set.\nmodule.exports = function(data, fields) {\n  if (data == null || data.length === 0) return null;\n  fields = fields || util.keys(data[0]);\n\n  var profiles = fields.map(function(f) {\n    var p = stats.profile(data, util.accessor(f));\n    return (p.field = f, p);\n  });\n  \n  profiles.toString = printSummary;\n  return profiles;\n};\n\nfunction printSummary() {\n  var profiles = this;\n  var str = [];\n  profiles.forEach(function(p) {\n    str.push(\"----- Field: '\" + p.field + \"' -----\");\n    if (typeof p.min === 'string' || p.distinct < 10) {\n      str.push(printCategoricalProfile(p));\n    } else {\n      str.push(printQuantitativeProfile(p));\n    }\n    str.push(\"\");\n  });\n  return str.join(\"\\n\");\n}\n\nfunction printQuantitativeProfile(p) {\n  return [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"min:      \" + p.min,\n    \"max:      \" + p.max,\n    \"median:   \" + p.median,\n    \"mean:     \" + p.mean,\n    \"stdev:    \" + p.stdev,\n    \"modeskew: \" + p.modeskew\n  ].join(\"\\n\");\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"top values: \"\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return \" '\" + v + \"' (\" + u[v] + \")\"; });\n  return list.concat(top).join(\"\\n\");\n}\n},{\"./stats\":18,\"./util\":21}],20:[function(require,module,exports){\n(function (global){\nvar util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate\n};\n\nfunction template(text) {\n  var src = source(text, \"d\");\n  src = \"var __t; return \" + src + \";\";\n\n  try {\n    return (new Function(\"d\", src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || \"obj\";\n  var index = 0;\n  var src = \"'\";\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += \"'\\n+((__t=(\"\n        + template_var(interpolate, variable)\n        + \"))==null?'':__t)+\\n'\";\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + \"'\";\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var format = [];\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || \"\";\n    if (stringCast) {\n      stringCast = false;\n      src = \"String(\" + src + \")\" + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  var src = util.field(prop).map(util.str).join(\"][\");\n  src = variable + \"[\" + src + \"]\";\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a\n          + (args.length > 1 ? ',' + util.number(args[1]) : '')\n          + ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!==\"left\" && b!==\"middle\" && b!==\"center\") ? \"right\" : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\"' + b + '\")';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      default:\n        throw Error(\"Unrecognized template filter: \" + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  \"'\":      \"'\",\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === \"'\" && pattern[pattern.length-1] === \"'\") ||\n      (pattern[0] !== '\"' && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error(\"Format pattern must be quoted: \" + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"./util\":21}],21:[function(require,module,exports){\n(function (process){\nvar Buffer = require('buffer').Buffer;\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined'\n        && typeof process.stderr !== 'undefined';\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) == '[object Function]';\n};\n\nu.isString = function(obj) {\n  return toString.call(obj) == '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return !isNaN(parseFloat(obj)) && isFinite(obj);\n};\n\nu.isBoolean = function(obj) {\n  return toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) == '[object Date]';\n};\n\nu.isNotNull = function(obj) {\n  return obj != null && (typeof obj !== 'number' ? true : !isNaN(obj));\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) { return s == null ? null : +s; };\n\nu.boolean = function(s) { return s == null ? null : s==='false' ? false : !!s; };\n\nu.date = function(s) { return s == null ? null : Date.parse(s); }\n\nu.array = function(x) { return x != null ? (u.isArray(x) ? x : [x]) : []; };\n\nu.str = function(x) {\n  return u.isArray(x) ? \"[\" + x.map(u.str) + \"]\"\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? (\"'\"+util_escape_str(x)+\"'\") : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, \"$1\\\\'\");\n}\n\n// utility functions\n\nu.identity = function(x) { return x; };\n\nu.true = function() { return true; };\n\nu.false = function() { return false; };\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list) {\n  return list.reduce(function(obj, x) {\n    return (obj[x] = 1, obj);\n  }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  return values.join(\"|\");\n};\n\n// data access functions\n\nu.field = function(f) {\n  return f.split(\"\\\\.\")\n    .map(function(d) { return d.split(\".\"); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += \".\" + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return (u.isFunction(f) || f==null)\n    ? f : u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x) { return s.reduce(function(x,f) {\n          return x[f];\n        }, x);\n      }\n    : function(x) { return x[f]; };\n};\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x, v) {\n        for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n        x[s[i]] = v;\n      }\n    : function(x, v) { x[f] = v; };\n};\n\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === \"-\") { s = -1; f = f.slice(1); }\n    else if (f[0] === \"+\") { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith\n  ? function(string, searchString) {\n    return string.startsWith(searchString);\n  }\n  : function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : \"…\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis\n        + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n}).call(this,require('_process'))\n\n},{\"_process\":3,\"buffer\":2}],22:[function(require,module,exports){\n'use strict';\n\nvar globals = require('./globals'),\n  consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema'),\n  time = require('./compile/time');\n\nvar Encoding = module.exports = (function() {\n\n  function Encoding(marktype, enc, data, config, filter, theme) {\n    var defaults = schema.instantiate();\n\n    var spec = {\n      data: data,\n      marktype: marktype,\n      enc: enc,\n      config: config,\n      filter: filter || []\n    };\n\n    // type to bitcode\n    for (var e in defaults.enc) {\n      defaults.enc[e].type = consts.dataTypes[defaults.enc[e].type];\n    }\n\n    var specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.enc;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.enc = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(et, nodata, nofn) {\n    if (!this.has(et)) return null;\n\n    var f = (nodata ? '' : 'data.');\n\n    if (this._enc[et].aggr === 'count') {\n      return f + 'count';\n    } else if (!nofn && this._enc[et].bin) {\n      return f + 'bin_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].aggr) {\n      return f + this._enc[et].aggr + '_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].fn) {\n      return f + this._enc[et].fn + '_' + this._enc[et].name;\n    } else {\n      return f + this._enc[et].name;\n    }\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggr || this._enc[et].fn || (this._enc[et].bin && \"bin\");\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.band = function(et) {\n    return this._enc[et].band || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.band(encType).size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggr = function(et) {\n    return this._enc[et].aggr;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.legend = function(et) {\n    return this._enc[et].legend;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.fn = function(et) {\n    return this._enc[et].fn;\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isType = vlfield.isType.byCode;\n\n    // console.log('sort:', sort, 'support:', Encoding.toggleSort.support({enc:this._enc}, stats) , 'toggle:', this.config('toggleSort'))\n\n    if ((!sort || sort.length===0) &&\n        Encoding.toggleSort.support({enc:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === 'Q'\n      ) {\n      var qField = isType(enc.x, O) ? enc.y : enc.x;\n\n      if (isType(enc[et], O)) {\n        sort = [{\n          name: qField.name,\n          aggr: qField.aggr,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.length = function() {\n    return util.keys(this._enc).length;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.role = function(et) {\n    return this.has(et) ? vlfield.role(this._enc[et]) : null;\n  };\n\n  proto.text = function(prop) {\n    var text = this._enc[TEXT].text;\n    return prop ? text[prop] : text;\n  };\n\n  proto.font = function(prop) {\n    var font = this._enc[TEXT].font;\n    return prop ? font[prop] : font;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.enc(et);\n    return field && Encoding.isType(field, type);\n  };\n\n  Encoding.isType = function (fieldDef, type) {\n    // FIXME vlfield.isType\n    return (fieldDef.type & type) > 0;\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.enc(encType), true);\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.enc(encType), true);\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.enc(encType), true);\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec, stats) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.enc.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.enc(encType), stats, this.config('filterNull'), true);\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return this._data[name];\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  proto.toSpec = function(excludeConfig) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for (var e in enc) {\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.enc);\n  };\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split, true);\n\n    return new Encoding(marktype, enc, data, config, null, theme);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    var enc = util.duplicate(spec.enc || {});\n\n    //convert type from string to bitcode (e.g, O=1)\n    for (var e in enc) {\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, spec.data, spec.config, spec.filter, theme);\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.enc,\n      enc = util.duplicate(spec.enc);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.enc = enc;\n    return spec;\n  };\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === 'Q' ? 'O' :'Q';\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec, useTypeCode) {\n    if (!Encoding.toggleSort.support(spec, useTypeCode)) { return; }\n    var enc = spec.enc;\n    return enc.x.type === 'O' ? 'x' :  'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats, useTypeCode) {\n    var enc = spec.enc,\n      isType = vlfield.isType.get(useTypeCode);\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isType(enc.x, O) && vlfield.isMeasure(enc.y, useTypeCode)) ? 'x' :\n      ( isType(enc.y, O) && vlfield.isMeasure(enc.x, useTypeCode)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.enc);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n\n},{\"./compile/time\":39,\"./consts\":40,\"./enc\":42,\"./field\":43,\"./globals\":44,\"./schema/schema\":45,\"./util\":47}],23:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {},\n    data = spec.data[1]; // currently data[0] is raw and data[1] is table\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggr) {\n      if (field.aggr === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggr + '|'+ field.name] = {\n          op: field.aggr,\n          field: 'data.'+ field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0 && !opt.preaggregatedData) {\n    if (!data.transform) data.transform = [];\n    data.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n\n},{\"../globals\":44,\"../util\":47}],24:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var type = name;\n  var isCol = name == COL, isRow = name == ROW;\n  var rowOffset = axisTitleOffset(encoding, layout, Y) + 20,\n    cellPadding = layout.cellPadding;\n\n\n  if (isCol) type = 'x';\n  if (isRow) type = 'y';\n\n  var def = {\n    type: type,\n    scale: name\n  };\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n    def.layer = (isRow || isCol) ? 'front' :  'back';\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      setter(def, ['properties', 'grid'], {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      setter(def, ['properties', 'grid'], {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: rowOffset\n        },\n        x2: {\n          offset: rowOffset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: \"mark.group.width\",\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else {\n      setter(def, ['properties', 'grid', 'stroke'], {\n        value: encoding.config('gridColor')\n      });\n    }\n  }\n\n  if (encoding.axis(name).title) {\n    def = axis_title(def, name, encoding, layout, opt);\n  }\n\n  if (isRow || isCol) {\n    setter(def, ['properties', 'ticks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'majorTicks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'axis'], {\n      opacity: {value: 0}\n    });\n  }\n\n  if (isCol) {\n    def.orient = 'top';\n  }\n\n  if (isRow) {\n    def.offset = rowOffset;\n  }\n\n  if (name == X) {\n    if (encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n      def.orient = 'top';\n    }\n\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      setter(def, ['properties','labels'], {\n        angle: {value: 270},\n        align: {value: 'right'},\n        baseline: {value: 'middle'}\n      });\n    } else { // Q\n      def.ticks = 5;\n    }\n  }\n\n  def = axis_labels(def, name, encoding, layout, opt);\n\n  return def;\n};\n\nfunction axis_title(def, name, encoding, layout, opt) {\n  var maxlength = null,\n    fieldTitle = encoding.fieldTitle(name);\n  if (name===X) {\n    maxlength = layout.cellWidth / encoding.config('characterWidth');\n  } else if (name === Y) {\n    maxlength = layout.cellHeight / encoding.config('characterWidth');\n  }\n\n  def.title = maxlength ? util.truncate(fieldTitle, maxlength) : fieldTitle;\n\n  if (name === ROW) {\n    setter(def, ['properties','title'], {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    });\n  }\n\n  def.titleOffset = axisTitleOffset(encoding, layout, name);\n  return def;\n}\n\nfunction axis_labels(def, name, encoding, layout, opt) {\n  var fn;\n  // add custom label for time type\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) && (time.hasScale(fn))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ fn);\n  }\n\n  var textTemplatePath = ['properties','labels','text','template'];\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q)) {\n    setter(def, textTemplatePath, \"{{data | number:'.3s'}}\");\n  } else if (encoding.isType(name, T) && !encoding.fn(name)) {\n    setter(def, textTemplatePath, \"{{data | time:'%Y-%m-%d'}}\");\n  } else if (encoding.isType(name, T) && encoding.fn(name) === 'year') {\n    setter(def, textTemplatePath, \"{{data | number:'d'}}\");\n  } else if (encoding.isType(name, O) && encoding.axis(name).maxLabelLength) {\n    setter(def, textTemplatePath, '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}');\n  }\n\n  return def;\n}\n\nfunction axisTitleOffset(encoding, layout, name) {\n  var value = encoding.axis(name).titleOffset;\n  if (value) {\n    return value;\n  }\n  switch (name) {\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n}\n\n},{\"../globals\":44,\"../util\":47,\"./time\":39}],25:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = binning;\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n  var bins = {};\n\n  if (opt.preaggregatedData) {\n    return;\n  }\n\n  if (!spec.transform) spec.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      spec.transform.push({\n        type: 'bin',\n        field: 'data.' + field.name,\n        output: 'data.bin_' + field.name,\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n}\n\n},{\"../globals\":44,\"../util\":47}],26:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals');\n\nmodule.exports = compile;\n\nvar Encoding = require('../Encoding'),\n  axis = compile.axis = require('./axis'),\n  filter = compile.filter = require('./filter'),\n  legend = compile.legend = require('./legend'),\n  marks = compile.marks = require('./marks'),\n  scale = compile.scale = require('./scale');\n\ncompile.aggregate = require('./aggregate');\ncompile.bin = require('./bin');\ncompile.facet = require('./facet');\ncompile.group = require('./group');\ncompile.layout = require('./layout');\ncompile.sort = require('./sort');\ncompile.stack = require('./stack');\ncompile.style = require('./style');\ncompile.subfacet = require('./subfacet');\ncompile.template = require('./template');\ncompile.time = require('./time');\n\nfunction compile(spec, stats, theme) {\n  return compile.encoding(Encoding.fromSpec(spec, theme), stats);\n}\n\ncompile.shorthand = function (shorthand, stats, config, theme) {\n  return compile.encoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompile.encoding = function (encoding, stats) {\n  var layout = compile.layout(encoding, stats),\n    style = compile.style(encoding, stats),\n    spec = compile.template(encoding, layout, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  filter.addFilters(spec, encoding);\n  var sorting = compile.sort(spec, encoding, stats);\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  var preaggregatedData = !!encoding.data('vegaServer');\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  compile.bin(spec.data[1], encoding, {preaggregatedData: preaggregatedData});\n\n  var lineType = marks[encoding.marktype()].line;\n\n  if (!preaggregatedData) {\n    spec = compile.time(spec, encoding);\n  }\n\n  // handle subfacets\n  var aggResult = compile.aggregate(spec, encoding, {preaggregatedData: preaggregatedData}),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && compile.stack(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compile.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = compile.facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, style, sorting,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(spec, encoding);\n\n  return spec;\n};\n\n\n},{\"../Encoding\":22,\"../globals\":44,\"./aggregate\":23,\"./axis\":24,\"./bin\":25,\"./facet\":27,\"./filter\":28,\"./group\":29,\"./layout\":30,\"./legend\":31,\"./marks\":32,\"./scale\":33,\"./sort\":34,\"./stack\":35,\"./style\":36,\"./subfacet\":37,\"./template\":38,\"./time\":39}],27:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.field(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.field(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    style,\n    sorting,\n    {stack: stack, facet: true, stats: stats}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n\n},{\"../globals\":44,\"../util\":47,\"./axis\":24,\"./group\":29,\"./scale\":33}],28:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(spec, encoding) {\n  var filters = encoding.filter(),\n    data = spec.data[0];  // apply filters to raw data before aggregation\n\n  if (!data.transform)\n    data.transform = [];\n\n  // add custom filters\n  for (var i in filters) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = 'd.data.' + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j in operands) {\n        condition += 'd.data.' + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    data.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(spec, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      spec.data[1].transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.field(encType) + '>0'\n      });\n    }\n  });\n};\n\n\n},{\"../globals\":44}],29:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\n},{}],30:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  schema = require('../schema/schema'),\n  time = require('./time'),\n  vlfield = require('../field');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.band(X).padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.enc(COL).width :  encoding.config(\"singleWidth\");\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.band(Y).padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.enc(ROW).height :  encoding.config(\"singleHeight\");\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  // FIXME determine constant for Q and T in a nicer way\n  return encoding.isType(et, Q) ? 20 :\n    encoding.isType(et, T) ? 20 :\n    stats[encoding.fieldName(et)].max;\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (x) {\n    var maxLength;\n    if (encoding.isDimension(x) || encoding.isType(x, T)) {\n      maxLength =  getMaxLength(encoding, stats, x);\n    } else if (encoding.aggr(x) === 'count') {\n      //assign default value for count as it won't have stats\n      maxLength =  3;\n    } else if (encoding.isType(x, Q)) {\n      if (x===X) {\n        maxLength = 3;\n      } else { // Y\n        //assume that default formating is always shorter than 7\n        maxLength = Math.min(getMaxLength(encoding, stats, x), 7);\n      }\n    }\n    setter(layout,[x, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + 20);\n  });\n  return layout;\n}\n\n},{\"../field\":43,\"../globals\":44,\"../schema/schema\":45,\"../util\":47,\"./time\":39}],31:[function(require,module,exports){\n'use strict';\n\nvar global = require('../globals'),\n  time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vegalite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props, fn;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) &&\n    time.hasScale(fn)) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ fn;\n  }\n\n  return def;\n};\n\n},{\"../globals\":44,\"./time\":39}],32:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlscale = require('./scale');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.field(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, alpha: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: e.scale(X).type === 'log' ? 1 : 0};\n    }\n  } else if (e.has(X)) { // is ordinal\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    // TODO add single bar offset\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: e.scale(Y).type === 'log' ? 1 : 0};\n  } else if (e.has(Y)) { // is ordinal\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    // TODO add single bar offset\n    p.yc = {group: 'height'};\n  }\n\n  // width\n  if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.width = {\n        value: e.bandSize(X, layout.x.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // X is Quant or Time Scale\n    p.width = {value: 2};\n  }\n\n  // height\n  if (!e.has(Y) || e.isOrdinalScale(Y)) { // no Y or Y is ordinal\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // Y is Quant or Time Scale\n    p.height = {value: 2};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction line_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    } else if (e.value(ALPHA) !== undefined) {\n      p.opacity = {value: e.value(ALPHA)};\n    } else if (!e.has(COLOR)) {\n      p.opacity = {value: style.opacity};\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: e.font('size')};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: 'black'};\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else {\n    p.opacity = {value: style.opacity};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      p.text = {template: \"{{\" + e.field(TEXT) + \" | number:'.3s'}}\"};\n      p.align = {value: 'right'};\n    } else {\n      p.text = {field: e.field(TEXT)};\n    }\n  } else {\n    p.text = {value: 'Abc'};\n  }\n\n  p.font = {value: e.font('family')};\n  p.fontWeight = {value: e.font('weight')};\n  p.fontStyle = {value: e.font('style')};\n  p.baseline = {value: e.text('baseline')};\n\n  return p;\n}\n\n},{\"../globals\":44,\"../util\":47,\"./scale\":33}],33:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  time = require('./time');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale_domain(name, encoding, sorting, opt)\n    };\n    if (s.type === 'ordinal' && !encoding.bin(name) && encoding.sort(name).length === 0) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, layout, style, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case O: return 'ordinal';\n    case T:\n      var fn = encoding.fn(name);\n      return (fn && time.scale.type(fn, name)) || 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nfunction scale_domain(name, encoding, sorting, opt) {\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encoding.fn(name), name);\n    if(range) return range;\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)], encoding.bin(name).maxbins);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name === Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: 'data.' + (opt.facet ? 'max_' : '') + 'sum_' + encoding.field(name, true)\n    } :\n    {data: sorting.getDataset(name), field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, layout, style, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name);\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name) || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      var range = encoding.scale(COLOR).range;\n      if (range === undefined) {\n        if (s.type === 'ordinal') {\n          // FIXME\n          range = style.colorRange;\n        } else {\n          range = ['#A9DB9F', '#0D5C21'];\n          s.zero = false;\n        }\n      }\n      s.range = range;\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.band(s.name).padding;\n      }\n  }\n}\n\n},{\"../globals\":44,\"../util\":47,\"./time\":39}],34:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(spec, encoding, stats, opt) {\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggr,\n          field: 'data.' + d.name\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + 'data.' + (d.aggr==='count' ? 'count' : (d.aggr + '_' + d.name));\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: ['data.' + field.name],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      spec.data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    spec: spec,\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n\n},{\"../globals\":44}],35:[function(require,module,exports){\n\"use strict\";\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{op: 'max', field: 'data.sum_' + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n\n},{\"../globals\":44,\"../util\":47,\"./marks\":32}],36:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlfield = require('../field'),\n  Encoding = require('../Encoding');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n    colorRange: colorRange(encoding, stats)\n  };\n};\n\nfunction colorRange(encoding, stats){\n  if (encoding.has(COLOR) && encoding.isDimension(COLOR)) {\n    var cardinality = encoding.cardinality(COLOR, stats);\n    if (cardinality <= 10) {\n      return \"category10\";\n    } else {\n      return \"category20\";\n    }\n    // TODO can vega interpolate range for ordinal scale?\n  }\n  return null;\n}\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field, true))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n\n},{\"../Encoding\":22,\"../field\":43,\"../globals\":44,\"../util\":47}],37:[function(require,module,exports){\n'use strict';\n\nvar global = require('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.field(COLOR)});\n  }\n}\n\n},{\"../globals\":44,\"./group\":29}],38:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals');\n\nvar groupdef = require('./group').def,\n  vldata = require('../data');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) { //hack use stats\n\n  var data = {name: RAW, format: {type: encoding.data('formatType')}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = vldata.getUrl(encoding, stats);\n  if (dataUrl) data.url = dataUrl;\n\n  var preaggregatedData = !!encoding.data('vegaServer');\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (field.aggr === 'count') {\n        name = 'count';\n      } else if (preaggregatedData && field.bin) {\n        name = 'bin_' + field.name;\n      } else if (preaggregatedData && field.aggr) {\n        name = field.aggr + '_' + field.name;\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n\n},{\"../data\":41,\"../globals\":44,\"./group\":29}],39:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt) {\n  var timeFields = {}, timeFn = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.fn) {\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeFn[field.fn] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[1],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var fn in timeFn) {\n    time.scale(scales, fn, encoding);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var fn = field.fn;\n  switch (fn) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.fn, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\n/** append custom time scales for axis label */\ntime.scale = function(scales, fn, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength');\n  // TODO add option for shorter scale / custom range\n  switch (fn) {\n    case 'day':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 7),\n        range: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(\n          function(s) { return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case 'month':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 12),\n        range: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(\n            function(s) { return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n\ntime.isOrdinalFn = function(fn) {\n  switch (fn) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(fn, name) {\n  if (name === COLOR) {\n    return 'linear'; // this has order\n  }\n\n  return time.isOrdinalFn(fn) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(fn, name) {\n  var isColor = name === COLOR;\n  switch (fn) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(fn) {\n  switch (fn) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n\n\n},{\"../globals\":44,\"../util\":47}],40:[function(require,module,exports){\n'use strict';\n\nvar globals = require('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT, DETAIL];\n\nconsts.dataTypes = {'O': O, 'Q': Q, 'T': T};\n\nconsts.dataTypeNames = ['O', 'Q', 'T'].reduce(function(r, x) {\n  r[consts.dataTypes[x]] = x;\n  return r;\n},{});\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n\n},{\"./globals\":44}],41:[function(require,module,exports){\n'use strict';\n\nvar dl = require('datalib');\n\nvar vldata = module.exports = {},\n  vlfield = require('./field'),\n  util = require('./util');\n\nvldata.getUrl = function getDataUrl(encoding, stats) {\n  if (!encoding.data('vegaServer')) {\n    // don't use vega server\n    return encoding.data('url');\n  }\n\n  if (encoding.length() === 0) {\n    // no fields\n    return;\n  }\n\n  var fields = [];\n  encoding.forEach(function(field, encType) {\n    var obj = {\n      name: encoding.field(encType, true),\n      field: field.name\n    };\n    if (field.aggr) {\n      obj.aggr = field.aggr;\n    }\n    if (field.bin) {\n      obj.binSize = util.getbins(stats[field.name], encoding.bin(encType).maxbins).step;\n    }\n    fields.push(obj);\n  });\n\n  var query = {\n    table: encoding.data('vegaServer').table,\n    fields: fields\n  };\n\n  return encoding.data('vegaServer').url + '/query/?q=' + JSON.stringify(query);\n};\n\n/** Mapping from datalib's inferred type to vegalite's type */\nvldata.types = {\n  'boolean': 'O',\n  'number': 'Q',\n  'integer': 'Q',\n  'date': 'T',\n  'string': 'O'\n};\n\nvldata.getStats = function(data) {\n  var stats = {},\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    var stat = dl.profile(data, function(d) {\n      return d[k];\n    });\n\n    var sample = {};\n    while(Object.keys(sample).length < Math.min(stat.distinct, 10)) {\n      var value = data[Math.floor(Math.random() * data.length)][k];\n      sample[value] = true;\n    }\n    stat.sample = Object.keys(sample);\n\n    stats[k] = stat;\n  });\n\n  stats.count = data.length;\n  return stats;\n};\n\n},{\"./field\":43,\"./util\":47,\"datalib\":17}],42:[function(require,module,exports){\n// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.alpha) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggr) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init, i = 0, k;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field, encType) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand, convertType) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field, convertType);\n    return m;\n  }, {});\n};\n},{\"./compile/time\":39,\"./consts\":40,\"./field\":43,\"./schema/schema\":45,\"./util\":47}],43:[function(require,module,exports){\n'use strict';\n\n// utility for field\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggr ? f.aggr + c.func : '') +\n    (f.fn ? f.fn + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type +\n    (consts.dataTypeNames[f.type] || f.type);\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand, convertType) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: convertType ? consts.dataTypes[split[1].trim()] : split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggr.enum) {\n    var a = schema.aggr.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggr = a;\n      break;\n    }\n  }\n\n  // check time fn\n  for (i in schema.timefns) {\n    var f = schema.timefns[i];\n    if (o.name && o.name.indexOf(f + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.fn = f;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar typeOrder = {\n  O: 0,\n  G: 1,\n  T: 2,\n  Q: 3\n};\n\nvlfield.order = {};\n\nvlfield.order.type = function(field) {\n  if (field.aggr==='count') return 4;\n  return typeOrder[field.type];\n};\n\nvlfield.order.typeThenName = function(field) {\n  return vlfield.order.type(field) + '_' + field.name.toLowerCase();\n};\n\nvlfield.order.original = function() {\n  return 0; // no swap will occur\n};\n\nvlfield.order.name = function(field) {\n  return field.name;\n};\n\nvlfield.order.typeThenCardinality = function(field, stats){\n  return stats[field.name].distinct;\n};\n\n// FIXME refactor\nvlfield.isType = function (fieldDef, type) {\n  return (fieldDef.type & type) > 0;\n};\n\nvlfield.isType.byCode = vlfield.isType;\n\nvlfield.isType.byName = function (field, type) {\n  return field.type === consts.dataTypeNames[type];\n};\n\n\nfunction getIsType(useTypeCode) {\n  return useTypeCode ? vlfield.isType.byCode : vlfield.isType.byName;\n}\n\nvlfield.isType.get = getIsType; //FIXME\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || field.bin ||\n    ( isType(field, T) && field.fn && time.isOrdinalFn(field.fn) );\n};\n\nfunction isDimension(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || !!field.bin ||\n    ( isType(field, T) && !!field.fn );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field, useTypeCode /*optional*/) {\n  return field && isDimension(field, useTypeCode);\n};\n\nvlfield.isMeasure = function(field, useTypeCode) {\n  return field && !isDimension(field, useTypeCode);\n};\n\nvlfield.role = function(field) {\n  return isDimension(field) ? 'dimension' : 'measure';\n};\n\nvlfield.count = function() {\n  return {name:'*', aggr: 'count', type:'Q', displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggr === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull, useTypeCode) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var isType = getIsType(useTypeCode),\n    type = useTypeCode ? consts.dataTypeNames[field.type] : field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggr) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n\n},{\"./compile/time\":39,\"./consts\":40,\"./schema/schema\":45,\"./util\":47}],44:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],45:[function(require,module,exports){\n// Package of defining Vegalite Specification's json schema\n\"use strict\";\n\nvar schema = module.exports = {},\n  util = require('../util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggr = {\n  type: 'string',\n  enum: ['avg', 'sum', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'sum', 'min', 'max', 'count'],\n    O: [],\n    T: ['avg', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: {'Q': true, 'O': true, 'T': true, '': true}\n};\nschema.band = {\n  type: 'object',\n  properties: {\n    size: {\n      type: 'integer',\n      minimum: 0\n    },\n    padding: {\n      type: 'integer',\n      minimum: 0,\n      default: 1\n    }\n  }\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.enc.properties[encType].supportedRole;\n};\n\nschema.timefns = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.fn = {\n  type: 'string',\n  enum: schema.timefns,\n  supportedTypes: {'T': true}\n};\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: 'string',\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: {'Q': true}\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2\n    }\n  },\n  supportedTypes: {'Q': true} // TODO: add 'O' after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O', 'Q', 'T']\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: {'T': true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O','Q', 'T'] // ordinal-only field supports Q when bin is applied and T when fn is applied.\n    },\n    fn: schema.fn,\n    bin: bin,\n    aggr: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: {'O': true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        title: {\n          type: 'boolean',\n          default: true,\n          description: 'A title for the axis.'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: {'O': true},\n        required: ['name', 'aggr'],\n        name: {\n          type: 'string'\n        },\n        aggr: {\n          type: 'string',\n          enum: ['avg', 'sum', 'min', 'max', 'count']\n        },\n        reverse: {\n          type: 'boolean',\n          default: false\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: schema.band\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    text: {\n      type: 'object',\n      properties: {\n        align: {\n          type: 'string',\n          default: 'left'\n        },\n        baseline: {\n          type: 'string',\n          default: 'middle'\n        },\n        margin: {\n          type: 'integer',\n          default: 4,\n          minimum: 0\n        }\n      }\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    }\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array']\n        }\n      }\n    }\n  }\n};\n\nvar alphaMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    grid: {\n      type: 'boolean',\n      default: true,\n      description: 'A flag indicate if gridlines should be created in addition to ticks.'\n    },\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using alpha / size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\nvar alpha = merge(clone(quantitativeField), alphaMixin, sortMixin);\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    vegaServer: {\n      type: 'object',\n      default: null,\n      properties: {\n        table: {\n          type: 'string',\n          default: undefined\n        },\n        url: {\n          type: 'string',\n          default: 'http://localhost:3001'\n        }\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#eeeeee'\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: 'O'\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#aaaaaa'\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    }\n  }\n};\n\n/** @type Object Schema of a vegalite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for vegalite specification',\n  type: 'object',\n  required: ['marktype', 'enc', 'data', 'config'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    enc: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.enc.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n\n},{\"../util\":47,\"./schemautil\":46}],46:[function(require,module,exports){\n'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n},{\"../util\":47}],47:[function(require,module,exports){\n'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.bin = require('datalib/src/bin');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n\n},{\"datalib/src/bin\":4,\"datalib/src/generate\":6,\"datalib/src/util\":21}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvdmwiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3Nlci1yZXNvbHZlL2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2Jyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9iaW4uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvZGF0ZS11bml0cy5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9nZW5lcmF0ZS5qcyIsIm5vZGVfbW9kdWxlcy9kYXRhbGliL3NyYy9oaXN0b2dyYW0uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvY3N2LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9mb3JtYXRzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9mb3JtYXRzL2pzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvdG9wb2pzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvdHJlZWpzb24uanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvaW1wb3J0L2Zvcm1hdHMvdHN2LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9sb2FkLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9sb2FkZXJzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2ltcG9ydC9yZWFkLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3N0YXRzLmpzIiwibm9kZV9tb2R1bGVzL2RhdGFsaWIvc3JjL3N1bW1hcnkuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvdGVtcGxhdGUuanMiLCJub2RlX21vZHVsZXMvZGF0YWxpYi9zcmMvdXRpbC5qcyIsInNyYy9FbmNvZGluZy5qcyIsInNyYy9jb21waWxlL2FnZ3JlZ2F0ZS5qcyIsInNyYy9jb21waWxlL2F4aXMuanMiLCJzcmMvY29tcGlsZS9iaW4uanMiLCJzcmMvY29tcGlsZS9jb21waWxlLmpzIiwic3JjL2NvbXBpbGUvZmFjZXQuanMiLCJzcmMvY29tcGlsZS9maWx0ZXIuanMiLCJzcmMvY29tcGlsZS9ncm91cC5qcyIsInNyYy9jb21waWxlL2xheW91dC5qcyIsInNyYy9jb21waWxlL2xlZ2VuZC5qcyIsInNyYy9jb21waWxlL21hcmtzLmpzIiwic3JjL2NvbXBpbGUvc2NhbGUuanMiLCJzcmMvY29tcGlsZS9zb3J0LmpzIiwic3JjL2NvbXBpbGUvc3RhY2suanMiLCJzcmMvY29tcGlsZS9zdHlsZS5qcyIsInNyYy9jb21waWxlL3N1YmZhY2V0LmpzIiwic3JjL2NvbXBpbGUvdGVtcGxhdGUuanMiLCJzcmMvY29tcGlsZS90aW1lLmpzIiwic3JjL2NvbnN0cy5qcyIsInNyYy9kYXRhLmpzIiwic3JjL2VuYy5qcyIsInNyYy9maWVsZC5qcyIsInNyYy9nbG9iYWxzLmpzIiwic3JjL3NjaGVtYS9zY2hlbWEuanMiLCJzcmMvc2NoZW1hL3NjaGVtYXV0aWwuanMiLCJzcmMvdXRpbC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTtBQ0FBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hNQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0VBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDTkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDamJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNyTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNW1CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwiZmlsZSI6ImdlbmVyYXRlZC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzQ29udGVudCI6WyIoZnVuY3Rpb24gZSh0LG4scil7ZnVuY3Rpb24gcyhvLHUpe2lmKCFuW29dKXtpZighdFtvXSl7dmFyIGE9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtpZighdSYmYSlyZXR1cm4gYShvLCEwKTtpZihpKXJldHVybiBpKG8sITApO3ZhciBmPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIrbytcIidcIik7dGhyb3cgZi5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGZ9dmFyIGw9bltvXT17ZXhwb3J0czp7fX07dFtvXVswXS5jYWxsKGwuZXhwb3J0cyxmdW5jdGlvbihlKXt2YXIgbj10W29dWzFdW2VdO3JldHVybiBzKG4/bjplKX0sbCxsLmV4cG9ydHMsZSx0LG4scil9cmV0dXJuIG5bb10uZXhwb3J0c312YXIgaT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuL2dsb2JhbHMnKSxcbiAgICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gICAgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKTtcblxudmFyIHZsID0ge307XG5cbnV0aWwuZXh0ZW5kKHZsLCBjb25zdHMsIHV0aWwpO1xuXG52bC5FbmNvZGluZyA9IHJlcXVpcmUoJy4vRW5jb2RpbmcnKTtcbnZsLmNvbXBpbGUgPSByZXF1aXJlKCcuL2NvbXBpbGUvY29tcGlsZScpO1xudmwuZGF0YSA9IHJlcXVpcmUoJy4vZGF0YScpO1xudmwuZmllbGQgPSByZXF1aXJlKCcuL2ZpZWxkJyk7XG52bC5lbmMgPSByZXF1aXJlKCcuL2VuYycpO1xudmwuc2NoZW1hID0gcmVxdWlyZSgnLi9zY2hlbWEvc2NoZW1hJyk7XG52bC50b1Nob3J0aGFuZCA9IHZsLkVuY29kaW5nLnNob3J0aGFuZDtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHZsO1xuIixudWxsLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcblxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRRdWV1ZTtcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgdmFyIGkgPSAtMTtcbiAgICAgICAgd2hpbGUgKCsraSA8IGxlbikge1xuICAgICAgICAgICAgY3VycmVudFF1ZXVlW2ldKCk7XG4gICAgICAgIH1cbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xufVxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICBxdWV1ZS5wdXNoKGZ1bik7XG4gICAgaWYgKCFkcmFpbmluZykge1xuICAgICAgICBzZXRUaW1lb3V0KGRyYWluUXVldWUsIDApO1xuICAgIH1cbn07XG5cbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG4vLyBUT0RPKHNodHlsbWFuKVxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciB1bml0cyA9IHJlcXVpcmUoJy4vZGF0ZS11bml0cycpO1xudmFyIEVQU0lMT04gPSAxZS0xNTtcblxuZnVuY3Rpb24gYmluKG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgLy8gZGV0ZXJtaW5lIHJhbmdlXG4gIHZhciBtYXhiID0gb3B0Lm1heGJpbnMgfHwgMTUsXG4gICAgICBiYXNlID0gb3B0LmJhc2UgfHwgMTAsXG4gICAgICBsb2diID0gTWF0aC5sb2coYmFzZSksXG4gICAgICBkaXYgPSBvcHQuZGl2IHx8IFs1LCAyXSwgICAgICBcbiAgICAgIG1pbiA9IG9wdC5taW4sXG4gICAgICBtYXggPSBvcHQubWF4LFxuICAgICAgc3BhbiA9IG1heCAtIG1pbixcbiAgICAgIHN0ZXAsIGxvZ2IsIGxldmVsLCBtaW5zdGVwLCBwcmVjaXNpb24sIHYsIGksIGVwcztcblxuICBpZiAob3B0LnN0ZXAgIT0gbnVsbCkge1xuICAgIC8vIGlmIHN0ZXAgc2l6ZSBpcyBleHBsaWNpdGx5IGdpdmVuLCB1c2UgdGhhdFxuICAgIHN0ZXAgPSBvcHQuc3RlcDtcbiAgfSBlbHNlIGlmIChvcHQuc3RlcHMpIHtcbiAgICAvLyBpZiBwcm92aWRlZCwgbGltaXQgY2hvaWNlIHRvIGFjY2VwdGFibGUgc3RlcCBzaXplc1xuICAgIHN0ZXAgPSBvcHQuc3RlcHNbTWF0aC5taW4oXG4gICAgICBvcHQuc3RlcHMubGVuZ3RoIC0gMSxcbiAgICAgIGJpc2VjdChvcHQuc3RlcHMsIHNwYW4vbWF4YiwgMCwgb3B0LnN0ZXBzLmxlbmd0aClcbiAgICApXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBlbHNlIHVzZSBzcGFuIHRvIGRldGVybWluZSBzdGVwIHNpemVcbiAgICBsZXZlbCA9IE1hdGguY2VpbChNYXRoLmxvZyhtYXhiKSAvIGxvZ2IpO1xuICAgIG1pbnN0ZXAgPSBvcHQubWluc3RlcCB8fCAwO1xuICAgIHN0ZXAgPSBNYXRoLm1heChcbiAgICAgIG1pbnN0ZXAsXG4gICAgICBNYXRoLnBvdyhiYXNlLCBNYXRoLnJvdW5kKE1hdGgubG9nKHNwYW4pIC8gbG9nYikgLSBsZXZlbClcbiAgICApO1xuICAgIFxuICAgIC8vIGluY3JlYXNlIHN0ZXAgc2l6ZSBpZiB0b28gbWFueSBiaW5zXG4gICAgZG8geyBzdGVwICo9IGJhc2U7IH0gd2hpbGUgKE1hdGguY2VpbChzcGFuL3N0ZXApID4gbWF4Yik7XG5cbiAgICAvLyBkZWNyZWFzZSBzdGVwIHNpemUgaWYgYWxsb3dlZFxuICAgIGZvciAoaT0wOyBpPGRpdi5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IHN0ZXAgLyBkaXZbaV07XG4gICAgICBpZiAodiA+PSBtaW5zdGVwICYmIHNwYW4gLyB2IDw9IG1heGIpIHN0ZXAgPSB2O1xuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBwcmVjaXNpb24sIG1pbiBhbmQgbWF4XG4gIHYgPSBNYXRoLmxvZyhzdGVwKTtcbiAgcHJlY2lzaW9uID0gdiA+PSAwID8gMCA6IH5+KC12IC8gbG9nYikgKyAxO1xuICBlcHMgPSBNYXRoLnBvdyhiYXNlLCAtcHJlY2lzaW9uIC0gMSk7XG4gIG1pbiA9IE1hdGgubWluKG1pbiwgTWF0aC5mbG9vcihtaW4gLyBzdGVwICsgZXBzKSAqIHN0ZXApO1xuICBtYXggPSBNYXRoLmNlaWwobWF4IC8gc3RlcCkgKiBzdGVwO1xuXG4gIHJldHVybiB7XG4gICAgc3RhcnQ6IG1pbixcbiAgICBzdG9wOiAgbWF4LFxuICAgIHN0ZXA6ICBzdGVwLFxuICAgIHVuaXQ6ICB7cHJlY2lzaW9uOiBwcmVjaXNpb259LFxuICAgIHZhbHVlOiB2YWx1ZSxcbiAgICBpbmRleDogaW5kZXhcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGJpc2VjdChhLCB4LCBsbywgaGkpIHtcbiAgd2hpbGUgKGxvIDwgaGkpIHtcbiAgICB2YXIgbWlkID0gbG8gKyBoaSA+Pj4gMTtcbiAgICBpZiAodXRpbC5jbXAoYVttaWRdLCB4KSA8IDApIHsgbG8gPSBtaWQgKyAxOyB9XG4gICAgZWxzZSB7IGhpID0gbWlkOyB9XG4gIH1cbiAgcmV0dXJuIGxvO1xufTtcblxuZnVuY3Rpb24gdmFsdWUodikge1xuICByZXR1cm4gdGhpcy5zdGVwICogTWF0aC5mbG9vcih2IC8gdGhpcy5zdGVwICsgRVBTSUxPTik7XG59XG5cbmZ1bmN0aW9uIGluZGV4KHYpIHtcbiAgcmV0dXJuIE1hdGguZmxvb3IoKHYgLSB0aGlzLnN0YXJ0KSAvIHRoaXMuc3RlcCArIEVQU0lMT04pO1xufVxuXG5mdW5jdGlvbiBkYXRlX3ZhbHVlKHYpIHtcbiAgcmV0dXJuIHRoaXMudW5pdC5kYXRlKHZhbHVlLmNhbGwodGhpcywgdikpO1xufVxuXG5mdW5jdGlvbiBkYXRlX2luZGV4KHYpIHtcbiAgcmV0dXJuIGluZGV4LmNhbGwodGhpcywgdGhpcy51bml0LnVuaXQodikpO1xufVxuXG5iaW4uZGF0ZSA9IGZ1bmN0aW9uKG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgLy8gZmluZCB0aW1lIHN0ZXAsIHRoZW4gYmluXG4gIHZhciBkbWluID0gb3B0Lm1pbixcbiAgICAgIGRtYXggPSBvcHQubWF4LFxuICAgICAgbWF4YiA9IG9wdC5tYXhiaW5zIHx8IDIwLFxuICAgICAgbWluYiA9IG9wdC5taW5iaW5zIHx8IDQsXG4gICAgICBzcGFuID0gKCtkbWF4KSAtICgrZG1pbik7XG4gICAgICB1bml0ID0gb3B0LnVuaXQgPyB1bml0c1tvcHQudW5pdF0gOiB1bml0cy5maW5kKHNwYW4sIG1pbmIsIG1heGIpLFxuICAgICAgYmlucyA9IGJpbih7XG4gICAgICAgIG1pbjogICAgIHVuaXQubWluICE9IG51bGwgPyB1bml0Lm1pbiA6IHVuaXQudW5pdChkbWluKSxcbiAgICAgICAgbWF4OiAgICAgdW5pdC5tYXggIT0gbnVsbCA/IHVuaXQubWF4IDogdW5pdC51bml0KGRtYXgpLFxuICAgICAgICBtYXhiaW5zOiBtYXhiLFxuICAgICAgICBtaW5zdGVwOiB1bml0Lm1pbnN0ZXAsXG4gICAgICAgIHN0ZXBzOiAgIHVuaXQuc3RlcFxuICAgICAgfSk7XG5cbiAgYmlucy51bml0ID0gdW5pdDtcbiAgYmlucy5pbmRleCA9IGRhdGVfaW5kZXg7XG4gIGlmICghb3B0LnJhdykgYmlucy52YWx1ZSA9IGRhdGVfdmFsdWU7XG4gIHJldHVybiBiaW5zO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW47XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgU1RFUFMgPSBbXG4gIFszMTUzNmU2LCA1XSwgIC8vIDEteWVhclxuICBbNzc3NmU2LCA0XSwgICAvLyAzLW1vbnRoXG4gIFsyNTkyZTYsIDRdLCAgIC8vIDEtbW9udGhcbiAgWzEyMDk2ZTUsIDNdLCAgLy8gMi13ZWVrXG4gIFs2MDQ4ZTUsIDNdLCAgIC8vIDEtd2Vla1xuICBbMTcyOGU1LCAzXSwgICAvLyAyLWRheVxuICBbODY0ZTUsIDNdLCAgICAvLyAxLWRheVxuICBbNDMyZTUsIDJdLCAgICAvLyAxMi1ob3VyXG4gIFsyMTZlNSwgMl0sICAgIC8vIDYtaG91clxuICBbMTA4ZTUsIDJdLCAgICAvLyAzLWhvdXJcbiAgWzM2ZTUsIDJdLCAgICAgLy8gMS1ob3VyXG4gIFsxOGU1LCAxXSwgICAgIC8vIDMwLW1pbnV0ZVxuICBbOWU1LCAxXSwgICAgICAvLyAxNS1taW51dGVcbiAgWzNlNSwgMV0sICAgICAgLy8gNS1taW51dGVcbiAgWzZlNCwgMV0sICAgICAgLy8gMS1taW51dGVcbiAgWzNlNCwgMF0sICAgICAgLy8gMzAtc2Vjb25kXG4gIFsxNWUzLCAwXSwgICAgIC8vIDE1LXNlY29uZFxuICBbNWUzLCAwXSwgICAgICAvLyA1LXNlY29uZFxuICBbMWUzLCAwXSAgICAgICAvLyAxLXNlY29uZFxuXTtcblxudmFyIGVudHJpZXMgPSBbXG4gIHtcbiAgICB0eXBlOiBcInNlY29uZFwiLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgZm9ybWF0OiBcIiVZICViICUtZCAlSDolTTolUy4lTFwiLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShkICogMWUzKTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiAoK2QgLyAxZTMpO1xuICAgIH1cbiAgfSxcbiAge1xuICAgIHR5cGU6IFwibWludXRlXCIsXG4gICAgbWluc3RlcDogMSxcbiAgICBmb3JtYXQ6IFwiJVkgJWIgJS1kICVIOiVNXCIsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQgKiA2ZTQpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIH5+KCtkIC8gNmU0KTtcbiAgICB9XG4gIH0sXG4gIHtcbiAgICB0eXBlOiBcImhvdXJcIixcbiAgICBtaW5zdGVwOiAxLFxuICAgIGZvcm1hdDogXCIlWSAlYiAlLWQgJUg6MDBcIixcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoZCAqIDM2ZTUpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIH5+KCtkIC8gMzZlNSk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogXCJkYXlcIixcbiAgICBtaW5zdGVwOiAxLFxuICAgIHN0ZXA6IFsxLCA3XSxcbiAgICBmb3JtYXQ6IFwiJVkgJWIgJS1kXCIsXG4gICAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKGQgKiA4NjRlNSk7XG4gICAgfSxcbiAgICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gfn4oK2QgLyA4NjRlNSk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogXCJtb250aFwiLFxuICAgIG1pbnN0ZXA6IDEsXG4gICAgc3RlcDogWzEsIDMsIDZdLFxuICAgIGZvcm1hdDogXCIlYiAlWVwiLFxuICAgIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh+fihkIC8gMTIpLCBkICUgMTIsIDEpKTtcbiAgICB9LFxuICAgIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICAgIGlmICh1dGlsLmlzTnVtYmVyKGQpKSBkID0gbmV3IERhdGUoZCk7XG4gICAgICByZXR1cm4gMTIgKiBkLmdldFVUQ0Z1bGxZZWFyKCkgKyBkLmdldFVUQ01vbnRoKCk7XG4gICAgfVxuICB9LFxuICB7XG4gICAgdHlwZTogXCJ5ZWFyXCIsXG4gICAgbWluc3RlcDogMSxcbiAgICBmb3JtYXQ6IFwiJVlcIixcbiAgICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoZCwgMCwgMSkpO1xuICAgIH0sXG4gICAgdW5pdDogZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuICh1dGlsLmlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENGdWxsWWVhcigpO1xuICAgIH1cbiAgfVxuXTtcblxudmFyIG1pbnV0ZU9mSG91ciA9IHtcbiAgdHlwZTogXCJtaW51dGVPZkhvdXJcIixcbiAgbWluOiAwLFxuICBtYXg6IDU5LFxuICBtaW5zdGVwOiAxLFxuICBmb3JtYXQ6IFwiJU1cIixcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCAxLCAwLCBkKSk7XG4gIH0sXG4gIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gKHV0aWwuaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ01pbnV0ZXMoKTtcbiAgfVxufTtcblxudmFyIGhvdXJPZkRheSA9IHtcbiAgdHlwZTogXCJob3VyT2ZEYXlcIixcbiAgbWluOiAwLFxuICBtYXg6IDIzLFxuICBtaW5zdGVwOiAxLFxuICBmb3JtYXQ6IFwiJUhcIixcbiAgZGF0ZTogZnVuY3Rpb24oZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQygxOTcwLCAwLCAxLCBkKSk7XG4gIH0sXG4gIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gKHV0aWwuaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0hvdXJzKCk7XG4gIH1cbn07XG5cbnZhciBkYXlPZldlZWsgPSB7XG4gIHR5cGU6IFwiZGF5T2ZXZWVrXCIsXG4gIG1pbjogMCxcbiAgbWF4OiA2LFxuICBzdGVwOiBbMV0sXG4gIGZvcm1hdDogXCIlYVwiLFxuICBkYXRlOiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKERhdGUuVVRDKDE5NzAsIDAsIDQgKyBkKSk7XG4gIH0sXG4gIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gKHV0aWwuaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ0RheSgpO1xuICB9XG59O1xuXG52YXIgZGF5T2ZNb250aCA9IHtcbiAgdHlwZTogXCJkYXlPZk1vbnRoXCIsXG4gIG1pbjogMSxcbiAgbWF4OiAzMSxcbiAgc3RlcDogWzFdLFxuICBmb3JtYXQ6IFwiJS1kXCIsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgMCwgZCkpO1xuICB9LFxuICB1bml0OiBmdW5jdGlvbihkKSB7XG4gICAgcmV0dXJuICh1dGlsLmlzTnVtYmVyKGQpID8gbmV3IERhdGUoZCkgOiBkKS5nZXRVVENEYXRlKCk7XG4gIH1cbn07XG5cbnZhciBtb250aE9mWWVhciA9IHtcbiAgdHlwZTogXCJtb250aE9mWWVhclwiLFxuICBtaW46IDAsXG4gIG1heDogMTEsXG4gIHN0ZXA6IFsxXSxcbiAgZm9ybWF0OiBcIiViXCIsXG4gIGRhdGU6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoRGF0ZS5VVEMoMTk3MCwgZCAlIDEyLCAxKSk7XG4gIH0sXG4gIHVuaXQ6IGZ1bmN0aW9uKGQpIHtcbiAgICByZXR1cm4gKHV0aWwuaXNOdW1iZXIoZCkgPyBuZXcgRGF0ZShkKSA6IGQpLmdldFVUQ01vbnRoKCk7XG4gIH1cbn07XG5cbnZhciB1bml0cyA9IHtcbiAgXCJzZWNvbmRcIjogICAgICAgZW50cmllc1swXSxcbiAgXCJtaW51dGVcIjogICAgICAgZW50cmllc1sxXSxcbiAgXCJob3VyXCI6ICAgICAgICAgZW50cmllc1syXSxcbiAgXCJkYXlcIjogICAgICAgICAgZW50cmllc1szXSxcbiAgXCJtb250aFwiOiAgICAgICAgZW50cmllc1s0XSxcbiAgXCJ5ZWFyXCI6ICAgICAgICAgZW50cmllc1s1XSxcbiAgXCJtaW51dGVPZkhvdXJcIjogbWludXRlT2ZIb3VyLFxuICBcImhvdXJPZkRheVwiOiAgICBob3VyT2ZEYXksXG4gIFwiZGF5T2ZXZWVrXCI6ICAgIGRheU9mV2VlayxcbiAgXCJkYXlPZk1vbnRoXCI6ICAgZGF5T2ZNb250aCxcbiAgXCJtb250aE9mWWVhclwiOiAgbW9udGhPZlllYXIsXG4gIFwidGltZXN0ZXBzXCI6ICAgIGVudHJpZXNcbn07XG5cbnVuaXRzLmZpbmQgPSBmdW5jdGlvbihzcGFuLCBtaW5iLCBtYXhiKSB7XG4gIHZhciBpLCBsZW4sIGJpbnMsIHN0ZXAgPSBTVEVQU1swXTtcblxuICBmb3IgKGkgPSAxLCBsZW4gPSBTVEVQUy5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xuICAgIHN0ZXAgPSBTVEVQU1tpXTtcbiAgICBpZiAoc3BhbiA+IHN0ZXBbMF0pIHtcbiAgICAgIGJpbnMgPSBzcGFuIC8gc3RlcFswXTtcbiAgICAgIGlmIChiaW5zID4gbWF4Yikge1xuICAgICAgICByZXR1cm4gZW50cmllc1tTVEVQU1tpIC0gMV1bMV1dO1xuICAgICAgfVxuICAgICAgaWYgKGJpbnMgPj0gbWluYikge1xuICAgICAgICByZXR1cm4gZW50cmllc1tzdGVwWzFdXTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGVudHJpZXNbU1RFUFNbU1RFUFMubGVuZ3RoIC0gMV1bMV1dO1xufTtcblxubW9kdWxlLmV4cG9ydHMgPSB1bml0cztcbiIsInZhciBnZW4gPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5nZW4ucmVwZWF0ID0gZnVuY3Rpb24odmFsLCBuKSB7XG4gIHZhciBhID0gQXJyYXkobiksIGk7XG4gIGZvciAoaT0wOyBpPG47ICsraSkgYVtpXSA9IHZhbDtcbiAgcmV0dXJuIGE7XG59O1xuXG5nZW4uemVyb3MgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiBnZW4ucmVwZWF0KDAsIG4pO1xufTtcblxuZ2VuLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgc3RlcCA9IDE7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAyKSB7XG4gICAgICBzdG9wID0gc3RhcnQ7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICB9XG4gIGlmICgoc3RvcCAtIHN0YXJ0KSAvIHN0ZXAgPT0gSW5maW5pdHkpIHRocm93IG5ldyBFcnJvcignSW5maW5pdGUgcmFuZ2UnKTtcbiAgdmFyIHJhbmdlID0gW10sIGkgPSAtMSwgajtcbiAgaWYgKHN0ZXAgPCAwKSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpID4gc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgZWxzZSB3aGlsZSAoKGogPSBzdGFydCArIHN0ZXAgKiArK2kpIDwgc3RvcCkgcmFuZ2UucHVzaChqKTtcbiAgcmV0dXJuIHJhbmdlO1xufTtcblxuZ2VuLnJhbmRvbSA9IHt9O1xuXG5nZW4ucmFuZG9tLnVuaWZvcm0gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICBpZiAobWF4ID09PSB1bmRlZmluZWQpIHtcblx0XHRtYXggPSBtaW47XG5cdFx0bWluID0gMDtcblx0fVxuXHR2YXIgZCA9IG1heCAtIG1pbjtcblx0dmFyIGYgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbWluICsgZCAqIE1hdGgucmFuZG9tKCk7XG5cdH07XG5cdGYuc2FtcGxlcyA9IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIGdlbi56ZXJvcyhuKS5tYXAoZik7IH07XG5cdHJldHVybiBmO1xufTtcblxuZ2VuLnJhbmRvbS5pbnRlZ2VyID0gZnVuY3Rpb24oYSwgYikge1xuXHRpZiAoYiA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0YiA9IGE7XG5cdFx0YSA9IDA7XG5cdH1cbiAgdmFyIGQgPSBiIC0gYTtcblx0dmFyIGYgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gYSArIE1hdGguZmxvb3IoZCAqIE1hdGgucmFuZG9tKCkpO1xuXHR9O1xuXHRmLnNhbXBsZXMgPSBmdW5jdGlvbihuKSB7IHJldHVybiBnZW4uemVyb3MobikubWFwKGYpOyB9O1xuXHRyZXR1cm4gZjtcbn07XG5cbmdlbi5yYW5kb20ubm9ybWFsID0gZnVuY3Rpb24obWVhbiwgc3RkZXYpIHtcblx0bWVhbiA9IG1lYW4gfHwgMDtcblx0c3RkZXYgPSBzdGRldiB8fCAxO1xuXHR2YXIgbmV4dCA9IHVuZGVmaW5lZDtcblx0dmFyIGYgPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgeCA9IDAsIHkgPSAwLCByZHMsIGM7XG5cdFx0aWYgKG5leHQgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0eCA9IG5leHQ7XG5cdFx0XHRuZXh0ID0gdW5kZWZpbmVkO1xuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fVxuXHRcdGRvIHtcblx0XHRcdHggPSBNYXRoLnJhbmRvbSgpKjItMTtcblx0XHRcdHkgPSBNYXRoLnJhbmRvbSgpKjItMTtcblx0XHRcdHJkcyA9IHgqeCArIHkqeTtcblx0XHR9IHdoaWxlIChyZHMgPT0gMCB8fCByZHMgPiAxKTtcblx0XHRjID0gTWF0aC5zcXJ0KC0yKk1hdGgubG9nKHJkcykvcmRzKTsgLy8gQm94LU11bGxlciB0cmFuc2Zvcm1cblx0XHRuZXh0ID0gbWVhbiArIHkqYypzdGRldjtcblx0XHRyZXR1cm4gbWVhbiArIHgqYypzdGRldjtcblx0fTtcblx0Zi5zYW1wbGVzID0gZnVuY3Rpb24obikgeyByZXR1cm4gZ2VuLnplcm9zKG4pLm1hcChmKTsgfTtcblx0cmV0dXJuIGY7XG59OyIsInZhciBzdGF0cyA9IHJlcXVpcmUoJy4vc3RhdHMnKTtcbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG52YXIgYmluID0gcmVxdWlyZSgnLi9iaW4nKTtcbnZhciBnZW4gPSByZXF1aXJlKCcuL2dlbmVyYXRlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsdWVzLCBmLCBvcHRpb25zKSB7XG4gIGlmIChvcHRpb25zID09PSB1bmRlZmluZWQgJiYgIXV0aWwuaXNGdW5jdGlvbihmKSkgeyBvcHRpb25zID0gZjsgZiA9IG51bGw7IH1cblxuICB2YXIgdHlwZSA9IG9wdGlvbnMgJiYgb3B0aW9ucy50eXBlIHx8IGluZmVyKHZhbHVlcywgZik7XG4gIGlmICh0eXBlICE9PSAnbnVtYmVyJyAmJiB0eXBlICE9PSAnZGF0ZScgJiYgdHlwZSAhPT0gJ2ludGVnZXInKSB7XG4gICAgcmV0dXJuIGNhdGVnb3JpY2FsKHZhbHVlcywgZiwgb3B0aW9ucyAmJiBvcHRpb25zLnNvcnQpO1xuICB9XG5cbiAgdmFyIGV4dCA9IHN0YXRzLmV4dGVudCh2YWx1ZXMsIGYpLFxuICAgICAgb3B0ID0gdXRpbC5leHRlbmQoe21pbjogZXh0WzBdLCBtYXg6IGV4dFsxXX0sIG9wdGlvbnMpO1xuICBpZiAodHlwZSA9PT0gJ2ludGVnZXInICYmIG9wdC5taW5zdGVwID09IG51bGwpIG9wdC5taW5zdGVwID0gMTtcbiAgdmFyIGIgPSB0eXBlID09PSAnZGF0ZScgPyBiaW4uZGF0ZShvcHQpIDogYmluKG9wdCk7XG4gIHJldHVybiBudW1lcmljYWwodmFsdWVzLCBmLCBiKTtcbn07XG5cbmZ1bmN0aW9uIGluZmVyKHZhbHVlcywgZikge1xuICB2YXIgdiA9IG51bGwsIGk7XG5cbiAgLy8gaWYgZGF0YSBhcnJheSBoYXMgdHlwZSBhbm5vdGF0aW9ucywgdXNlIHRoZW1cbiAgaWYgKHZhbHVlcy50eXBlcykge1xuICAgIHYgPSBmKHZhbHVlcy50eXBlcyk7XG4gICAgaWYgKHV0aWwuaXNTdHJpbmcodikpIHJldHVybiB2O1xuICB9XG5cbiAgZm9yIChpPTA7ICF1dGlsLmlzTm90TnVsbCh2KSAmJiBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICB9XG4gIHJldHVybiB1dGlsLmlzRGF0ZSh2KSA/ICdkYXRlJyA6IHV0aWwuaXNOdW1iZXIodikgPyAnbnVtYmVyJyA6ICdzdHJpbmcnO1xufVxuXG5mdW5jdGlvbiBudW1lcmljYWwodmFsdWVzLCBmLCBiKSB7XG4gIHZhciBoID0gZ2VuLnJhbmdlKGIuc3RhcnQsIGIuc3RvcCArIGIuc3RlcC8yLCBiLnN0ZXApXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiB7dmFsdWU6IGIudmFsdWUodiksIGNvdW50OiAwfTsgfSk7XG5cbiAgZm9yICh2YXIgaT0wLCB2LCBqOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh1dGlsLmlzTm90TnVsbCh2KSkge1xuICAgICAgaiA9IGIuaW5kZXgodik7XG4gICAgICBpZiAoaiA8IDAgfHwgaiA+PSBoLmxlbmd0aCB8fCAhaXNGaW5pdGUoaikpIGNvbnRpbnVlO1xuICAgICAgaFtqXS5jb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICBoLmJpbnMgPSBiO1xuICByZXR1cm4gaDtcbn1cblxuZnVuY3Rpb24gY2F0ZWdvcmljYWwodmFsdWVzLCBmLCBzb3J0KSB7XG4gIHZhciBjID0gc3RhdHMudW5pcXVlKHZhbHVlcywgZikuY291bnRzO1xuICByZXR1cm4gdXRpbC5rZXlzKGMpXG4gICAgLm1hcChmdW5jdGlvbihrKSB7IHJldHVybiB7dmFsdWU6IGssIGNvdW50OiBjW2tdfTsgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3Ioc29ydCA/IFwiLWNvdW50XCIgOiBcIit2YWx1ZVwiKSk7XG59IiwidmFyIGQzID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cuZDMgOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsLmQzIDogbnVsbCk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZGF0YSwgZm9ybWF0KSB7XG4gIHZhciBkID0gZDMuY3N2LnBhcnNlKGRhdGEgPyBkYXRhLnRvU3RyaW5nKCkgOiBkYXRhKTtcbiAgcmV0dXJuIGQ7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gIGpzb246IHJlcXVpcmUoJy4vanNvbicpLFxuICBjc3Y6IHJlcXVpcmUoJy4vY3N2JyksXG4gIHRzdjogcmVxdWlyZSgnLi90c3YnKSxcbiAgdG9wb2pzb246IHJlcXVpcmUoJy4vdG9wb2pzb24nKSxcbiAgdHJlZWpzb246IHJlcXVpcmUoJy4vdHJlZWpzb24nKVxufTsiLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uLy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIGQgPSB1dGlsLmlzT2JqZWN0KGRhdGEpICYmICF1dGlsLmlzQnVmZmVyKGRhdGEpXG4gICAgPyBkYXRhIDogSlNPTi5wYXJzZShkYXRhKTtcbiAgaWYgKGZvcm1hdCAmJiBmb3JtYXQucHJvcGVydHkpIHtcbiAgICBkID0gdXRpbC5hY2Nlc3Nvcihmb3JtYXQucHJvcGVydHkpKGQpO1xuICB9XG4gIHJldHVybiBkO1xufTtcbiIsInZhciBqc29uID0gcmVxdWlyZSgnLi9qc29uJyk7XG52YXIgdG9wb2pzb24gPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy50b3BvanNvbiA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwudG9wb2pzb24gOiBudWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgaWYgKHRvcG9qc29uID09IG51bGwpIHsgdGhyb3cgRXJyb3IoXCJUb3BvSlNPTiBsaWJyYXJ5IG5vdCBsb2FkZWQuXCIpOyB9XG5cbiAgdmFyIHQgPSBqc29uKGRhdGEsIGZvcm1hdCksIG9iajtcblxuICBpZiAoZm9ybWF0ICYmIGZvcm1hdC5mZWF0dXJlKSB7XG4gICAgaWYgKG9iaiA9IHQub2JqZWN0c1tmb3JtYXQuZmVhdHVyZV0pIHtcbiAgICAgIHJldHVybiB0b3BvanNvbi5mZWF0dXJlKHQsIG9iaikuZmVhdHVyZXNcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIFRvcG9KU09OIG9iamVjdDogXCIrZm9ybWF0LmZlYXR1cmUpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChmb3JtYXQgJiYgZm9ybWF0Lm1lc2gpIHtcbiAgICBpZiAob2JqID0gdC5vYmplY3RzW2Zvcm1hdC5tZXNoXSkge1xuICAgICAgcmV0dXJuIFt0b3BvanNvbi5tZXNoKHQsIHQub2JqZWN0c1tmb3JtYXQubWVzaF0pXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgRXJyb3IoXCJJbnZhbGlkIFRvcG9KU09OIG9iamVjdDogXCIgKyBmb3JtYXQubWVzaCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKFwiTWlzc2luZyBUb3BvSlNPTiBmZWF0dXJlIG9yIG1lc2ggcGFyYW1ldGVyLlwiKTtcbiAgfVxuXG4gIHJldHVybiBbXTtcbn07XG4iLCJ2YXIganNvbiA9IHJlcXVpcmUoJy4vanNvbicpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGRhdGEsIGZvcm1hdCkge1xuICBkYXRhID0ganNvbihkYXRhLCBmb3JtYXQpO1xuICByZXR1cm4gdG9UYWJsZShkYXRhLCAoZm9ybWF0ICYmIGZvcm1hdC5jaGlsZHJlbikpO1xufTtcblxuZnVuY3Rpb24gdG9UYWJsZShyb290LCBjaGlsZHJlbkZpZWxkKSB7XG4gIGNoaWxkcmVuRmllbGQgPSBjaGlsZHJlbkZpZWxkIHx8IFwiY2hpbGRyZW5cIjtcbiAgdmFyIHRhYmxlID0gW107XG4gIFxuICBmdW5jdGlvbiB2aXNpdChub2RlLCBwYXJlbnQpIHtcbiAgICB0YWJsZS5wdXNoKG5vZGUpO1xuICAgIHZhciBjaGlsZHJlbiA9IG5vZGVbY2hpbGRyZW5GaWVsZF07XG4gICAgaWYgKGNoaWxkcmVuKSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8Y2hpbGRyZW4ubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmlzaXQoY2hpbGRyZW5baV0sIG5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBcbiAgdmlzaXQocm9vdCwgbnVsbCk7XG4gIHJldHVybiAodGFibGUucm9vdCA9IHJvb3QsIHRhYmxlKTtcbn0iLCJ2YXIgZDMgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvdy5kMyA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWwuZDMgOiBudWxsKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmb3JtYXQpIHtcbiAgdmFyIGQgPSBkMy50c3YucGFyc2UoZGF0YSA/IGRhdGEudG9TdHJpbmcoKSA6IGRhdGEpO1xuICByZXR1cm4gZDtcbn07XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuLy8gTWF0Y2hlcyBhYnNvbHV0ZSBVUkxzIHdpdGggb3B0aW9uYWwgcHJvdG9jb2xcbi8vICAgaHR0cHM6Ly8uLi4gICAgZmlsZTovLy4uLiAgICAvLy4uLlxudmFyIHByb3RvY29sX3JlID0gL14oW0EtWmEtel0rOik/XFwvXFwvLztcblxuLy8gU3BlY2lhbCB0cmVhdG1lbnQgaW4gbm9kZS5qcyBmb3IgdGhlIGZpbGU6IHByb3RvY29sXG52YXIgZmlsZVByb3RvY29sID0gJ2ZpbGU6Ly8nO1xuXG4vLyBWYWxpZGF0ZSBhbmQgY2xlYW51cCBVUkwgdG8gZW5zdXJlIHRoYXQgaXQgaXMgYWxsb3dlZCB0byBiZSBhY2Nlc3NlZFxuLy8gUmV0dXJucyBjbGVhbmVkIHVwIFVSTCwgb3IgZmFsc2UgaWYgYWNjZXNzIGlzIG5vdCBhbGxvd2VkXG5mdW5jdGlvbiBzYW5pdGl6ZVVybChvcHQpIHtcbiAgdmFyIHVybCA9IG9wdC51cmw7XG4gIGlmICghdXJsICYmIG9wdC5maWxlKSB7IHJldHVybiBmaWxlUHJvdG9jb2wgKyBvcHQuZmlsZTsgfVxuXG4gIC8vIEluIGNhc2UgdGhpcyBpcyBhIHJlbGF0aXZlIHVybCAoaGFzIG5vIGhvc3QpLCBwcmVwZW5kIG9wdC5iYXNlVVJMXG4gIGlmIChvcHQuYmFzZVVSTCAmJiAhcHJvdG9jb2xfcmUudGVzdCh1cmwpKSB7XG4gICAgaWYgKCF1dGlsLnN0YXJ0c1dpdGgodXJsLCAnLycpICYmIG9wdC5iYXNlVVJMW29wdC5iYXNlVVJMLmxlbmd0aC0xXSAhPT0gJy8nKSB7XG4gICAgICB1cmwgPSAnLycgKyB1cmw7IC8vIEVuc3VyZSB0aGF0IHRoZXJlIGlzIGEgc2xhc2ggYmV0d2VlbiB0aGUgYmFzZVVSTCAoZS5nLiBob3N0bmFtZSkgYW5kIHVybFxuICAgIH1cbiAgICB1cmwgPSBvcHQuYmFzZVVSTCArIHVybDtcbiAgfVxuICAvLyByZWxhdGl2ZSBwcm90b2NvbCwgc3RhcnRzIHdpdGggJy8vJ1xuICBpZiAodXRpbC5pc05vZGUgJiYgdXRpbC5zdGFydHNXaXRoKHVybCwgJy8vJykpIHtcbiAgICB1cmwgPSAob3B0LmRlZmF1bHRQcm90b2NvbCB8fCAnaHR0cCcpICsgJzonICsgdXJsO1xuICB9XG4gIC8vIElmIG9wdC5kb21haW5XaGl0ZUxpc3QgaXMgc2V0LCBvbmx5IGFsbG93cyB1cmwsIHdob3NlIGhvc3RuYW1lXG4gIC8vICogSXMgdGhlIHNhbWUgYXMgdGhlIG9yaWdpbiAod2luZG93LmxvY2F0aW9uLmhvc3RuYW1lKVxuICAvLyAqIEVxdWFscyBvbmUgb2YgdGhlIHZhbHVlcyBpbiB0aGUgd2hpdGVsaXN0XG4gIC8vICogSXMgYSBwcm9wZXIgc3ViZG9tYWluIG9mIG9uZSBvZiB0aGUgdmFsdWVzIGluIHRoZSB3aGl0ZWxpc3RcbiAgaWYgKG9wdC5kb21haW5XaGl0ZUxpc3QpIHtcbiAgICB2YXIgZG9tYWluLCBvcmlnaW47XG4gICAgaWYgKHV0aWwuaXNOb2RlKSB7XG4gICAgICAvLyByZWxhdGl2ZSBwcm90b2NvbCBpcyBicm9rZW46IGh0dHBzOi8vZ2l0aHViLmNvbS9kZWZ1bmN0em9tYmllL25vZGUtdXJsL2lzc3Vlcy81XG4gICAgICB2YXIgcGFydHMgPSByZXF1aXJlKCd1cmwnKS5wYXJzZSh1cmwpO1xuICAgICAgZG9tYWluID0gcGFydHMuaG9zdG5hbWU7XG4gICAgICBvcmlnaW4gPSBudWxsO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcbiAgICAgIGEuaHJlZiA9IHVybDtcbiAgICAgIC8vIEZyb20gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy83MzY1MTMvaG93LWRvLWktcGFyc2UtYS11cmwtaW50by1ob3N0bmFtZS1hbmQtcGF0aC1pbi1qYXZhc2NyaXB0XG4gICAgICAvLyBJRSBkb2Vzbid0IHBvcHVsYXRlIGFsbCBsaW5rIHByb3BlcnRpZXMgd2hlbiBzZXR0aW5nIC5ocmVmIHdpdGggYSByZWxhdGl2ZSBVUkwsXG4gICAgICAvLyBob3dldmVyIC5ocmVmIHdpbGwgcmV0dXJuIGFuIGFic29sdXRlIFVSTCB3aGljaCB0aGVuIGNhbiBiZSB1c2VkIG9uIGl0c2VsZlxuICAgICAgLy8gdG8gcG9wdWxhdGUgdGhlc2UgYWRkaXRpb25hbCBmaWVsZHMuXG4gICAgICBpZiAoYS5ob3N0ID09IFwiXCIpIHtcbiAgICAgICAgYS5ocmVmID0gYS5ocmVmO1xuICAgICAgfVxuICAgICAgZG9tYWluID0gYS5ob3N0bmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgb3JpZ2luID0gd2luZG93LmxvY2F0aW9uLmhvc3RuYW1lO1xuICAgIH1cblxuICAgIGlmIChvcmlnaW4gIT09IGRvbWFpbikge1xuICAgICAgdmFyIHdoaXRlTGlzdGVkID0gb3B0LmRvbWFpbldoaXRlTGlzdC5zb21lKGZ1bmN0aW9uIChkKSB7XG4gICAgICAgIHZhciBpZHggPSBkb21haW4ubGVuZ3RoIC0gZC5sZW5ndGg7XG4gICAgICAgIHJldHVybiBkID09PSBkb21haW4gfHxcbiAgICAgICAgICAoaWR4ID4gMSAmJiBkb21haW5baWR4LTFdID09PSAnLicgJiYgZG9tYWluLmxhc3RJbmRleE9mKGQpID09PSBpZHgpO1xuICAgICAgfSk7XG4gICAgICBpZiAoIXdoaXRlTGlzdGVkKSB7XG4gICAgICAgIHRocm93ICdVUkwgaXMgbm90IHdoaXRlbGlzdGVkOiAnICsgdXJsO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gdXJsO1xufVxuXG5mdW5jdGlvbiBsb2FkKG9wdCwgY2FsbGJhY2spIHtcbiAgdmFyIGVycm9yID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oZSkgeyB0aHJvdyBlOyB9O1xuICBcbiAgdHJ5IHtcbiAgICB2YXIgdXJsID0gbG9hZC5zYW5pdGl6ZVVybChvcHQpOyAvLyBlbmFibGUgb3ZlcnJpZGVcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgZXJyb3IoZXJyKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXVybCkge1xuICAgIGVycm9yKCdJbnZhbGlkIFVSTDogJyArIHVybCk7XG4gIH0gZWxzZSBpZiAoIXV0aWwuaXNOb2RlKSB7XG4gICAgLy8gaW4gYnJvd3NlciwgdXNlIHhoclxuICAgIHJldHVybiB4aHIodXJsLCBjYWxsYmFjayk7XG4gIH0gZWxzZSBpZiAodXRpbC5zdGFydHNXaXRoKHVybCwgZmlsZVByb3RvY29sKSkge1xuICAgIC8vIGluIG5vZGUuanMsIGlmIHVybCBzdGFydHMgd2l0aCAnZmlsZTovLycsIHN0cmlwIGl0IGFuZCBsb2FkIGZyb20gZmlsZVxuICAgIHJldHVybiBmaWxlKHVybC5zbGljZShmaWxlUHJvdG9jb2wubGVuZ3RoKSwgY2FsbGJhY2spO1xuICB9IGVsc2Uge1xuICAgIC8vIGZvciByZWd1bGFyIFVSTHMgaW4gbm9kZS5qc1xuICAgIHJldHVybiBodHRwKHVybCwgY2FsbGJhY2spO1xuICB9XG59XG5cbmZ1bmN0aW9uIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHtcbiAgdmFyIHR5cGUgPSByZXF1ZXN0LnJlc3BvbnNlVHlwZTtcbiAgcmV0dXJuIHR5cGUgJiYgdHlwZSAhPT0gXCJ0ZXh0XCJcbiAgICAgID8gcmVxdWVzdC5yZXNwb25zZSAvLyBudWxsIG9uIGVycm9yXG4gICAgICA6IHJlcXVlc3QucmVzcG9uc2VUZXh0OyAvLyBcIlwiIG9uIGVycm9yXG59XG5cbmZ1bmN0aW9uIHhocih1cmwsIGNhbGxiYWNrKSB7XG4gIHZhciBhc3luYyA9ICEhY2FsbGJhY2s7XG4gIHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0O1xuICAvLyBJZiBJRSBkb2VzIG5vdCBzdXBwb3J0IENPUlMsIHVzZSBYRG9tYWluUmVxdWVzdCAoY29waWVkIGZyb20gZDMueGhyKVxuICBpZiAodGhpcy5YRG9tYWluUmVxdWVzdFxuICAgICAgJiYgIShcIndpdGhDcmVkZW50aWFsc1wiIGluIHJlcXVlc3QpXG4gICAgICAmJiAvXihodHRwKHMpPzopP1xcL1xcLy8udGVzdCh1cmwpKSByZXF1ZXN0ID0gbmV3IFhEb21haW5SZXF1ZXN0O1xuXG4gIGZ1bmN0aW9uIHJlc3BvbmQoKSB7XG4gICAgdmFyIHN0YXR1cyA9IHJlcXVlc3Quc3RhdHVzO1xuICAgIGlmICghc3RhdHVzICYmIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpIHx8IHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwIHx8IHN0YXR1cyA9PT0gMzA0KSB7XG4gICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrKHJlcXVlc3QsIG51bGwpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChhc3luYykge1xuICAgIFwib25sb2FkXCIgaW4gcmVxdWVzdFxuICAgICAgPyByZXF1ZXN0Lm9ubG9hZCA9IHJlcXVlc3Qub25lcnJvciA9IHJlc3BvbmRcbiAgICAgIDogcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHsgcmVxdWVzdC5yZWFkeVN0YXRlID4gMyAmJiByZXNwb25kKCk7IH07XG4gIH1cbiAgXG4gIHJlcXVlc3Qub3BlbihcIkdFVFwiLCB1cmwsIGFzeW5jKTtcbiAgcmVxdWVzdC5zZW5kKCk7XG4gIFxuICBpZiAoIWFzeW5jICYmIHhockhhc1Jlc3BvbnNlKHJlcXVlc3QpKSB7XG4gICAgcmV0dXJuIHJlcXVlc3QucmVzcG9uc2VUZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIGZpbGUoZmlsZSwgY2FsbGJhY2spIHtcbiAgdmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcbiAgaWYgKCFjYWxsYmFjaykge1xuICAgIHJldHVybiBmcy5yZWFkRmlsZVN5bmMoZmlsZSwgJ3V0ZjgnKTtcbiAgfVxuICByZXF1aXJlKCdmcycpLnJlYWRGaWxlKGZpbGUsIGNhbGxiYWNrKTtcbn1cblxuZnVuY3Rpb24gaHR0cCh1cmwsIGNhbGxiYWNrKSB7XG4gIGlmICghY2FsbGJhY2spIHtcbiAgICByZXR1cm4gcmVxdWlyZSgnc3luYy1yZXF1ZXN0JykoJ0dFVCcsIHVybCkuZ2V0Qm9keSgpO1xuICB9XG4gIHJlcXVpcmUoJ3JlcXVlc3QnKSh1cmwsIGZ1bmN0aW9uKGVycm9yLCByZXNwb25zZSwgYm9keSkge1xuICAgIGlmICghZXJyb3IgJiYgcmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gMjAwKSB7XG4gICAgICBjYWxsYmFjayhudWxsLCBib2R5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbGJhY2soZXJyb3IsIG51bGwpO1xuICAgIH1cbiAgfSk7XG59XG5cbmxvYWQuc2FuaXRpemVVcmwgPSBzYW5pdGl6ZVVybDtcblxubW9kdWxlLmV4cG9ydHMgPSBsb2FkO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgbG9hZCA9IHJlcXVpcmUoJy4vbG9hZCcpO1xudmFyIHJlYWQgPSByZXF1aXJlKCcuL3JlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB1dGlsXG4gIC5rZXlzKHJlYWQuZm9ybWF0cylcbiAgLnJlZHVjZShmdW5jdGlvbihvdXQsIHR5cGUpIHtcbiAgICBvdXRbdHlwZV0gPSBmdW5jdGlvbihvcHQsIGZvcm1hdCwgY2FsbGJhY2spIHtcbiAgICAgIC8vIHByb2Nlc3MgYXJndW1lbnRzXG4gICAgICBpZiAodXRpbC5pc1N0cmluZyhvcHQpKSBvcHQgPSB7dXJsOiBvcHR9O1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDIgJiYgdXRpbC5pc0Z1bmN0aW9uKGZvcm1hdCkpIHtcbiAgICAgICAgY2FsbGJhY2sgPSBmb3JtYXQ7XG4gICAgICAgIGZvcm1hdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cblxuICAgICAgLy8gc2V0IHVwIHJlYWQgZm9ybWF0XG4gICAgICBmb3JtYXQgPSB1dGlsLmV4dGVuZCh7cGFyc2U6ICdhdXRvJ30sIGZvcm1hdCk7XG4gICAgICBmb3JtYXQudHlwZSA9IHR5cGU7XG5cbiAgICAgIC8vIGxvYWQgZGF0YVxuICAgICAgdmFyIGRhdGEgPSBsb2FkKG9wdCwgY2FsbGJhY2sgPyBmdW5jdGlvbihlcnJvciwgZGF0YSkge1xuICAgICAgICBpZiAoZXJyb3IpIGNhbGxiYWNrKGVycm9yLCBudWxsKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAvLyBkYXRhIGxvYWRlZCwgbm93IHBhcnNlIGl0IChhc3luYylcbiAgICAgICAgICBkYXRhID0gcmVhZChkYXRhLCBmb3JtYXQpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgY2FsbGJhY2soZSwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2sobnVsbCwgZGF0YSk7XG4gICAgICB9IDogdW5kZWZpbmVkKTtcbiAgICAgIFxuICAgICAgLy8gZGF0YSBsb2FkZWQsIG5vdyBwYXJzZSBpdCAoc3luYylcbiAgICAgIGlmIChkYXRhKSByZXR1cm4gcmVhZChkYXRhLCBmb3JtYXQpO1xuICAgIH07XG4gICAgcmV0dXJuIG91dDtcbiAgfSwge30pO1xuIiwidmFyIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG52YXIgZm9ybWF0cyA9IHJlcXVpcmUoJy4vZm9ybWF0cycpO1xuXG52YXIgUEFSU0VSUyA9IHtcbiAgYm9vbGVhbjogdXRpbC5ib29sZWFuLFxuICBpbnRlZ2VyOiB1dGlsLm51bWJlcixcbiAgbnVtYmVyOiAgdXRpbC5udW1iZXIsXG4gIGRhdGU6ICAgIHV0aWwuZGF0ZSxcbiAgc3RyaW5nOiAgdXRpbC5pZGVudGl0eVxufTtcblxudmFyIFRFU1RTID0ge1xuICBib29sZWFuOiBmdW5jdGlvbih4KSB7IHJldHVybiB4PT09XCJ0cnVlXCIgfHwgeD09PVwiZmFsc2VcIiB8fCB1dGlsLmlzQm9vbGVhbih4KTsgfSxcbiAgaW50ZWdlcjogZnVuY3Rpb24oeCkgeyByZXR1cm4gVEVTVFMubnVtYmVyKHgpICYmICh4PSt4KSA9PT0gfn54OyB9LFxuICBudW1iZXI6IGZ1bmN0aW9uKHgpIHsgcmV0dXJuICFpc05hTigreCkgJiYgIXV0aWwuaXNEYXRlKHgpOyB9LFxuICBkYXRlOiBmdW5jdGlvbih4KSB7IHJldHVybiAhaXNOYU4oRGF0ZS5wYXJzZSh4KSk7IH1cbn07XG5cbmZ1bmN0aW9uIHJlYWQoZGF0YSwgZm9ybWF0KSB7XG4gIHZhciB0eXBlID0gKGZvcm1hdCAmJiBmb3JtYXQudHlwZSkgfHwgXCJqc29uXCI7XG4gIGRhdGEgPSBmb3JtYXRzW3R5cGVdKGRhdGEsIGZvcm1hdCk7XG4gIGlmIChmb3JtYXQgJiYgZm9ybWF0LnBhcnNlKSBwYXJzZShkYXRhLCBmb3JtYXQucGFyc2UpO1xuICByZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gaW5mZXJfdHlwZSh2YWx1ZXMsIGYpIHtcbiAgdmFyIGksIGosIHY7XG5cbiAgLy8gdHlwZXMgdG8gdGVzdCBmb3IsIGluIHByZWNlZGVuY2Ugb3JkZXJcbiAgdmFyIHR5cGVzID0gWydib29sZWFuJywgJ2ludGVnZXInLCAnbnVtYmVyJywgJ2RhdGUnXTtcblxuICBmb3IgKGk9MDsgaTx2YWx1ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAvLyBnZXQgbmV4dCB2YWx1ZSB0byB0ZXN0XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgLy8gdGVzdCB2YWx1ZSBhZ2FpbnN0IHJlbWFpbmluZyB0eXBlc1xuICAgIGZvciAoaj0wOyBqPHR5cGVzLmxlbmd0aDsgKytqKSB7XG4gICAgICBpZiAodXRpbC5pc05vdE51bGwodikgJiYgIVRFU1RTW3R5cGVzW2pdXSh2KSkge1xuICAgICAgICB0eXBlcy5zcGxpY2UoaiwgMSk7XG4gICAgICAgIGogLT0gMTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gaWYgbm8gdHlwZXMgbGVmdCwgcmV0dXJuICdzdHJpbmcnXG4gICAgaWYgKHR5cGVzLmxlbmd0aCA9PT0gMCkgcmV0dXJuICdzdHJpbmcnO1xuICB9XG5cbiAgcmV0dXJuIHR5cGVzWzBdO1xufVxuXG5mdW5jdGlvbiBpbmZlcl90eXBlcyhkYXRhLCBmaWVsZHMpIHtcbiAgZmllbGRzID0gZmllbGRzIHx8IHV0aWwua2V5cyhkYXRhWzBdKTtcbiAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoZnVuY3Rpb24odHlwZXMsIGYpIHtcbiAgICB2YXIgdHlwZSA9IGluZmVyX3R5cGUoZGF0YSwgdXRpbC5hY2Nlc3NvcihmKSk7XG4gICAgaWYgKFBBUlNFUlNbdHlwZV0pIHR5cGVzW2ZdID0gdHlwZTtcbiAgICByZXR1cm4gdHlwZXM7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gcGFyc2UoZGF0YSwgdHlwZXMpIHtcbiAgdmFyIGNvbHMsIHBhcnNlcnMsIGQsIGksIGosIGNsZW4sIGxlbiA9IGRhdGEubGVuZ3RoO1xuXG4gIHR5cGVzID0gKHR5cGVzPT09J2F1dG8nKSA/IGluZmVyX3R5cGVzKGRhdGEpIDogdXRpbC5kdXBsaWNhdGUodHlwZXMpO1xuICBjb2xzID0gdXRpbC5rZXlzKHR5cGVzKTtcbiAgcGFyc2VycyA9IGNvbHMubWFwKGZ1bmN0aW9uKGMpIHsgcmV0dXJuIFBBUlNFUlNbdHlwZXNbY11dOyB9KTtcblxuICBmb3IgKGk9MCwgY2xlbj1jb2xzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIGQgPSBkYXRhW2ldO1xuICAgIGZvciAoaj0wOyBqPGNsZW47ICsraikge1xuICAgICAgZFtjb2xzW2pdXSA9IHBhcnNlcnNbal0oZFtjb2xzW2pdXSk7XG4gICAgfVxuICB9XG4gIGRhdGEudHlwZXMgPSB0eXBlcztcbn1cblxucmVhZC50eXBlID0gaW5mZXJfdHlwZTtcbnJlYWQudHlwZXMgPSBpbmZlcl90eXBlcztcbnJlYWQuZm9ybWF0cyA9IGZvcm1hdHM7XG5yZWFkLnBhcnNlID0gcGFyc2U7XG5tb2R1bGUuZXhwb3J0cyA9IHJlYWQ7XG4iLCJ2YXIgdXRpbCA9IHJlcXVpcmUoJy4vdXRpbCcpO1xuXG52YXIgZGwgPSB7XG4gIGxvYWQ6ICAgICAgcmVxdWlyZSgnLi9pbXBvcnQvbG9hZCcpLFxuICByZWFkOiAgICAgIHJlcXVpcmUoJy4vaW1wb3J0L3JlYWQnKSxcbiAgYmluOiAgICAgICByZXF1aXJlKCcuL2JpbicpLFxuICBoaXN0b2dyYW06IHJlcXVpcmUoJy4vaGlzdG9ncmFtJyksXG4gIHN1bW1hcnk6ICAgcmVxdWlyZSgnLi9zdW1tYXJ5JyksXG4gIHRlbXBsYXRlOiAgcmVxdWlyZSgnLi90ZW1wbGF0ZScpLFxuICBkYXRldW5pdHM6IHJlcXVpcmUoJy4vZGF0ZS11bml0cycpXG59O1xuXG51dGlsLmV4dGVuZChkbCwgdXRpbCk7XG51dGlsLmV4dGVuZChkbCwgcmVxdWlyZSgnLi9nZW5lcmF0ZScpKTtcbnV0aWwuZXh0ZW5kKGRsLCByZXF1aXJlKCcuL3N0YXRzJykpO1xudXRpbC5leHRlbmQoZGwsIHJlcXVpcmUoJy4vaW1wb3J0L2xvYWRlcnMnKSk7XG5cbm1vZHVsZS5leHBvcnRzID0gZGw7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBnZW4gPSByZXF1aXJlKCcuL2dlbmVyYXRlJyk7XG52YXIgc3RhdHMgPSB7fTtcblxuLy8gQ29sbGVjdCB1bmlxdWUgdmFsdWVzIGFuZCBhc3NvY2lhdGVkIGNvdW50cy5cbi8vIE91dHB1dDogYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb2JzZXJ2ZWQgb3JkZXJcbi8vIFRoZSBhcnJheSBpbmNsdWRlcyBhbiBhZGRpdGlvbmFsICdjb3VudHMnIHByb3BlcnR5LFxuLy8gd2hpY2ggaXMgYSBoYXNoIGZyb20gdW5pcXVlIHZhbHVlcyB0byBvY2N1cnJlbmNlIGNvdW50cy5cbnN0YXRzLnVuaXF1ZSA9IGZ1bmN0aW9uKHZhbHVlcywgZiwgcmVzdWx0cykge1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGg9PT0wKSByZXR1cm4gW107XG4gIHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuICB2YXIgdSA9IHt9LCB2LCBpO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2IGluIHUpIHtcbiAgICAgIHVbdl0gKz0gMTtcbiAgICB9IGVsc2Uge1xuICAgICAgdVt2XSA9IDE7XG4gICAgICByZXN1bHRzLnB1c2godik7XG4gICAgfVxuICB9XG4gIHJlc3VsdHMuY291bnRzID0gdTtcbiAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG4vLyBDb3VudCB0aGUgbnVtYmVyIG9mIG5vbi1udWxsIHZhbHVlcy5cbnN0YXRzLmNvdW50ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICB2YXIgdiwgaSwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ICE9IG51bGwpIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBkaXN0aW5jdCB2YWx1ZXMuXG5zdGF0cy5jb3VudC5kaXN0aW5jdCA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGg9PT0wKSByZXR1cm4gMDtcbiAgdmFyIHUgPSB7fSwgdiwgaSwgY291bnQgPSAwO1xuICBmb3IgKGk9MCwgbj12YWx1ZXMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2IGluIHUpIGNvbnRpbnVlO1xuICAgIHVbdl0gPSAxO1xuICAgIGNvdW50ICs9IDE7XG4gIH1cbiAgcmV0dXJuIGNvdW50O1xufTtcblxuLy8gQ291bnQgdGhlIG51bWJlciBvZiBudWxsIG9yIHVuZGVmaW5lZCB2YWx1ZXMuXG5zdGF0cy5jb3VudC5udWxscyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGg9PT0wKSByZXR1cm4gMDtcbiAgdmFyIHYsIGksIGNvdW50ID0gMDtcbiAgZm9yIChpPTAsIG49dmFsdWVzLmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICBpZiAodiA9PSBudWxsKSBjb3VudCArPSAxO1xuICB9XG4gIHJldHVybiBjb3VudDtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG1lZGlhbiBvZiBhbiBhcnJheSBvZiBudW1iZXJzLlxuc3RhdHMubWVkaWFuID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIGlmICghdXRpbC5pc0FycmF5KHZhbHVlcykgfHwgdmFsdWVzLmxlbmd0aD09PTApIHJldHVybiAwO1xuICBpZiAoZikgdmFsdWVzID0gdmFsdWVzLm1hcChmKTtcbiAgdmFsdWVzID0gdmFsdWVzLmZpbHRlcih1dGlsLmlzTm90TnVsbCkuc29ydCh1dGlsLmNtcCk7XG4gIHZhciBoYWxmID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoLzIpO1xuICBpZiAodmFsdWVzLmxlbmd0aCAlIDIpIHtcbiAgICByZXR1cm4gdmFsdWVzW2hhbGZdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAodmFsdWVzW2hhbGYtMV0gKyB2YWx1ZXNbaGFsZl0pIC8gMi4wO1xuICB9XG59O1xuXG4vLyBDb21wdXRlIHRoZSBxdWFudGlsZSBvZiBhIHNvcnRlZCBhcnJheSBvZiBudW1iZXJzLlxuLy8gQWRhcHRlZCBmcm9tIHRoZSBEMy5qcyBpbXBsZW1lbnRhdGlvbi5cbnN0YXRzLnF1YW50aWxlID0gZnVuY3Rpb24odmFsdWVzLCBmLCBwKSB7XG4gIGlmIChwID09PSB1bmRlZmluZWQpIHsgcCA9IGY7IGYgPSB1dGlsLmlkZW50aXR5OyB9XG4gIHZhciBIID0gKHZhbHVlcy5sZW5ndGggLSAxKSAqIHAgKyAxLFxuICAgICAgaCA9IE1hdGguZmxvb3IoSCksXG4gICAgICB2ID0gK2YodmFsdWVzW2ggLSAxXSksXG4gICAgICBlID0gSCAtIGg7XG4gIHJldHVybiBlID8gdiArIGUgKiAoZih2YWx1ZXNbaF0pIC0gdikgOiB2O1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgbWVhbiAoYXZlcmFnZSkgb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLm1lYW4gPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgaWYgKCF1dGlsLmlzQXJyYXkodmFsdWVzKSB8fCB2YWx1ZXMubGVuZ3RoPT09MCkgcmV0dXJuIDA7XG4gIHZhciBtZWFuID0gMCwgZGVsdGEsIGksIGMsIHY7XG4gIGZvciAoaT0wLCBjPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG4gICAgaWYgKHYgIT0gbnVsbCAmJiAhaXNOYU4odikpIHtcbiAgICAgIGRlbHRhID0gdiAtIG1lYW47XG4gICAgICBtZWFuID0gbWVhbiArIGRlbHRhIC8gKCsrYyk7XG4gICAgfVxuICB9XG4gIHJldHVybiBtZWFuO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIHZhcmlhbmNlIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy52YXJpYW5jZSA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICBpZiAoIXV0aWwuaXNBcnJheSh2YWx1ZXMpIHx8IHZhbHVlcy5sZW5ndGg9PT0wKSByZXR1cm4gMDtcbiAgdmFyIG1lYW4gPSAwLCBNMiA9IDAsIGRlbHRhLCBpLCBjLCB2O1xuICBmb3IgKGk9MCwgYz0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIGlmICh2ICE9IG51bGwgJiYgIWlzTmFOKHYpKSB7XG4gICAgICBkZWx0YSA9IHYgLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2MpO1xuICAgICAgTTIgPSBNMiArIGRlbHRhICogKHYgLSBtZWFuKTtcbiAgICB9XG4gIH1cbiAgTTIgPSBNMiAvIChjIC0gMSk7XG4gIHJldHVybiBNMjtcbn07XG5cbi8vIENvbXB1dGUgdGhlIHNhbXBsZSBzdGFuZGFyZCBkZXZpYXRpb24gb2YgYW4gYXJyYXkgb2YgbnVtYmVycy5cbnN0YXRzLnN0ZGV2ID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoc3RhdHMudmFyaWFuY2UodmFsdWVzLCBmKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBQZWFyc29uIG1vZGUgc2tld25lc3MgKChtZWRpYW4tbWVhbikvc3RkZXYpIG9mIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5tb2Rlc2tldyA9IGZ1bmN0aW9uKHZhbHVlcywgZikge1xuICB2YXIgYXZnID0gc3RhdHMubWVhbih2YWx1ZXMsIGYpLFxuICAgICAgbWVkID0gc3RhdHMubWVkaWFuKHZhbHVlcywgZiksXG4gICAgICBzdGQgPSBzdGF0cy5zdGRldih2YWx1ZXMsIGYpO1xuICByZXR1cm4gc3RkID09PSAwID8gMCA6IChhdmcgLSBtZWQpIC8gc3RkO1xufTtcblxuLy8gRmluZCB0aGUgbWluaW11bSBhbmQgbWF4aW11bSBvZiBhbiBhcnJheSBvZiB2YWx1ZXMuXG5zdGF0cy5leHRlbnQgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIGEsIGIsIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICB2ID0gKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgPyB2Lmxlbmd0aCA6IHY7XG4gICAgaWYgKHV0aWwuaXNOb3ROdWxsKHYpKSB7IGEgPSBiID0gdjsgYnJlYWs7IH1cbiAgfVxuICBmb3IgKDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICB2ID0gKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgPyB2Lmxlbmd0aCA6IHY7XG4gICAgaWYgKHV0aWwuaXNOb3ROdWxsKHYpKSB7XG4gICAgICBpZiAodiA8IGEpIGEgPSB2O1xuICAgICAgaWYgKHYgPiBiKSBiID0gdjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIFthLCBiXTtcbn07XG5cbi8vIEZpbmQgdGhlIGludGVnZXIgaW5kaWNlcyBvZiB0aGUgbWluaW11bSBhbmQgbWF4aW11bSB2YWx1ZXMuXG5zdGF0cy5leHRlbnQuaW5kZXggPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIGEsIGIsIHgsIHksIHYsIGksIG4gPSB2YWx1ZXMubGVuZ3RoO1xuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICB2ID0gZiA/IGYodmFsdWVzW2ldKSA6IHZhbHVlc1tpXTtcbiAgICB2ID0gKHR5cGVvZiB2ID09PSAnc3RyaW5nJykgPyB2Lmxlbmd0aCA6IHY7XG4gICAgaWYgKHV0aWwuaXNOb3ROdWxsKHYpKSB7IGEgPSBiID0gdjsgeCA9IHkgPSBpOyBicmVhazsgfVxuICB9XG4gIGZvciAoOyBpPG47ICsraSkge1xuICAgIHYgPSBmID8gZih2YWx1ZXNbaV0pIDogdmFsdWVzW2ldO1xuICAgIHYgPSAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSA/IHYubGVuZ3RoIDogdjtcbiAgICBpZiAodXRpbC5pc05vdE51bGwodikpIHtcbiAgICAgIGlmICh2IDwgYSkgeyBhID0gdjsgeCA9IGk7IH1cbiAgICAgIGlmICh2ID4gYikgeyBiID0gdjsgeSA9IGk7IH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIFt4LCB5XTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIGRvdCBwcm9kdWN0IG9mIHR3byBhcnJheXMgb2YgbnVtYmVycy5cbnN0YXRzLmRvdCA9IGZ1bmN0aW9uKHZhbHVlcywgYSwgYikge1xuICB2YXIgc3VtID0gMCwgaSwgdjtcbiAgaWYgKCFiKSB7XG4gICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IGEubGVuZ3RoKSB7XG4gICAgICB0aHJvdyBFcnJvcihcIkFycmF5IGxlbmd0aHMgbXVzdCBtYXRjaC5cIik7XG4gICAgfVxuICAgIGZvciAoaT0wOyBpPHZhbHVlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdiA9IHZhbHVlc1tpXSAqIGFbaV07XG4gICAgICBpZiAoIWlzTmFOKHYpKSBzdW0gKz0gdjtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gYSh2YWx1ZXNbaV0pICogYih2YWx1ZXNbaV0pO1xuICAgICAgaWYgKCFpc05hTih2KSkgc3VtICs9IHY7XG4gICAgfVxuICB9XG4gIHJldHVybiBzdW07XG59O1xuXG4vLyBDb21wdXRlIGFzY2VuZGluZyByYW5rIHNjb3JlcyBmb3IgYW4gYXJyYXkgb2YgdmFsdWVzLlxuLy8gVGllcyBhcmUgYXNzaWduZWQgdGhlaXIgY29sbGVjdGl2ZSBtZWFuIHJhbmsuXG5zdGF0cy5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBmKSB7XG4gIHZhciBhID0gdmFsdWVzLm1hcChmdW5jdGlvbih2LCBpKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpZHg6IGksXG4gICAgICAgIHZhbDogKGYgPyBmKHYpIDogdilcbiAgICAgIH07XG4gICAgfSlcbiAgICAuc29ydCh1dGlsLmNvbXBhcmF0b3IoXCJ2YWxcIikpO1xuXG4gIHZhciBuID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgIHIgPSBBcnJheShuKSxcbiAgICAgIHRpZSA9IC0xLCBwID0ge30sIGksIHYsIG11O1xuXG4gIGZvciAoaT0wOyBpPG47ICsraSkge1xuICAgIHYgPSBhW2ldLnZhbDtcbiAgICBpZiAodGllIDwgMCAmJiBwID09PSB2KSB7XG4gICAgICB0aWUgPSBpIC0gMTtcbiAgICB9IGVsc2UgaWYgKHRpZSA+IC0xICYmIHAgIT09IHYpIHtcbiAgICAgIG11ID0gMSArIChpLTEgKyB0aWUpIC8gMjtcbiAgICAgIGZvciAoOyB0aWU8aTsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgICAgIHRpZSA9IC0xO1xuICAgIH1cbiAgICByW2FbaV0uaWR4XSA9IGkgKyAxO1xuICAgIHAgPSB2O1xuICB9XG5cbiAgaWYgKHRpZSA+IC0xKSB7XG4gICAgbXUgPSAxICsgKG4tMSArIHRpZSkgLyAyO1xuICAgIGZvciAoOyB0aWU8bjsgKyt0aWUpIHJbYVt0aWVdLmlkeF0gPSBtdTtcbiAgfVxuXG4gIHJldHVybiByO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgc2FtcGxlIFBlYXJzb24gcHJvZHVjdC1tb21lbnQgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuc3RhdHMuY29yID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciBmbiA9IGI7XG4gIGIgPSBmbiA/IHZhbHVlcy5tYXAoYikgOiBhLFxuICBhID0gZm4gPyB2YWx1ZXMubWFwKGEpIDogdmFsdWVzO1xuXG4gIHZhciBkb3QgPSBzdGF0cy5kb3QoYSwgYiksXG4gICAgICBtdWEgPSBzdGF0cy5tZWFuKGEpLFxuICAgICAgbXViID0gc3RhdHMubWVhbihiKSxcbiAgICAgIHNkYSA9IHN0YXRzLnN0ZGV2KGEpLFxuICAgICAgc2RiID0gc3RhdHMuc3RkZXYoYiksXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aDtcblxuICByZXR1cm4gKGRvdCAtIG4qbXVhKm11YikgLyAoKG4tMSkgKiBzZGEgKiBzZGIpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgU3BlYXJtYW4gcmFuayBjb3JyZWxhdGlvbiBvZiB0d28gYXJyYXlzIG9mIHZhbHVlcy5cbnN0YXRzLmNvci5yYW5rID0gZnVuY3Rpb24odmFsdWVzLCBhLCBiKSB7XG4gIHZhciByYSA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgYSkgOiBzdGF0cy5yYW5rKHZhbHVlcyksXG4gICAgICByYiA9IGIgPyBzdGF0cy5yYW5rKHZhbHVlcywgYikgOiBzdGF0cy5yYW5rKGEpLFxuICAgICAgbiA9IHZhbHVlcy5sZW5ndGgsIGksIHMsIGQ7XG5cbiAgZm9yIChpPTAsIHM9MDsgaTxuOyArK2kpIHtcbiAgICBkID0gcmFbaV0gLSByYltpXTtcbiAgICBzICs9IGQgKiBkO1xuICB9XG5cbiAgcmV0dXJuIDEgLSA2KnMgLyAobiAqIChuKm4tMSkpO1xufTtcblxuLy8gQ29tcHV0ZSB0aGUgZGlzdGFuY2UgY29ycmVsYXRpb24gb2YgdHdvIGFycmF5cyBvZiBudW1iZXJzLlxuLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9EaXN0YW5jZV9jb3JyZWxhdGlvblxuc3RhdHMuY29yLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIpIHtcbiAgdmFyIFggPSBiID8gdmFsdWVzLm1hcChhKSA6IHZhbHVlcyxcbiAgICAgIFkgPSBiID8gdmFsdWVzLm1hcChiKSA6IGE7XG5cbiAgdmFyIEEgPSBzdGF0cy5kaXN0Lm1hdChYKSxcbiAgICAgIEIgPSBzdGF0cy5kaXN0Lm1hdChZKSxcbiAgICAgIG4gPSBBLmxlbmd0aCxcbiAgICAgIGksIGFhLCBiYiwgYWI7XG5cbiAgZm9yIChpPTAsIGFhPTAsIGJiPTAsIGFiPTA7IGk8bjsgKytpKSB7XG4gICAgYWEgKz0gQVtpXSpBW2ldO1xuICAgIGJiICs9IEJbaV0qQltpXTtcbiAgICBhYiArPSBBW2ldKkJbaV07XG4gIH1cblxuICByZXR1cm4gTWF0aC5zcXJ0KGFiIC8gTWF0aC5zcXJ0KGFhKmJiKSk7XG59O1xuXG4vLyBDb21wdXRlIHRoZSB2ZWN0b3IgZGlzdGFuY2UgYmV0d2VlbiB0d28gYXJyYXlzIG9mIG51bWJlcnMuXG4vLyBEZWZhdWx0IGlzIEV1Y2xpZGVhbiAoZXhwPTIpIGRpc3RhbmNlLCBjb25maWd1cmFibGUgdmlhIGV4cCBhcmd1bWVudC5cbnN0YXRzLmRpc3QgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGV4cCkge1xuICB2YXIgZiA9IHV0aWwuaXNGdW5jdGlvbihiKSxcbiAgICAgIFggPSB2YWx1ZXMsXG4gICAgICBZID0gZiA/IHZhbHVlcyA6IGEsXG4gICAgICBlID0gZiA/IGV4cCA6IGIsXG4gICAgICBuID0gdmFsdWVzLmxlbmd0aCwgcyA9IDAsIGQsIGk7XG5cbiAgaWYgKGUgPT09IDIgfHwgZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgICBkID0gZiA/IChhKFhbaV0pLWIoWVtpXSkpIDogKFhbaV0tWVtpXSk7XG4gICAgICBzICs9IGQqZDtcbiAgICB9XG4gICAgcmV0dXJuIE1hdGguc3FydChzKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICAgIGQgPSBNYXRoLmFicyhmID8gKGEoWFtpXSktYihZW2ldKSkgOiAoWFtpXS1ZW2ldKSk7XG4gICAgICBzICs9IE1hdGgucG93KGQsIGUpO1xuICAgIH1cbiAgICByZXR1cm4gTWF0aC5wb3cocywgMS9lKTtcbiAgfVxufTtcblxuLy8gQ29uc3RydWN0IGEgbWVhbi1jZW50ZXJlZCBkaXN0YW5jZSBtYXRyaXggZm9yIGFuIGFycmF5IG9mIG51bWJlcnMuXG5zdGF0cy5kaXN0Lm1hdCA9IGZ1bmN0aW9uKFgpIHtcbiAgdmFyIG4gPSBYLmxlbmd0aCxcbiAgICAgIG0gPSBuKm4sXG4gICAgICBBID0gQXJyYXkobSksXG4gICAgICBSID0gZ2VuLnplcm9zKG4pLFxuICAgICAgTSA9IDAsIHYsIGksIGo7XG5cbiAgZm9yIChpPTA7IGk8bjsgKytpKSB7XG4gICAgQVtpKm4raV0gPSAwO1xuICAgIGZvciAoaj1pKzE7IGo8bjsgKytqKSB7XG4gICAgICBBW2kqbitqXSA9ICh2ID0gTWF0aC5hYnMoWFtpXSAtIFhbal0pKTtcbiAgICAgIEFbaipuK2ldID0gdjtcbiAgICAgIFJbaV0gKz0gdjtcbiAgICAgIFJbal0gKz0gdjtcbiAgICB9XG4gIH1cblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBNICs9IFJbaV07XG4gICAgUltpXSAvPSBuO1xuICB9XG4gIE0gLz0gbTtcblxuICBmb3IgKGk9MDsgaTxuOyArK2kpIHtcbiAgICBmb3IgKGo9aTsgajxuOyArK2opIHtcbiAgICAgIEFbaSpuK2pdICs9IE0gLSBSW2ldIC0gUltqXTtcbiAgICAgIEFbaipuK2ldID0gQVtpKm4ral07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIEE7XG59O1xuXG4vLyBDb21wdXRlIHRoZSBTaGFubm9uIGVudHJvcHkgKGxvZyBiYXNlIDIpIG9mIGFuIGFycmF5IG9mIGNvdW50cy5cbnN0YXRzLmVudHJvcHkgPSBmdW5jdGlvbihjb3VudHMsIGYpIHtcbiAgdmFyIGksIHAsIHMgPSAwLCBIID0gMCwgTiA9IGNvdW50cy5sZW5ndGg7XG4gIGZvciAoaT0wOyBpPE47ICsraSkge1xuICAgIHMgKz0gKGYgPyBmKGNvdW50c1tpXSkgOiBjb3VudHNbaV0pO1xuICB9XG4gIGlmIChzID09PSAwKSByZXR1cm4gMDtcbiAgZm9yIChpPTA7IGk8TjsgKytpKSB7XG4gICAgcCA9IChmID8gZihjb3VudHNbaV0pIDogY291bnRzW2ldKSAvIHM7XG4gICAgaWYgKHAgPiAwKSBIICs9IHAgKiBNYXRoLmxvZyhwKSAvIE1hdGguTE4yO1xuICB9XG4gIHJldHVybiAtSDtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG5vcm1hbGl6ZWQgU2hhbm5vbiBlbnRyb3B5IChsb2cgYmFzZSAyKSBvZiBhbiBhcnJheSBvZiBjb3VudHMuXG5zdGF0cy5lbnRyb3B5Lm5vcm1hbGl6ZWQgPSBmdW5jdGlvbihjb3VudHMsIGYpIHtcbiAgdmFyIEggPSBzdGF0cy5lbnRyb3B5KGNvdW50cywgZik7XG4gIHJldHVybiBIPT09MCA/IDAgOiBIICogTWF0aC5MTjIgLyBNYXRoLmxvZyhjb3VudHMubGVuZ3RoKTtcbn07XG5cbi8vIENvbXB1dGUgdGhlIG11dHVhbCBpbmZvcm1hdGlvbiBiZXR3ZWVuIHR3byBkaXNjcmV0ZSB2YXJpYWJsZXMuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL011dHVhbF9pbmZvcm1hdGlvblxuc3RhdHMuZW50cm9weS5tdXR1YWwgPSBmdW5jdGlvbih2YWx1ZXMsIGEsIGIsIGNvdW50cykge1xuICB2YXIgeCA9IGNvdW50cyA/IHZhbHVlcy5tYXAoYSkgOiB2YWx1ZXMsXG4gICAgICB5ID0gY291bnRzID8gdmFsdWVzLm1hcChiKSA6IGEsXG4gICAgICB6ID0gY291bnRzID8gdmFsdWVzLm1hcChjb3VudHMpIDogYjtcblxuICB2YXIgcHggPSB7fSxcblx0ICAgIHB5ID0ge30sXG5cdCAgICBpLCB4eCwgeXksIHp6LCBzID0gMCwgdCwgTiA9IHoubGVuZ3RoLCBwLCBJID0gMDtcblxuXHRmb3IgKGk9MDsgaTxOOyArK2kpIHtcblx0ICBweFt4W2ldXSA9IDA7XG5cdCAgcHlbeVtpXV0gPSAwO1xuICB9XG5cblx0Zm9yIChpPTA7IGk8TjsgKytpKSB7XG5cdFx0cHhbeFtpXV0gKz0geltpXTtcblx0XHRweVt5W2ldXSArPSB6W2ldO1xuXHRcdHMgKz0geltpXTtcblx0fVxuXG5cdHQgPSAxIC8gKHMgKiBNYXRoLkxOMik7XG5cdGZvciAoaT0wOyBpPE47ICsraSkge1xuXHRcdGlmICh6W2ldID09PSAwKSBjb250aW51ZTtcblx0XHRwID0gKHMgKiB6W2ldKSAvIChweFt4W2ldXSAqIHB5W3lbaV1dKTtcblx0XHRJICs9IHpbaV0gKiB0ICogTWF0aC5sb2cocCk7XG5cdH1cblxuXHRyZXR1cm4gSTtcbn07XG5cbi8vIENvbXB1dGUgYSBwcm9maWxlIG9mIHN1bW1hcnkgc3RhdGlzdGljcyBmb3IgYSB2YXJpYWJsZS5cbnN0YXRzLnByb2ZpbGUgPSBmdW5jdGlvbih2YWx1ZXMsIGYpIHtcbiAgdmFyIHAgPSB7fSxcbiAgICAgIG1lYW4gPSAwLFxuICAgICAgY291bnQgPSAwLFxuICAgICAgZGlzdGluY3QgPSAwLFxuICAgICAgbWluID0gbnVsbCxcbiAgICAgIG1heCA9IG51bGwsXG4gICAgICBNMiA9IDAsXG4gICAgICB2YWxzID0gW10sXG4gICAgICB1ID0ge30sIGRlbHRhLCBzZCwgaSwgdiwgeCwgaGFsZiwgaCwgaDI7XG5cbiAgLy8gY29tcHV0ZSBzdW1tYXJ5IHN0YXRzXG4gIGZvciAoaT0wLCBjPTA7IGk8dmFsdWVzLmxlbmd0aDsgKytpKSB7XG4gICAgdiA9IGYgPyBmKHZhbHVlc1tpXSkgOiB2YWx1ZXNbaV07XG5cbiAgICAvLyB1cGRhdGUgdW5pcXVlIHZhbHVlc1xuICAgIHVbdl0gPSAodiBpbiB1KSA/IHVbdl0gKyAxIDogKGRpc3RpbmN0ICs9IDEsIDEpO1xuXG4gICAgaWYgKHV0aWwuaXNOb3ROdWxsKHYpKSB7XG4gICAgICAvLyB1cGRhdGUgc3RhdHNcbiAgICAgIHggPSAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSA/IHYubGVuZ3RoIDogdjtcbiAgICAgIGlmIChtaW49PT1udWxsIHx8IHggPCBtaW4pIG1pbiA9IHg7XG4gICAgICBpZiAobWF4PT09bnVsbCB8fCB4ID4gbWF4KSBtYXggPSB4O1xuXG4gICAgICBkZWx0YSA9IHggLSBtZWFuO1xuICAgICAgbWVhbiA9IG1lYW4gKyBkZWx0YSAvICgrK2NvdW50KTtcbiAgICAgIE0yID0gTTIgKyBkZWx0YSAqICh4IC0gbWVhbik7XG4gICAgICB2YWxzLnB1c2goeCk7XG4gICAgfVxuICB9XG4gIE0yID0gTTIgLyAoY291bnQgLSAxKTtcbiAgc2QgPSBNYXRoLnNxcnQoTTIpO1xuXG4gIC8vIHNvcnQgdmFsdWVzIGZvciBtZWRpYW4gYW5kIGlxclxuICB2YWxzLnNvcnQodXRpbC5jbXApO1xuXG4gIHJldHVybiB7XG4gICAgdW5pcXVlOiAgIHUsXG4gICAgY291bnQ6ICAgIGNvdW50LFxuICAgIG51bGxzOiAgICB2YWx1ZXMubGVuZ3RoIC0gY291bnQsXG4gICAgZGlzdGluY3Q6IGRpc3RpbmN0LFxuICAgIG1pbjogICAgICBtaW4sXG4gICAgbWF4OiAgICAgIG1heCxcbiAgICBtZWFuOiAgICAgbWVhbixcbiAgICBzdGRldjogICAgc2QsXG4gICAgbWVkaWFuOiAgICh2ID0gc3RhdHMucXVhbnRpbGUodmFscywgMC41KSksXG4gICAgbW9kZXNrZXc6IHNkID09PSAwID8gMCA6IChtZWFuIC0gdikgLyBzZCxcbiAgICBpcXI6ICAgICAgW3N0YXRzLnF1YW50aWxlKHZhbHMsIDAuMjUpLCBzdGF0cy5xdWFudGlsZSh2YWxzLCAwLjc1KV1cbiAgfTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhdHM7IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBzdGF0cyA9IHJlcXVpcmUoJy4vc3RhdHMnKTtcblxuLy8gQ29tcHV0ZSBwcm9maWxlcyBmb3IgYWxsIHZhcmlhYmxlcyBpbiBhIGRhdGEgc2V0LlxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihkYXRhLCBmaWVsZHMpIHtcbiAgaWYgKGRhdGEgPT0gbnVsbCB8fCBkYXRhLmxlbmd0aCA9PT0gMCkgcmV0dXJuIG51bGw7XG4gIGZpZWxkcyA9IGZpZWxkcyB8fCB1dGlsLmtleXMoZGF0YVswXSk7XG5cbiAgdmFyIHByb2ZpbGVzID0gZmllbGRzLm1hcChmdW5jdGlvbihmKSB7XG4gICAgdmFyIHAgPSBzdGF0cy5wcm9maWxlKGRhdGEsIHV0aWwuYWNjZXNzb3IoZikpO1xuICAgIHJldHVybiAocC5maWVsZCA9IGYsIHApO1xuICB9KTtcbiAgXG4gIHByb2ZpbGVzLnRvU3RyaW5nID0gcHJpbnRTdW1tYXJ5O1xuICByZXR1cm4gcHJvZmlsZXM7XG59O1xuXG5mdW5jdGlvbiBwcmludFN1bW1hcnkoKSB7XG4gIHZhciBwcm9maWxlcyA9IHRoaXM7XG4gIHZhciBzdHIgPSBbXTtcbiAgcHJvZmlsZXMuZm9yRWFjaChmdW5jdGlvbihwKSB7XG4gICAgc3RyLnB1c2goXCItLS0tLSBGaWVsZDogJ1wiICsgcC5maWVsZCArIFwiJyAtLS0tLVwiKTtcbiAgICBpZiAodHlwZW9mIHAubWluID09PSAnc3RyaW5nJyB8fCBwLmRpc3RpbmN0IDwgMTApIHtcbiAgICAgIHN0ci5wdXNoKHByaW50Q2F0ZWdvcmljYWxQcm9maWxlKHApKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RyLnB1c2gocHJpbnRRdWFudGl0YXRpdmVQcm9maWxlKHApKTtcbiAgICB9XG4gICAgc3RyLnB1c2goXCJcIik7XG4gIH0pO1xuICByZXR1cm4gc3RyLmpvaW4oXCJcXG5cIik7XG59XG5cbmZ1bmN0aW9uIHByaW50UXVhbnRpdGF0aXZlUHJvZmlsZShwKSB7XG4gIHJldHVybiBbXG4gICAgXCJkaXN0aW5jdDogXCIgKyBwLmRpc3RpbmN0LFxuICAgIFwibnVsbHM6ICAgIFwiICsgcC5udWxscyxcbiAgICBcIm1pbjogICAgICBcIiArIHAubWluLFxuICAgIFwibWF4OiAgICAgIFwiICsgcC5tYXgsXG4gICAgXCJtZWRpYW46ICAgXCIgKyBwLm1lZGlhbixcbiAgICBcIm1lYW46ICAgICBcIiArIHAubWVhbixcbiAgICBcInN0ZGV2OiAgICBcIiArIHAuc3RkZXYsXG4gICAgXCJtb2Rlc2tldzogXCIgKyBwLm1vZGVza2V3XG4gIF0uam9pbihcIlxcblwiKTtcbn1cblxuZnVuY3Rpb24gcHJpbnRDYXRlZ29yaWNhbFByb2ZpbGUocCkge1xuICB2YXIgbGlzdCA9IFtcbiAgICBcImRpc3RpbmN0OiBcIiArIHAuZGlzdGluY3QsXG4gICAgXCJudWxsczogICAgXCIgKyBwLm51bGxzLFxuICAgIFwidG9wIHZhbHVlczogXCJcbiAgXTtcbiAgdmFyIHUgPSBwLnVuaXF1ZTtcbiAgdmFyIHRvcCA9IHV0aWwua2V5cyh1KVxuICAgIC5zb3J0KGZ1bmN0aW9uKGEsYikgeyByZXR1cm4gdVtiXSAtIHVbYV07IH0pXG4gICAgLnNsaWNlKDAsIDYpXG4gICAgLm1hcChmdW5jdGlvbih2KSB7IHJldHVybiBcIiAnXCIgKyB2ICsgXCInIChcIiArIHVbdl0gKyBcIilcIjsgfSk7XG4gIHJldHVybiBsaXN0LmNvbmNhdCh0b3ApLmpvaW4oXCJcXG5cIik7XG59IiwidmFyIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcbnZhciBkMyA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93LmQzIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbC5kMyA6IG51bGwpO1xuXG52YXIgY29udGV4dCA9IHtcbiAgZm9ybWF0czogICAgW10sXG4gIGZvcm1hdF9tYXA6IHt9LFxuICB0cnVuY2F0ZTogICB1dGlsLnRydW5jYXRlXG59O1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZSh0ZXh0KSB7XG4gIHZhciBzcmMgPSBzb3VyY2UodGV4dCwgXCJkXCIpO1xuICBzcmMgPSBcInZhciBfX3Q7IHJldHVybiBcIiArIHNyYyArIFwiO1wiO1xuXG4gIHRyeSB7XG4gICAgcmV0dXJuIChuZXcgRnVuY3Rpb24oXCJkXCIsIHNyYykpLmJpbmQoY29udGV4dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBlLnNvdXJjZSA9IHNyYztcbiAgICB0aHJvdyBlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gdGVtcGxhdGU7XG5cbi8vIGNsZWFyIGNhY2hlIG9mIGZvcm1hdCBvYmplY3RzXG4vLyBjYW4gKmJyZWFrKiBwcmlvciB0ZW1wbGF0ZSBmdW5jdGlvbnMsIHNvIGludm9rZSB3aXRoIGNhcmVcbnRlbXBsYXRlLmNsZWFyRm9ybWF0Q2FjaGUgPSBmdW5jdGlvbigpIHtcbiAgY29udGV4dC5mb3JtYXRzID0gW107XG4gIGNvbnRleHQuZm9ybWF0X21hcCA9IHt9O1xufTtcblxuZnVuY3Rpb24gc291cmNlKHRleHQsIHZhcmlhYmxlKSB7XG4gIHZhcmlhYmxlID0gdmFyaWFibGUgfHwgXCJvYmpcIjtcbiAgdmFyIGluZGV4ID0gMDtcbiAgdmFyIHNyYyA9IFwiJ1wiO1xuICB2YXIgcmVnZXggPSB0ZW1wbGF0ZV9yZTtcblxuICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICB0ZXh0LnJlcGxhY2UocmVnZXgsIGZ1bmN0aW9uKG1hdGNoLCBpbnRlcnBvbGF0ZSwgb2Zmc2V0KSB7XG4gICAgc3JjICs9IHRleHRcbiAgICAgIC5zbGljZShpbmRleCwgb2Zmc2V0KVxuICAgICAgLnJlcGxhY2UodGVtcGxhdGVfZXNjYXBlciwgdGVtcGxhdGVfZXNjYXBlQ2hhcik7XG4gICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgIHNyYyArPSBcIidcXG4rKChfX3Q9KFwiXG4gICAgICAgICsgdGVtcGxhdGVfdmFyKGludGVycG9sYXRlLCB2YXJpYWJsZSlcbiAgICAgICAgKyBcIikpPT1udWxsPycnOl9fdCkrXFxuJ1wiO1xuICAgIH1cblxuICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICByZXR1cm4gbWF0Y2g7XG4gIH0pO1xuICByZXR1cm4gc3JjICsgXCInXCI7XG59XG5cbmZ1bmN0aW9uIHRlbXBsYXRlX3Zhcih0ZXh0LCB2YXJpYWJsZSkge1xuICB2YXIgZmlsdGVycyA9IHRleHQuc3BsaXQoJ3wnKTtcbiAgdmFyIHByb3AgPSBmaWx0ZXJzLnNoaWZ0KCkudHJpbSgpO1xuICB2YXIgZm9ybWF0ID0gW107XG4gIHZhciBzdHJpbmdDYXN0ID0gdHJ1ZTtcbiAgXG4gIGZ1bmN0aW9uIHN0cmNhbGwoZm4pIHtcbiAgICBmbiA9IGZuIHx8IFwiXCI7XG4gICAgaWYgKHN0cmluZ0Nhc3QpIHtcbiAgICAgIHN0cmluZ0Nhc3QgPSBmYWxzZTtcbiAgICAgIHNyYyA9IFwiU3RyaW5nKFwiICsgc3JjICsgXCIpXCIgKyBmbjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3JjICs9IGZuO1xuICAgIH1cbiAgICByZXR1cm4gc3JjO1xuICB9XG4gIFxuICB2YXIgc3JjID0gdXRpbC5maWVsZChwcm9wKS5tYXAodXRpbC5zdHIpLmpvaW4oXCJdW1wiKTtcbiAgc3JjID0gdmFyaWFibGUgKyBcIltcIiArIHNyYyArIFwiXVwiO1xuICBcbiAgZm9yICh2YXIgaT0wOyBpPGZpbHRlcnMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgZiA9IGZpbHRlcnNbaV0sIGFyZ3MgPSBudWxsLCBwaWR4LCBhLCBiO1xuXG4gICAgaWYgKChwaWR4PWYuaW5kZXhPZignOicpKSA+IDApIHtcbiAgICAgIGYgPSBmLnNsaWNlKDAsIHBpZHgpO1xuICAgICAgYXJncyA9IGZpbHRlcnNbaV0uc2xpY2UocGlkeCsxKS5zcGxpdCgnLCcpXG4gICAgICAgIC5tYXAoZnVuY3Rpb24ocykgeyByZXR1cm4gcy50cmltKCk7IH0pO1xuICAgIH1cbiAgICBmID0gZi50cmltKCk7XG5cbiAgICBzd2l0Y2ggKGYpIHtcbiAgICAgIGNhc2UgJ2xlbmd0aCc6XG4gICAgICAgIHN0cmNhbGwoJy5sZW5ndGgnKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdsb3dlcic6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvd2VyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndXBwZXInOlxuICAgICAgICBzdHJjYWxsKCcudG9VcHBlckNhc2UoKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xvd2VyLWxvY2FsZSc6XG4gICAgICAgIHN0cmNhbGwoJy50b0xvY2FsZUxvd2VyQ2FzZSgpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndXBwZXItbG9jYWxlJzpcbiAgICAgICAgc3RyY2FsbCgnLnRvTG9jYWxlVXBwZXJDYXNlKCknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICd0cmltJzpcbiAgICAgICAgc3RyY2FsbCgnLnRyaW0oKScpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2xlZnQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgwLCcgKyBhICsgJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdyaWdodCc6XG4gICAgICAgIGEgPSB1dGlsLm51bWJlcihhcmdzWzBdKTtcbiAgICAgICAgc3RyY2FsbCgnLnNsaWNlKC0nICsgYSArJyknKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdtaWQnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhICsgdXRpbC5udW1iZXIoYXJnc1sxXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgrJythKycsJytiKycpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAnc2xpY2UnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIHN0cmNhbGwoJy5zbGljZSgnKyBhXG4gICAgICAgICAgKyAoYXJncy5sZW5ndGggPiAxID8gJywnICsgdXRpbC5udW1iZXIoYXJnc1sxXSkgOiAnJylcbiAgICAgICAgICArICcpJyk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndHJ1bmNhdGUnOlxuICAgICAgICBhID0gdXRpbC5udW1iZXIoYXJnc1swXSk7XG4gICAgICAgIGIgPSBhcmdzWzFdO1xuICAgICAgICBiID0gKGIhPT1cImxlZnRcIiAmJiBiIT09XCJtaWRkbGVcIiAmJiBiIT09XCJjZW50ZXJcIikgPyBcInJpZ2h0XCIgOiBiO1xuICAgICAgICBzcmMgPSAndGhpcy50cnVuY2F0ZSgnICsgc3RyY2FsbCgpICsgJywnICsgYSArICcsXCInICsgYiArICdcIiknO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ251bWJlcic6XG4gICAgICAgIGEgPSB0ZW1wbGF0ZV9mb3JtYXQoYXJnc1swXSwgZDMuZm9ybWF0KTtcbiAgICAgICAgc3RyaW5nQ2FzdCA9IGZhbHNlO1xuICAgICAgICBzcmMgPSAndGhpcy5mb3JtYXRzWycrYSsnXSgnK3NyYysnKSc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAndGltZSc6XG4gICAgICAgIGEgPSB0ZW1wbGF0ZV9mb3JtYXQoYXJnc1swXSwgZDMudGltZS5mb3JtYXQpO1xuICAgICAgICBzdHJpbmdDYXN0ID0gZmFsc2U7XG4gICAgICAgIHNyYyA9ICd0aGlzLmZvcm1hdHNbJythKyddKCcrc3JjKycpJztcbiAgICAgICAgYnJlYWs7XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBFcnJvcihcIlVucmVjb2duaXplZCB0ZW1wbGF0ZSBmaWx0ZXI6IFwiICsgZik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHNyYztcbn1cblxudmFyIHRlbXBsYXRlX3JlID0gL1xce1xceyguKz8pXFx9XFx9fCQvZztcblxuLy8gQ2VydGFpbiBjaGFyYWN0ZXJzIG5lZWQgdG8gYmUgZXNjYXBlZCBzbyB0aGF0IHRoZXkgY2FuIGJlIHB1dCBpbnRvIGFcbi8vIHN0cmluZyBsaXRlcmFsLlxudmFyIHRlbXBsYXRlX2VzY2FwZXMgPSB7XG4gIFwiJ1wiOiAgICAgIFwiJ1wiLFxuICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICdcXHInOiAgICAgJ3InLFxuICAnXFxuJzogICAgICduJyxcbiAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAnXFx1MjAyOSc6ICd1MjAyOSdcbn07XG5cbnZhciB0ZW1wbGF0ZV9lc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZV9lc2NhcGVDaGFyKG1hdGNoKSB7XG4gIHJldHVybiAnXFxcXCcgKyB0ZW1wbGF0ZV9lc2NhcGVzW21hdGNoXTtcbn1cblxuZnVuY3Rpb24gdGVtcGxhdGVfZm9ybWF0KHBhdHRlcm4sIGZtdCkge1xuICBpZiAoKHBhdHRlcm5bMF0gPT09IFwiJ1wiICYmIHBhdHRlcm5bcGF0dGVybi5sZW5ndGgtMV0gPT09IFwiJ1wiKSB8fFxuICAgICAgKHBhdHRlcm5bMF0gIT09ICdcIicgJiYgcGF0dGVybltwYXR0ZXJuLmxlbmd0aC0xXSA9PT0gJ1wiJykpIHtcbiAgICBwYXR0ZXJuID0gcGF0dGVybi5zbGljZSgxLCAtMSk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgRXJyb3IoXCJGb3JtYXQgcGF0dGVybiBtdXN0IGJlIHF1b3RlZDogXCIgKyBwYXR0ZXJuKTtcbiAgfVxuICBpZiAoIWNvbnRleHQuZm9ybWF0X21hcFtwYXR0ZXJuXSkge1xuICAgIHZhciBmID0gZm10KHBhdHRlcm4pO1xuICAgIHZhciBpID0gY29udGV4dC5mb3JtYXRzLmxlbmd0aDtcbiAgICBjb250ZXh0LmZvcm1hdHMucHVzaChmKTtcbiAgICBjb250ZXh0LmZvcm1hdF9tYXBbcGF0dGVybl0gPSBpO1xuICB9XG4gIHJldHVybiBjb250ZXh0LmZvcm1hdF9tYXBbcGF0dGVybl07XG59XG4iLCJ2YXIgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xudmFyIHUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyB3aGVyZSBhcmUgd2U/XG5cbnUuaXNOb2RlID0gdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnXG4gICAgICAgICYmIHR5cGVvZiBwcm9jZXNzLnN0ZGVyciAhPT0gJ3VuZGVmaW5lZCc7XG5cbi8vIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zXG5cbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5cbnUuaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG59O1xuXG51LmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufTtcblxudS5pc1N0cmluZyA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IFN0cmluZ10nO1xufTtcblxudS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudS5pc051bWJlciA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gIWlzTmFOKHBhcnNlRmxvYXQob2JqKSkgJiYgaXNGaW5pdGUob2JqKTtcbn07XG5cbnUuaXNCb29sZWFuID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT0gJ1tvYmplY3QgQm9vbGVhbl0nO1xufTtcblxudS5pc0RhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBEYXRlXSc7XG59O1xuXG51LmlzTm90TnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gb2JqICE9IG51bGwgJiYgKHR5cGVvZiBvYmogIT09ICdudW1iZXInID8gdHJ1ZSA6ICFpc05hTihvYmopKTtcbn07XG5cbnUuaXNCdWZmZXIgPSAoQnVmZmVyICYmIEJ1ZmZlci5pc0J1ZmZlcikgfHwgdS5mYWxzZTtcblxuLy8gdHlwZSBjb2VyY2lvbiBmdW5jdGlvbnNcblxudS5udW1iZXIgPSBmdW5jdGlvbihzKSB7IHJldHVybiBzID09IG51bGwgPyBudWxsIDogK3M7IH07XG5cbnUuYm9vbGVhbiA9IGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMgPT0gbnVsbCA/IG51bGwgOiBzPT09J2ZhbHNlJyA/IGZhbHNlIDogISFzOyB9O1xuXG51LmRhdGUgPSBmdW5jdGlvbihzKSB7IHJldHVybiBzID09IG51bGwgPyBudWxsIDogRGF0ZS5wYXJzZShzKTsgfVxuXG51LmFycmF5ID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geCAhPSBudWxsID8gKHUuaXNBcnJheSh4KSA/IHggOiBbeF0pIDogW107IH07XG5cbnUuc3RyID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4gdS5pc0FycmF5KHgpID8gXCJbXCIgKyB4Lm1hcCh1LnN0cikgKyBcIl1cIlxuICAgIDogdS5pc09iamVjdCh4KSA/IEpTT04uc3RyaW5naWZ5KHgpXG4gICAgOiB1LmlzU3RyaW5nKHgpID8gKFwiJ1wiK3V0aWxfZXNjYXBlX3N0cih4KStcIidcIikgOiB4O1xufTtcblxudmFyIGVzY2FwZV9zdHJfcmUgPSAvKF58W15cXFxcXSknL2c7XG5cbmZ1bmN0aW9uIHV0aWxfZXNjYXBlX3N0cih4KSB7XG4gIHJldHVybiB4LnJlcGxhY2UoZXNjYXBlX3N0cl9yZSwgXCIkMVxcXFwnXCIpO1xufVxuXG4vLyB1dGlsaXR5IGZ1bmN0aW9uc1xuXG51LmlkZW50aXR5ID0gZnVuY3Rpb24oeCkgeyByZXR1cm4geDsgfTtcblxudS50cnVlID0gZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9O1xuXG51LmZhbHNlID0gZnVuY3Rpb24oKSB7IHJldHVybiBmYWxzZTsgfTtcblxudS5kdXBsaWNhdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkob2JqKSk7XG59O1xuXG51LmVxdWFsID0gZnVuY3Rpb24oYSwgYikge1xuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYSkgPT09IEpTT04uc3RyaW5naWZ5KGIpO1xufTtcblxudS5leHRlbmQgPSBmdW5jdGlvbihvYmopIHtcbiAgZm9yICh2YXIgeCwgbmFtZSwgaT0xLCBsZW49YXJndW1lbnRzLmxlbmd0aDsgaTxsZW47ICsraSkge1xuICAgIHggPSBhcmd1bWVudHNbaV07XG4gICAgZm9yIChuYW1lIGluIHgpIHsgb2JqW25hbWVdID0geFtuYW1lXTsgfVxuICB9XG4gIHJldHVybiBvYmo7XG59O1xuXG51LmtleXMgPSBmdW5jdGlvbih4KSB7XG4gIHZhciBrZXlzID0gW10sIGs7XG4gIGZvciAoayBpbiB4KSBrZXlzLnB1c2goayk7XG4gIHJldHVybiBrZXlzO1xufTtcblxudS52YWxzID0gZnVuY3Rpb24oeCkge1xuICB2YXIgdmFscyA9IFtdLCBrO1xuICBmb3IgKGsgaW4geCkgdmFscy5wdXNoKHhba10pO1xuICByZXR1cm4gdmFscztcbn07XG5cbnUudG9NYXAgPSBmdW5jdGlvbihsaXN0KSB7XG4gIHJldHVybiBsaXN0LnJlZHVjZShmdW5jdGlvbihvYmosIHgpIHtcbiAgICByZXR1cm4gKG9ialt4XSA9IDEsIG9iaik7XG4gIH0sIHt9KTtcbn07XG5cbnUua2V5c3RyID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIC8vIHVzZSB0byBlbnN1cmUgY29uc2lzdGVudCBrZXkgZ2VuZXJhdGlvbiBhY3Jvc3MgbW9kdWxlc1xuICByZXR1cm4gdmFsdWVzLmpvaW4oXCJ8XCIpO1xufTtcblxuLy8gZGF0YSBhY2Nlc3MgZnVuY3Rpb25zXG5cbnUuZmllbGQgPSBmdW5jdGlvbihmKSB7XG4gIHJldHVybiBmLnNwbGl0KFwiXFxcXC5cIilcbiAgICAubWFwKGZ1bmN0aW9uKGQpIHsgcmV0dXJuIGQuc3BsaXQoXCIuXCIpOyB9KVxuICAgIC5yZWR1Y2UoZnVuY3Rpb24oYSwgYikge1xuICAgICAgaWYgKGEubGVuZ3RoKSB7IGFbYS5sZW5ndGgtMV0gKz0gXCIuXCIgKyBiLnNoaWZ0KCk7IH1cbiAgICAgIGEucHVzaC5hcHBseShhLCBiKTtcbiAgICAgIHJldHVybiBhO1xuICAgIH0sIFtdKTtcbn07XG5cbnUuYWNjZXNzb3IgPSBmdW5jdGlvbihmKSB7XG4gIHZhciBzO1xuICByZXR1cm4gKHUuaXNGdW5jdGlvbihmKSB8fCBmPT1udWxsKVxuICAgID8gZiA6IHUuaXNTdHJpbmcoZikgJiYgKHM9dS5maWVsZChmKSkubGVuZ3RoID4gMVxuICAgID8gZnVuY3Rpb24oeCkgeyByZXR1cm4gcy5yZWR1Y2UoZnVuY3Rpb24oeCxmKSB7XG4gICAgICAgICAgcmV0dXJuIHhbZl07XG4gICAgICAgIH0sIHgpO1xuICAgICAgfVxuICAgIDogZnVuY3Rpb24oeCkgeyByZXR1cm4geFtmXTsgfTtcbn07XG5cbnUubXV0YXRvciA9IGZ1bmN0aW9uKGYpIHtcbiAgdmFyIHM7XG4gIHJldHVybiB1LmlzU3RyaW5nKGYpICYmIChzPXUuZmllbGQoZikpLmxlbmd0aCA+IDFcbiAgICA/IGZ1bmN0aW9uKHgsIHYpIHtcbiAgICAgICAgZm9yICh2YXIgaT0wOyBpPHMubGVuZ3RoLTE7ICsraSkgeCA9IHhbc1tpXV07XG4gICAgICAgIHhbc1tpXV0gPSB2O1xuICAgICAgfVxuICAgIDogZnVuY3Rpb24oeCwgdikgeyB4W2ZdID0gdjsgfTtcbn07XG5cblxuLy8gY29tcGFyaXNvbiAvIHNvcnRpbmcgZnVuY3Rpb25zXG5cbnUuY29tcGFyYXRvciA9IGZ1bmN0aW9uKHNvcnQpIHtcbiAgdmFyIHNpZ24gPSBbXTtcbiAgaWYgKHNvcnQgPT09IHVuZGVmaW5lZCkgc29ydCA9IFtdO1xuICBzb3J0ID0gdS5hcnJheShzb3J0KS5tYXAoZnVuY3Rpb24oZikge1xuICAgIHZhciBzID0gMTtcbiAgICBpZiAgICAgIChmWzBdID09PSBcIi1cIikgeyBzID0gLTE7IGYgPSBmLnNsaWNlKDEpOyB9XG4gICAgZWxzZSBpZiAoZlswXSA9PT0gXCIrXCIpIHsgcyA9ICsxOyBmID0gZi5zbGljZSgxKTsgfVxuICAgIHNpZ24ucHVzaChzKTtcbiAgICByZXR1cm4gdS5hY2Nlc3NvcihmKTtcbiAgfSk7XG4gIHJldHVybiBmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgaSwgbiwgZiwgeCwgeTtcbiAgICBmb3IgKGk9MCwgbj1zb3J0Lmxlbmd0aDsgaTxuOyArK2kpIHtcbiAgICAgIGYgPSBzb3J0W2ldOyB4ID0gZihhKTsgeSA9IGYoYik7XG4gICAgICBpZiAoeCA8IHkpIHJldHVybiAtMSAqIHNpZ25baV07XG4gICAgICBpZiAoeCA+IHkpIHJldHVybiBzaWduW2ldO1xuICAgIH1cbiAgICByZXR1cm4gMDtcbiAgfTtcbn07XG5cbnUuY21wID0gZnVuY3Rpb24oYSwgYikge1xuICBpZiAoYSA8IGIpIHtcbiAgICByZXR1cm4gLTE7XG4gIH0gZWxzZSBpZiAoYSA+IGIpIHtcbiAgICByZXR1cm4gMTtcbiAgfSBlbHNlIGlmIChhID49IGIpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsICYmIGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMDtcbiAgfSBlbHNlIGlmIChhID09PSBudWxsKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGIgPT09IG51bGwpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuICByZXR1cm4gTmFOO1xufTtcblxudS5udW1jbXAgPSBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfTtcblxudS5zdGFibGVzb3J0ID0gZnVuY3Rpb24oYXJyYXksIHNvcnRCeSwga2V5Rm4pIHtcbiAgdmFyIGluZGljZXMgPSBhcnJheS5yZWR1Y2UoZnVuY3Rpb24oaWR4LCB2LCBpKSB7XG4gICAgcmV0dXJuIChpZHhba2V5Rm4odildID0gaSwgaWR4KTtcbiAgfSwge30pO1xuXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzYSA9IHNvcnRCeShhKSxcbiAgICAgICAgc2IgPSBzb3J0QnkoYik7XG4gICAgcmV0dXJuIHNhIDwgc2IgPyAtMSA6IHNhID4gc2IgPyAxXG4gICAgICAgICA6IChpbmRpY2VzW2tleUZuKGEpXSAtIGluZGljZXNba2V5Rm4oYildKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGFycmF5O1xufTtcblxuXG4vLyBzdHJpbmcgZnVuY3Rpb25zXG5cbi8vIEVTNiBjb21wYXRpYmlsaXR5IHBlciBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9TdHJpbmcvc3RhcnRzV2l0aCNQb2x5ZmlsbFxuLy8gV2UgY291bGQgaGF2ZSB1c2VkIHRoZSBwb2x5ZmlsbCBjb2RlLCBidXQgbGV0cyB3YWl0IHVudGlsIEVTNiBiZWNvbWVzIGEgc3RhbmRhcmQgZmlyc3RcbnUuc3RhcnRzV2l0aCA9IFN0cmluZy5wcm90b3R5cGUuc3RhcnRzV2l0aFxuICA/IGZ1bmN0aW9uKHN0cmluZywgc2VhcmNoU3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5zdGFydHNXaXRoKHNlYXJjaFN0cmluZyk7XG4gIH1cbiAgOiBmdW5jdGlvbihzdHJpbmcsIHNlYXJjaFN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcubGFzdEluZGV4T2Yoc2VhcmNoU3RyaW5nLCAwKSA9PT0gMDtcbiAgfTtcblxudS50cnVuY2F0ZSA9IGZ1bmN0aW9uKHMsIGxlbmd0aCwgcG9zLCB3b3JkLCBlbGxpcHNpcykge1xuICB2YXIgbGVuID0gcy5sZW5ndGg7XG4gIGlmIChsZW4gPD0gbGVuZ3RoKSByZXR1cm4gcztcbiAgZWxsaXBzaXMgPSBlbGxpcHNpcyAhPT0gdW5kZWZpbmVkID8gU3RyaW5nKGVsbGlwc2lzKSA6IFwi4oCmXCI7XG4gIHZhciBsID0gTWF0aC5tYXgoMCwgbGVuZ3RoIC0gZWxsaXBzaXMubGVuZ3RoKTtcblxuICBzd2l0Y2ggKHBvcykge1xuICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICByZXR1cm4gZWxsaXBzaXMgKyAod29yZCA/IHRydW5jYXRlT25Xb3JkKHMsbCwxKSA6IHMuc2xpY2UobGVuLWwpKTtcbiAgICBjYXNlIFwibWlkZGxlXCI6XG4gICAgY2FzZSBcImNlbnRlclwiOlxuICAgICAgdmFyIGwxID0gTWF0aC5jZWlsKGwvMiksIGwyID0gTWF0aC5mbG9vcihsLzIpO1xuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsMSkgOiBzLnNsaWNlKDAsbDEpKSArIGVsbGlwc2lzXG4gICAgICAgICsgKHdvcmQgPyB0cnVuY2F0ZU9uV29yZChzLGwyLDEpIDogcy5zbGljZShsZW4tbDIpKTtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuICh3b3JkID8gdHJ1bmNhdGVPbldvcmQocyxsKSA6IHMuc2xpY2UoMCxsKSkgKyBlbGxpcHNpcztcbiAgfVxufTtcblxuZnVuY3Rpb24gdHJ1bmNhdGVPbldvcmQocywgbGVuLCByZXYpIHtcbiAgdmFyIGNudCA9IDAsIHRvayA9IHMuc3BsaXQodHJ1bmNhdGVfd29yZF9yZSk7XG4gIGlmIChyZXYpIHtcbiAgICBzID0gKHRvayA9IHRvay5yZXZlcnNlKCkpXG4gICAgICAuZmlsdGVyKGZ1bmN0aW9uKHcpIHsgY250ICs9IHcubGVuZ3RoOyByZXR1cm4gY250IDw9IGxlbjsgfSlcbiAgICAgIC5yZXZlcnNlKCk7XG4gIH0gZWxzZSB7XG4gICAgcyA9IHRvay5maWx0ZXIoZnVuY3Rpb24odykgeyBjbnQgKz0gdy5sZW5ndGg7IHJldHVybiBjbnQgPD0gbGVuOyB9KTtcbiAgfVxuICByZXR1cm4gcy5sZW5ndGggPyBzLmpvaW4oXCJcIikudHJpbSgpIDogdG9rWzBdLnNsaWNlKDAsIGxlbik7XG59XG5cbnZhciB0cnVuY2F0ZV93b3JkX3JlID0gLyhbXFx1MDAwOVxcdTAwMEFcXHUwMDBCXFx1MDAwQ1xcdTAwMERcXHUwMDIwXFx1MDBBMFxcdTE2ODBcXHUxODBFXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMEFcXHUyMDJGXFx1MjA1RlxcdTIwMjhcXHUyMDI5XFx1MzAwMFxcdUZFRkZdKS87XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi9nbG9iYWxzJyksXG4gIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4vZmllbGQnKSxcbiAgdmxlbmMgPSByZXF1aXJlKCcuL2VuYycpLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKSxcbiAgdGltZSA9IHJlcXVpcmUoJy4vY29tcGlsZS90aW1lJyk7XG5cbnZhciBFbmNvZGluZyA9IG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIEVuY29kaW5nKG1hcmt0eXBlLCBlbmMsIGRhdGEsIGNvbmZpZywgZmlsdGVyLCB0aGVtZSkge1xuICAgIHZhciBkZWZhdWx0cyA9IHNjaGVtYS5pbnN0YW50aWF0ZSgpO1xuXG4gICAgdmFyIHNwZWMgPSB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgbWFya3R5cGU6IG1hcmt0eXBlLFxuICAgICAgZW5jOiBlbmMsXG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIGZpbHRlcjogZmlsdGVyIHx8IFtdXG4gICAgfTtcblxuICAgIC8vIHR5cGUgdG8gYml0Y29kZVxuICAgIGZvciAodmFyIGUgaW4gZGVmYXVsdHMuZW5jKSB7XG4gICAgICBkZWZhdWx0cy5lbmNbZV0udHlwZSA9IGNvbnN0cy5kYXRhVHlwZXNbZGVmYXVsdHMuZW5jW2VdLnR5cGVdO1xuICAgIH1cblxuICAgIHZhciBzcGVjRXh0ZW5kZWQgPSBzY2hlbWEudXRpbC5tZXJnZShkZWZhdWx0cywgdGhlbWUgfHwge30sIHNwZWMpIDtcblxuICAgIHRoaXMuX2RhdGEgPSBzcGVjRXh0ZW5kZWQuZGF0YTtcbiAgICB0aGlzLl9tYXJrdHlwZSA9IHNwZWNFeHRlbmRlZC5tYXJrdHlwZTtcbiAgICB0aGlzLl9lbmMgPSBzcGVjRXh0ZW5kZWQuZW5jO1xuICAgIHRoaXMuX2NvbmZpZyA9IHNwZWNFeHRlbmRlZC5jb25maWc7XG4gICAgdGhpcy5fZmlsdGVyID0gc3BlY0V4dGVuZGVkLmZpbHRlcjtcbiAgfVxuXG4gIHZhciBwcm90byA9IEVuY29kaW5nLnByb3RvdHlwZTtcblxuICBwcm90by5tYXJrdHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXJrdHlwZTtcbiAgfTtcblxuICBwcm90by5pcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGUgPT09IG07XG4gIH07XG5cbiAgcHJvdG8uaGFzID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIC8vIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB2bGVuYy5oYXModGhpcy5fZW5jLCBlbmNUeXBlKVxuICAgIHJldHVybiB0aGlzLl9lbmNbZW5jVHlwZV0ubmFtZSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHByb3RvLmVuYyA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF07XG4gIH07XG5cbiAgcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlck51bGwgPSBbXSxcbiAgICAgIGZpZWxkcyA9IHRoaXMuZmllbGRzKCksXG4gICAgICBzZWxmID0gdGhpcztcblxuICAgIHV0aWwuZm9yRWFjaChmaWVsZHMsIGZ1bmN0aW9uKGZpZWxkTGlzdCwgZmllbGROYW1lKSB7XG4gICAgICBpZiAoZmllbGROYW1lID09PSAnKicpIHJldHVybjsgLy9jb3VudFxuXG4gICAgICBpZiAoKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuUSAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW1FdKSB8fFxuICAgICAgICAgIChzZWxmLmNvbmZpZygnZmlsdGVyTnVsbCcpLlQgJiYgZmllbGRMaXN0LmNvbnRhaW5zVHlwZVtUXSkgfHxcbiAgICAgICAgICAoc2VsZi5jb25maWcoJ2ZpbHRlck51bGwnKS5PICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbT10pKSB7XG4gICAgICAgIGZpbHRlck51bGwucHVzaCh7XG4gICAgICAgICAgb3BlcmFuZHM6IFtmaWVsZE5hbWVdLFxuICAgICAgICAgIG9wZXJhdG9yOiAnbm90TnVsbCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmlsdGVyTnVsbC5jb25jYXQodGhpcy5fZmlsdGVyKTtcbiAgfTtcblxuICAvLyBnZXQgXCJmaWVsZFwiIHByb3BlcnR5IGZvciB2ZWdhXG4gIHByb3RvLmZpZWxkID0gZnVuY3Rpb24oZXQsIG5vZGF0YSwgbm9mbikge1xuICAgIGlmICghdGhpcy5oYXMoZXQpKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBmID0gKG5vZGF0YSA/ICcnIDogJ2RhdGEuJyk7XG5cbiAgICBpZiAodGhpcy5fZW5jW2V0XS5hZ2dyID09PSAnY291bnQnKSB7XG4gICAgICByZXR1cm4gZiArICdjb3VudCc7XG4gICAgfSBlbHNlIGlmICghbm9mbiAmJiB0aGlzLl9lbmNbZXRdLmJpbikge1xuICAgICAgcmV0dXJuIGYgKyAnYmluXycgKyB0aGlzLl9lbmNbZXRdLm5hbWU7XG4gICAgfSBlbHNlIGlmICghbm9mbiAmJiB0aGlzLl9lbmNbZXRdLmFnZ3IpIHtcbiAgICAgIHJldHVybiBmICsgdGhpcy5fZW5jW2V0XS5hZ2dyICsgJ18nICsgdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH0gZWxzZSBpZiAoIW5vZm4gJiYgdGhpcy5fZW5jW2V0XS5mbikge1xuICAgICAgcmV0dXJuIGYgKyB0aGlzLl9lbmNbZXRdLmZuICsgJ18nICsgdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZiArIHRoaXMuX2VuY1tldF0ubmFtZTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uZmllbGROYW1lID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICB9O1xuXG4gIC8qXG4gICAqIHJldHVybiBrZXktdmFsdWUgcGFpcnMgb2YgZmllbGQgbmFtZSBhbmQgbGlzdCBvZiBmaWVsZHMgb2YgdGhhdCBmaWVsZCBuYW1lXG4gICAqL1xuICBwcm90by5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmxlbmMuZmllbGRzKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgcHJvdG8uZmllbGRUaXRsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgaWYgKHZsZmllbGQuaXNDb3VudCh0aGlzLl9lbmNbZXRdKSkge1xuICAgICAgcmV0dXJuIHZsZmllbGQuY291bnQuZGlzcGxheU5hbWU7XG4gICAgfVxuICAgIHZhciBmbiA9IHRoaXMuX2VuY1tldF0uYWdnciB8fCB0aGlzLl9lbmNbZXRdLmZuIHx8ICh0aGlzLl9lbmNbZXRdLmJpbiAmJiBcImJpblwiKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJldHVybiBmbi50b1VwcGVyQ2FzZSgpICsgJygnICsgdGhpcy5fZW5jW2V0XS5uYW1lICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5zY2FsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uc2NhbGUgfHwge307XG4gIH07XG5cbiAgcHJvdG8uYXhpcyA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYXhpcyB8fCB7fTtcbiAgfTtcblxuICBwcm90by5iYW5kID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5iYW5kIHx8IHt9O1xuICB9O1xuXG4gIHByb3RvLmJhbmRTaXplID0gZnVuY3Rpb24oZW5jVHlwZSwgdXNlU21hbGxCYW5kKSB7XG4gICAgdXNlU21hbGxCYW5kID0gdXNlU21hbGxCYW5kIHx8XG4gICAgICAvL2lzQmFuZEluU21hbGxNdWx0aXBsZXNcbiAgICAgIChlbmNUeXBlID09PSBZICYmIHRoaXMuaGFzKFJPVykgJiYgdGhpcy5oYXMoWSkpIHx8XG4gICAgICAoZW5jVHlwZSA9PT0gWCAmJiB0aGlzLmhhcyhDT0wpICYmIHRoaXMuaGFzKFgpKTtcblxuICAgIC8vIGlmIGJhbmQuc2l6ZSBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCwgZm9sbG93IHRoZSBzcGVjaWZpY2F0aW9uLCBvdGhlcndpc2UgZHJhdyB2YWx1ZSBmcm9tIGNvbmZpZy5cbiAgICByZXR1cm4gdGhpcy5iYW5kKGVuY1R5cGUpLnNpemUgfHxcbiAgICAgIHRoaXMuY29uZmlnKHVzZVNtYWxsQmFuZCA/ICdzbWFsbEJhbmRTaXplJyA6ICdsYXJnZUJhbmRTaXplJyk7XG4gIH07XG5cbiAgcHJvdG8uYWdnciA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYWdncjtcbiAgfTtcblxuICAvLyByZXR1cm5zIGZhbHNlIGlmIGJpbm5pbmcgaXMgZGlzYWJsZWQsIG90aGVyd2lzZSBhbiBvYmplY3Qgd2l0aCBiaW5uaW5nIHByb3BlcnRpZXNcbiAgcHJvdG8uYmluID0gZnVuY3Rpb24oZXQpIHtcbiAgICB2YXIgYmluID0gdGhpcy5fZW5jW2V0XS5iaW47XG4gICAgaWYgKGJpbiA9PT0ge30pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGJpbiA9PT0gdHJ1ZSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1heGJpbnM6IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFRcbiAgICAgIH07XG4gICAgcmV0dXJuIGJpbjtcbiAgfTtcblxuICBwcm90by5sZWdlbmQgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLmxlZ2VuZDtcbiAgfTtcblxuICBwcm90by52YWx1ZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0udmFsdWU7XG4gIH07XG5cbiAgcHJvdG8uZm4gPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLmZuO1xuICB9O1xuXG4gIHByb3RvLnNvcnQgPSBmdW5jdGlvbihldCwgc3RhdHMpIHtcbiAgICB2YXIgc29ydCA9IHRoaXMuX2VuY1tldF0uc29ydCxcbiAgICAgIGVuYyA9IHRoaXMuX2VuYyxcbiAgICAgIGlzVHlwZSA9IHZsZmllbGQuaXNUeXBlLmJ5Q29kZTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdzb3J0OicsIHNvcnQsICdzdXBwb3J0OicsIEVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydCh7ZW5jOnRoaXMuX2VuY30sIHN0YXRzKSAsICd0b2dnbGU6JywgdGhpcy5jb25maWcoJ3RvZ2dsZVNvcnQnKSlcblxuICAgIGlmICgoIXNvcnQgfHwgc29ydC5sZW5ndGg9PT0wKSAmJlxuICAgICAgICBFbmNvZGluZy50b2dnbGVTb3J0LnN1cHBvcnQoe2VuYzp0aGlzLl9lbmN9LCBzdGF0cywgdHJ1ZSkgJiYgLy9IQUNLXG4gICAgICAgIHRoaXMuY29uZmlnKCd0b2dnbGVTb3J0JykgPT09ICdRJ1xuICAgICAgKSB7XG4gICAgICB2YXIgcUZpZWxkID0gaXNUeXBlKGVuYy54LCBPKSA/IGVuYy55IDogZW5jLng7XG5cbiAgICAgIGlmIChpc1R5cGUoZW5jW2V0XSwgTykpIHtcbiAgICAgICAgc29ydCA9IFt7XG4gICAgICAgICAgbmFtZTogcUZpZWxkLm5hbWUsXG4gICAgICAgICAgYWdncjogcUZpZWxkLmFnZ3IsXG4gICAgICAgICAgdHlwZTogcUZpZWxkLnR5cGUsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc29ydDtcbiAgfTtcblxuICBwcm90by5sZW5ndGggPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdXRpbC5rZXlzKHRoaXMuX2VuYykubGVuZ3RoO1xuICB9O1xuXG4gIHByb3RvLm1hcCA9IGZ1bmN0aW9uKGYpIHtcbiAgICByZXR1cm4gdmxlbmMubWFwKHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8ucmVkdWNlID0gZnVuY3Rpb24oZiwgaW5pdCkge1xuICAgIHJldHVybiB2bGVuYy5yZWR1Y2UodGhpcy5fZW5jLCBmLCBpbml0KTtcbiAgfTtcblxuICBwcm90by5mb3JFYWNoID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB2bGVuYy5mb3JFYWNoKHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8udHlwZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGV0KSA/IHRoaXMuX2VuY1tldF0udHlwZSA6IG51bGw7XG4gIH07XG5cbiAgcHJvdG8ucm9sZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGV0KSA/IHZsZmllbGQucm9sZSh0aGlzLl9lbmNbZXRdKSA6IG51bGw7XG4gIH07XG5cbiAgcHJvdG8udGV4dCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICB2YXIgdGV4dCA9IHRoaXMuX2VuY1tURVhUXS50ZXh0O1xuICAgIHJldHVybiBwcm9wID8gdGV4dFtwcm9wXSA6IHRleHQ7XG4gIH07XG5cbiAgcHJvdG8uZm9udCA9IGZ1bmN0aW9uKHByb3ApIHtcbiAgICB2YXIgZm9udCA9IHRoaXMuX2VuY1tURVhUXS5mb250O1xuICAgIHJldHVybiBwcm9wID8gZm9udFtwcm9wXSA6IGZvbnQ7XG4gIH07XG5cbiAgcHJvdG8uaXNUeXBlID0gZnVuY3Rpb24oZXQsIHR5cGUpIHtcbiAgICB2YXIgZmllbGQgPSB0aGlzLmVuYyhldCk7XG4gICAgcmV0dXJuIGZpZWxkICYmIEVuY29kaW5nLmlzVHlwZShmaWVsZCwgdHlwZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNUeXBlID0gZnVuY3Rpb24gKGZpZWxkRGVmLCB0eXBlKSB7XG4gICAgLy8gRklYTUUgdmxmaWVsZC5pc1R5cGVcbiAgICByZXR1cm4gKGZpZWxkRGVmLnR5cGUgJiB0eXBlKSA+IDA7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUgPSBmdW5jdGlvbihlbmNvZGluZywgZW5jVHlwZSkge1xuICAgIHJldHVybiB2bGZpZWxkLmlzT3JkaW5hbFNjYWxlKGVuY29kaW5nLmVuYyhlbmNUeXBlKSwgdHJ1ZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNEaW1lbnNpb24gPSBmdW5jdGlvbihlbmNvZGluZywgZW5jVHlwZSkge1xuICAgIHJldHVybiB2bGZpZWxkLmlzRGltZW5zaW9uKGVuY29kaW5nLmVuYyhlbmNUeXBlKSwgdHJ1ZSk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNNZWFzdXJlID0gZnVuY3Rpb24oZW5jb2RpbmcsIGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5pc01lYXN1cmUoZW5jb2RpbmcuZW5jKGVuY1R5cGUpLCB0cnVlKTtcbiAgfTtcblxuICBwcm90by5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoZW5jVHlwZSkgJiYgRW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUodGhpcywgZW5jVHlwZSk7XG4gIH07XG5cbiAgcHJvdG8uaXNEaW1lbnNpb24gPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHRoaXMuaGFzKGVuY1R5cGUpICYmIEVuY29kaW5nLmlzRGltZW5zaW9uKHRoaXMsIGVuY1R5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzTWVhc3VyZSA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoZW5jVHlwZSkgJiYgRW5jb2RpbmcuaXNNZWFzdXJlKHRoaXMsIGVuY1R5cGUpO1xuICB9O1xuXG4gIHByb3RvLmlzQWdncmVnYXRlID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHZsZW5jLmlzQWdncmVnYXRlKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuIHZsZW5jLmlzQWdncmVnYXRlKHNwZWMuZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5hbHdheXNOb09jY2x1c2lvbiA9IGZ1bmN0aW9uKHNwZWMsIHN0YXRzKSB7XG4gICAgLy8gRklYTUUgcmF3IE94USB3aXRoICMgb2Ygcm93cyA9ICMgb2YgT1xuICAgIHJldHVybiB2bGVuYy5pc0FnZ3JlZ2F0ZShzcGVjLmVuYyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuaXNTdGFjayA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICAvLyBGSVhNRSB1cGRhdGUgdGhpcyBvbmNlIHdlIGhhdmUgY29udHJvbCBmb3Igc3RhY2sgLi4uXG4gICAgcmV0dXJuIChzcGVjLm1hcmt0eXBlID09PSAnYmFyJyB8fCBzcGVjLm1hcmt0eXBlID09PSAnYXJlYScpICYmXG4gICAgICBzcGVjLmVuYy5jb2xvcjtcbiAgfTtcblxuICBwcm90by5pc1N0YWNrID0gZnVuY3Rpb24oKSB7XG4gICAgLy8gRklYTUUgdXBkYXRlIHRoaXMgb25jZSB3ZSBoYXZlIGNvbnRyb2wgZm9yIHN0YWNrIC4uLlxuICAgIHJldHVybiAodGhpcy5pcygnYmFyJykgfHwgdGhpcy5pcygnYXJlYScpKSAmJiB0aGlzLmhhcygnY29sb3InKTtcbiAgfTtcblxuICBwcm90by5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGVuY1R5cGUsIHN0YXRzKSB7XG4gICAgcmV0dXJuIHZsZmllbGQuY2FyZGluYWxpdHkodGhpcy5lbmMoZW5jVHlwZSksIHN0YXRzLCB0aGlzLmNvbmZpZygnZmlsdGVyTnVsbCcpLCB0cnVlKTtcbiAgfTtcblxuICBwcm90by5pc1JhdyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAhdGhpcy5pc0FnZ3JlZ2F0ZSgpO1xuICB9O1xuXG4gIHByb3RvLmRhdGEgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2RhdGFbbmFtZV07XG4gIH07XG5cbiAgcHJvdG8uY29uZmlnID0gZnVuY3Rpb24obmFtZSkge1xuICAgIHJldHVybiB0aGlzLl9jb25maWdbbmFtZV07XG4gIH07XG5cbiAgcHJvdG8udG9TcGVjID0gZnVuY3Rpb24oZXhjbHVkZUNvbmZpZykge1xuICAgIHZhciBlbmMgPSB1dGlsLmR1cGxpY2F0ZSh0aGlzLl9lbmMpLFxuICAgICAgc3BlYztcblxuICAgIC8vIGNvbnZlcnQgdHlwZSdzIGJpdGNvZGUgdG8gdHlwZSBuYW1lXG4gICAgZm9yICh2YXIgZSBpbiBlbmMpIHtcbiAgICAgIGVuY1tlXS50eXBlID0gY29uc3RzLmRhdGFUeXBlTmFtZXNbZW5jW2VdLnR5cGVdO1xuICAgIH1cblxuICAgIHNwZWMgPSB7XG4gICAgICBtYXJrdHlwZTogdGhpcy5fbWFya3R5cGUsXG4gICAgICBlbmM6IGVuYyxcbiAgICAgIGZpbHRlcjogdGhpcy5fZmlsdGVyXG4gICAgfTtcblxuICAgIGlmICghZXhjbHVkZUNvbmZpZykge1xuICAgICAgc3BlYy5jb25maWcgPSB1dGlsLmR1cGxpY2F0ZSh0aGlzLl9jb25maWcpO1xuICAgIH1cblxuICAgIC8vIHJlbW92ZSBkZWZhdWx0c1xuICAgIHZhciBkZWZhdWx0cyA9IHNjaGVtYS5pbnN0YW50aWF0ZSgpO1xuICAgIHJldHVybiBzY2hlbWEudXRpbC5zdWJ0cmFjdChzcGVjLCBkZWZhdWx0cyk7XG4gIH07XG5cbiAgcHJvdG8udG9TaG9ydGhhbmQgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQ7XG4gICAgcmV0dXJuICdtYXJrJyArIGMuYXNzaWduICsgdGhpcy5fbWFya3R5cGUgK1xuICAgICAgYy5kZWxpbSArIHZsZW5jLnNob3J0aGFuZCh0aGlzLl9lbmMpO1xuICB9O1xuXG4gIEVuY29kaW5nLnNob3J0aGFuZCA9IGZ1bmN0aW9uIChzcGVjKSB7XG4gICAgdmFyIGMgPSBjb25zdHMuc2hvcnRoYW5kO1xuICAgIHJldHVybiAnbWFyaycgKyBjLmFzc2lnbiArIHNwZWMubWFya3R5cGUgK1xuICAgICAgYy5kZWxpbSArIHZsZW5jLnNob3J0aGFuZChzcGVjLmVuYyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnLCB0aGVtZSkge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZCxcbiAgICAgICAgc3BsaXQgPSBzaG9ydGhhbmQuc3BsaXQoYy5kZWxpbSksXG4gICAgICAgIG1hcmt0eXBlID0gc3BsaXQuc2hpZnQoKS5zcGxpdChjLmFzc2lnbilbMV0udHJpbSgpLFxuICAgICAgICBlbmMgPSB2bGVuYy5mcm9tU2hvcnRoYW5kKHNwbGl0LCB0cnVlKTtcblxuICAgIHJldHVybiBuZXcgRW5jb2RpbmcobWFya3R5cGUsIGVuYywgZGF0YSwgY29uZmlnLCBudWxsLCB0aGVtZSk7XG4gIH07XG5cbiAgRW5jb2Rpbmcuc3BlY0Zyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGRhdGEsIGNvbmZpZywgZXhjbHVkZUNvbmZpZykge1xuICAgIHJldHVybiBFbmNvZGluZy5mcm9tU2hvcnRoYW5kKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnKS50b1NwZWMoZXhjbHVkZUNvbmZpZyk7XG4gIH07XG5cbiAgRW5jb2RpbmcuZnJvbVNwZWMgPSBmdW5jdGlvbihzcGVjLCB0aGVtZSkge1xuICAgIHZhciBlbmMgPSB1dGlsLmR1cGxpY2F0ZShzcGVjLmVuYyB8fCB7fSk7XG5cbiAgICAvL2NvbnZlcnQgdHlwZSBmcm9tIHN0cmluZyB0byBiaXRjb2RlIChlLmcsIE89MSlcbiAgICBmb3IgKHZhciBlIGluIGVuYykge1xuICAgICAgZW5jW2VdLnR5cGUgPSBjb25zdHMuZGF0YVR5cGVzW2VuY1tlXS50eXBlXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IEVuY29kaW5nKHNwZWMubWFya3R5cGUsIGVuYywgc3BlYy5kYXRhLCBzcGVjLmNvbmZpZywgc3BlYy5maWx0ZXIsIHRoZW1lKTtcbiAgfTtcblxuICBFbmNvZGluZy50cmFuc3Bvc2UgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgdmFyIG9sZGVuYyA9IHNwZWMuZW5jLFxuICAgICAgZW5jID0gdXRpbC5kdXBsaWNhdGUoc3BlYy5lbmMpO1xuICAgIGVuYy54ID0gb2xkZW5jLnk7XG4gICAgZW5jLnkgPSBvbGRlbmMueDtcbiAgICBlbmMucm93ID0gb2xkZW5jLmNvbDtcbiAgICBlbmMuY29sID0gb2xkZW5jLnJvdztcbiAgICBzcGVjLmVuYyA9IGVuYztcbiAgICByZXR1cm4gc3BlYztcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVTb3J0ID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHNwZWMuY29uZmlnID0gc3BlYy5jb25maWcgfHwge307XG4gICAgc3BlYy5jb25maWcudG9nZ2xlU29ydCA9IHNwZWMuY29uZmlnLnRvZ2dsZVNvcnQgPT09ICdRJyA/ICdPJyA6J1EnO1xuICAgIHJldHVybiBzcGVjO1xuICB9O1xuXG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydC5kaXJlY3Rpb24gPSBmdW5jdGlvbihzcGVjLCB1c2VUeXBlQ29kZSkge1xuICAgIGlmICghRW5jb2RpbmcudG9nZ2xlU29ydC5zdXBwb3J0KHNwZWMsIHVzZVR5cGVDb2RlKSkgeyByZXR1cm47IH1cbiAgICB2YXIgZW5jID0gc3BlYy5lbmM7XG4gICAgcmV0dXJuIGVuYy54LnR5cGUgPT09ICdPJyA/ICd4JyA6ICAneSc7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydC5tb2RlID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHJldHVybiBzcGVjLmNvbmZpZy50b2dnbGVTb3J0O1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydCA9IGZ1bmN0aW9uKHNwZWMsIHN0YXRzLCB1c2VUeXBlQ29kZSkge1xuICAgIHZhciBlbmMgPSBzcGVjLmVuYyxcbiAgICAgIGlzVHlwZSA9IHZsZmllbGQuaXNUeXBlLmdldCh1c2VUeXBlQ29kZSk7XG5cbiAgICBpZiAodmxlbmMuaGFzKGVuYywgUk9XKSB8fCB2bGVuYy5oYXMoZW5jLCBDT0wpIHx8XG4gICAgICAhdmxlbmMuaGFzKGVuYywgWCkgfHwgIXZsZW5jLmhhcyhlbmMsIFkpIHx8XG4gICAgICAhRW5jb2RpbmcuYWx3YXlzTm9PY2NsdXNpb24oc3BlYywgc3RhdHMpKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuXG4gICAgcmV0dXJuICggaXNUeXBlKGVuYy54LCBPKSAmJiB2bGZpZWxkLmlzTWVhc3VyZShlbmMueSwgdXNlVHlwZUNvZGUpKSA/ICd4JyA6XG4gICAgICAoIGlzVHlwZShlbmMueSwgTykgJiYgdmxmaWVsZC5pc01lYXN1cmUoZW5jLngsIHVzZVR5cGVDb2RlKSkgPyAneScgOiBmYWxzZTtcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVGaWx0ZXJOdWxsTyA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICBzcGVjLmNvbmZpZyA9IHNwZWMuY29uZmlnIHx8IHt9O1xuICAgIHNwZWMuY29uZmlnLmZpbHRlck51bGwgPSBzcGVjLmNvbmZpZy5maWx0ZXJOdWxsIHx8IHsgLy9GSVhNRVxuICAgICAgVDogdHJ1ZSxcbiAgICAgIFE6IHRydWVcbiAgICB9O1xuICAgIHNwZWMuY29uZmlnLmZpbHRlck51bGwuTyA9ICFzcGVjLmNvbmZpZy5maWx0ZXJOdWxsLk87XG4gICAgcmV0dXJuIHNwZWM7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlRmlsdGVyTnVsbE8uc3VwcG9ydCA9IGZ1bmN0aW9uKHNwZWMsIHN0YXRzKSB7XG4gICAgdmFyIGZpZWxkcyA9IHZsZW5jLmZpZWxkcyhzcGVjLmVuYyk7XG4gICAgZm9yICh2YXIgZmllbGROYW1lIGluIGZpZWxkcykge1xuICAgICAgdmFyIGZpZWxkTGlzdCA9IGZpZWxkc1tmaWVsZE5hbWVdO1xuICAgICAgaWYgKGZpZWxkTGlzdC5jb250YWluc1R5cGUuTyAmJiBmaWVsZE5hbWUgaW4gc3RhdHMgJiYgc3RhdHNbZmllbGROYW1lXS5udWxscyA+IDApIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfTtcblxuICByZXR1cm4gRW5jb2Rpbmc7XG59KSgpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZ2dyZWdhdGVzO1xuXG5mdW5jdGlvbiBhZ2dyZWdhdGVzKHNwZWMsIGVuY29kaW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIHZhciBkaW1zID0ge30sIG1lYXMgPSB7fSwgZGV0YWlsID0ge30sIGZhY2V0cyA9IHt9LFxuICAgIGRhdGEgPSBzcGVjLmRhdGFbMV07IC8vIGN1cnJlbnRseSBkYXRhWzBdIGlzIHJhdyBhbmQgZGF0YVsxXSBpcyB0YWJsZVxuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZmllbGQuYWdncikge1xuICAgICAgaWYgKGZpZWxkLmFnZ3IgPT09ICdjb3VudCcpIHtcbiAgICAgICAgbWVhcy5jb3VudCA9IHtvcDogJ2NvdW50JywgZmllbGQ6ICcqJ307XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIG1lYXNbZmllbGQuYWdnciArICd8JysgZmllbGQubmFtZV0gPSB7XG4gICAgICAgICAgb3A6IGZpZWxkLmFnZ3IsXG4gICAgICAgICAgZmllbGQ6ICdkYXRhLicrIGZpZWxkLm5hbWVcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZGltc1tmaWVsZC5uYW1lXSA9IGVuY29kaW5nLmZpZWxkKGVuY1R5cGUpO1xuICAgICAgaWYgKGVuY1R5cGUgPT0gUk9XIHx8IGVuY1R5cGUgPT0gQ09MKSB7XG4gICAgICAgIGZhY2V0c1tmaWVsZC5uYW1lXSA9IGRpbXNbZmllbGQubmFtZV07XG4gICAgICB9ZWxzZSBpZiAoZW5jVHlwZSAhPT0gWCAmJiBlbmNUeXBlICE9PSBZKSB7XG4gICAgICAgIGRldGFpbFtmaWVsZC5uYW1lXSA9IGRpbXNbZmllbGQubmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgZGltcyA9IHV0aWwudmFscyhkaW1zKTtcbiAgbWVhcyA9IHV0aWwudmFscyhtZWFzKTtcblxuICBpZiAobWVhcy5sZW5ndGggPiAwICYmICFvcHQucHJlYWdncmVnYXRlZERhdGEpIHtcbiAgICBpZiAoIWRhdGEudHJhbnNmb3JtKSBkYXRhLnRyYW5zZm9ybSA9IFtdO1xuICAgIGRhdGEudHJhbnNmb3JtLnB1c2goe1xuICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICBncm91cGJ5OiBkaW1zLFxuICAgICAgZmllbGRzOiBtZWFzXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBkZXRhaWxzOiB1dGlsLnZhbHMoZGV0YWlsKSxcbiAgICBkaW1zOiBkaW1zLFxuICAgIGZhY2V0czogdXRpbC52YWxzKGZhY2V0cyksXG4gICAgYWdncmVnYXRlZDogbWVhcy5sZW5ndGggPiAwXG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBzZXR0ZXIgPSB1dGlsLnNldHRlcixcbiAgZ2V0dGVyID0gdXRpbC5nZXR0ZXIsXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxudmFyIGF4aXMgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5heGlzLm5hbWVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgcmV0dXJuIHV0aWwua2V5cyh1dGlsLmtleXMocHJvcHMpLnJlZHVjZShmdW5jdGlvbihhLCB4KSB7XG4gICAgdmFyIHMgPSBwcm9wc1t4XS5zY2FsZTtcbiAgICBpZiAocyA9PT0gWCB8fCBzID09PSBZKSBhW3Byb3BzW3hdLnNjYWxlXSA9IDE7XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KSk7XG59O1xuXG5heGlzLmRlZnMgPSBmdW5jdGlvbihuYW1lcywgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIG9wdCkge1xuICByZXR1cm4gbmFtZXMucmVkdWNlKGZ1bmN0aW9uKGEsIG5hbWUpIHtcbiAgICBhLnB1c2goYXhpcy5kZWYobmFtZSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIG9wdCkpO1xuICAgIHJldHVybiBhO1xuICB9LCBbXSk7XG59O1xuXG5heGlzLmRlZiA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzLCBvcHQpIHtcbiAgdmFyIHR5cGUgPSBuYW1lO1xuICB2YXIgaXNDb2wgPSBuYW1lID09IENPTCwgaXNSb3cgPSBuYW1lID09IFJPVztcbiAgdmFyIHJvd09mZnNldCA9IGF4aXNUaXRsZU9mZnNldChlbmNvZGluZywgbGF5b3V0LCBZKSArIDIwLFxuICAgIGNlbGxQYWRkaW5nID0gbGF5b3V0LmNlbGxQYWRkaW5nO1xuXG5cbiAgaWYgKGlzQ29sKSB0eXBlID0gJ3gnO1xuICBpZiAoaXNSb3cpIHR5cGUgPSAneSc7XG5cbiAgdmFyIGRlZiA9IHtcbiAgICB0eXBlOiB0eXBlLFxuICAgIHNjYWxlOiBuYW1lXG4gIH07XG5cbiAgaWYgKGVuY29kaW5nLmF4aXMobmFtZSkuZ3JpZCkge1xuICAgIGRlZi5ncmlkID0gdHJ1ZTtcbiAgICBkZWYubGF5ZXIgPSAoaXNSb3cgfHwgaXNDb2wpID8gJ2Zyb250JyA6ICAnYmFjayc7XG5cbiAgICBpZiAoaXNDb2wpIHtcbiAgICAgIC8vIHNldCBncmlkIHByb3BlcnR5IC0tIHB1dCB0aGUgbGluZXMgb24gdGhlIHJpZ2h0IHRoZSBjZWxsXG4gICAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnZ3JpZCddLCB7XG4gICAgICAgIHg6IHtcbiAgICAgICAgICBvZmZzZXQ6IGxheW91dC5jZWxsV2lkdGggKiAoMSsgY2VsbFBhZGRpbmcvMi4wKSxcbiAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlKHMpIC0tIHZlZ2EgZG9lc24ndCBkbyByZWN1cnNpdmUgbWVyZ2VcbiAgICAgICAgICBzY2FsZTogJ2NvbCdcbiAgICAgICAgfSxcbiAgICAgICAgeToge1xuICAgICAgICAgIHZhbHVlOiAtbGF5b3V0LmNlbGxIZWlnaHQgKiAoY2VsbFBhZGRpbmcvMiksXG4gICAgICAgIH0sXG4gICAgICAgIHN0cm9rZTogeyB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdjZWxsR3JpZENvbG9yJykgfVxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmIChpc1Jvdykge1xuICAgICAgLy8gc2V0IGdyaWQgcHJvcGVydHkgLS0gcHV0IHRoZSBsaW5lcyBvbiB0aGUgdG9wXG4gICAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnZ3JpZCddLCB7XG4gICAgICAgIHk6IHtcbiAgICAgICAgICBvZmZzZXQ6IC1sYXlvdXQuY2VsbEhlaWdodCAqIChjZWxsUGFkZGluZy8yKSxcbiAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlKHMpIC0tIHZlZ2EgZG9lc24ndCBkbyByZWN1cnNpdmUgbWVyZ2VcbiAgICAgICAgICBzY2FsZTogJ3JvdydcbiAgICAgICAgfSxcbiAgICAgICAgeDoge1xuICAgICAgICAgIHZhbHVlOiByb3dPZmZzZXRcbiAgICAgICAgfSxcbiAgICAgICAgeDI6IHtcbiAgICAgICAgICBvZmZzZXQ6IHJvd09mZnNldCArIChsYXlvdXQuY2VsbFdpZHRoICogMC4wNSksXG4gICAgICAgICAgLy8gZGVmYXVsdCB2YWx1ZShzKSAtLSB2ZWdhIGRvZXNuJ3QgZG8gcmVjdXJzaXZlIG1lcmdlXG4gICAgICAgICAgZ3JvdXA6IFwibWFyay5ncm91cC53aWR0aFwiLFxuICAgICAgICAgIG11bHQ6IDFcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkQ29sb3InKSB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ2dyaWQnLCAnc3Ryb2tlJ10sIHtcbiAgICAgICAgdmFsdWU6IGVuY29kaW5nLmNvbmZpZygnZ3JpZENvbG9yJylcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChlbmNvZGluZy5heGlzKG5hbWUpLnRpdGxlKSB7XG4gICAgZGVmID0gYXhpc190aXRsZShkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIG9wdCk7XG4gIH1cblxuICBpZiAoaXNSb3cgfHwgaXNDb2wpIHtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAndGlja3MnXSwge1xuICAgICAgb3BhY2l0eToge3ZhbHVlOiAwfVxuICAgIH0pO1xuICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICdtYWpvclRpY2tzJ10sIHtcbiAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMH1cbiAgICB9KTtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnYXhpcyddLCB7XG4gICAgICBvcGFjaXR5OiB7dmFsdWU6IDB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAoaXNDb2wpIHtcbiAgICBkZWYub3JpZW50ID0gJ3RvcCc7XG4gIH1cblxuICBpZiAoaXNSb3cpIHtcbiAgICBkZWYub2Zmc2V0ID0gcm93T2Zmc2V0O1xuICB9XG5cbiAgaWYgKG5hbWUgPT0gWCkge1xuICAgIGlmIChlbmNvZGluZy5oYXMoWSkgJiYgZW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUoWSkgJiYgZW5jb2RpbmcuY2FyZGluYWxpdHkoWSwgc3RhdHMpID4gMzApIHtcbiAgICAgIGRlZi5vcmllbnQgPSAndG9wJztcbiAgICB9XG5cbiAgICBpZiAoZW5jb2RpbmcuaXNEaW1lbnNpb24oWCkgfHwgZW5jb2RpbmcuaXNUeXBlKFgsIFQpKSB7XG4gICAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCdsYWJlbHMnXSwge1xuICAgICAgICBhbmdsZToge3ZhbHVlOiAyNzB9LFxuICAgICAgICBhbGlnbjoge3ZhbHVlOiAncmlnaHQnfSxcbiAgICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogJ21pZGRsZSd9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgeyAvLyBRXG4gICAgICBkZWYudGlja3MgPSA1O1xuICAgIH1cbiAgfVxuXG4gIGRlZiA9IGF4aXNfbGFiZWxzKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCwgb3B0KTtcblxuICByZXR1cm4gZGVmO1xufTtcblxuZnVuY3Rpb24gYXhpc190aXRsZShkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIG9wdCkge1xuICB2YXIgbWF4bGVuZ3RoID0gbnVsbCxcbiAgICBmaWVsZFRpdGxlID0gZW5jb2RpbmcuZmllbGRUaXRsZShuYW1lKTtcbiAgaWYgKG5hbWU9PT1YKSB7XG4gICAgbWF4bGVuZ3RoID0gbGF5b3V0LmNlbGxXaWR0aCAvIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKTtcbiAgfSBlbHNlIGlmIChuYW1lID09PSBZKSB7XG4gICAgbWF4bGVuZ3RoID0gbGF5b3V0LmNlbGxIZWlnaHQgLyBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJyk7XG4gIH1cblxuICBkZWYudGl0bGUgPSBtYXhsZW5ndGggPyB1dGlsLnRydW5jYXRlKGZpZWxkVGl0bGUsIG1heGxlbmd0aCkgOiBmaWVsZFRpdGxlO1xuXG4gIGlmIChuYW1lID09PSBST1cpIHtcbiAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCd0aXRsZSddLCB7XG4gICAgICBhbmdsZToge3ZhbHVlOiAwfSxcbiAgICAgIGFsaWduOiB7dmFsdWU6ICdyaWdodCd9LFxuICAgICAgYmFzZWxpbmU6IHt2YWx1ZTogJ21pZGRsZSd9LFxuICAgICAgZHk6IHt2YWx1ZTogKC1sYXlvdXQuaGVpZ2h0LzIpIC0yMH1cbiAgICB9KTtcbiAgfVxuXG4gIGRlZi50aXRsZU9mZnNldCA9IGF4aXNUaXRsZU9mZnNldChlbmNvZGluZywgbGF5b3V0LCBuYW1lKTtcbiAgcmV0dXJuIGRlZjtcbn1cblxuZnVuY3Rpb24gYXhpc19sYWJlbHMoZGVmLCBuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBvcHQpIHtcbiAgdmFyIGZuO1xuICAvLyBhZGQgY3VzdG9tIGxhYmVsIGZvciB0aW1lIHR5cGVcbiAgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSAmJiAoZm4gPSBlbmNvZGluZy5mbihuYW1lKSkgJiYgKHRpbWUuaGFzU2NhbGUoZm4pKSkge1xuICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscycsJ3RleHQnLCdzY2FsZSddLCAndGltZS0nKyBmbik7XG4gIH1cblxuICB2YXIgdGV4dFRlbXBsYXRlUGF0aCA9IFsncHJvcGVydGllcycsJ2xhYmVscycsJ3RleHQnLCd0ZW1wbGF0ZSddO1xuICBpZiAoZW5jb2RpbmcuYXhpcyhuYW1lKS5mb3JtYXQpIHtcbiAgICBkZWYuZm9ybWF0ID0gZW5jb2RpbmcuYXhpcyhuYW1lKS5mb3JtYXQ7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFEpKSB7XG4gICAgc2V0dGVyKGRlZiwgdGV4dFRlbXBsYXRlUGF0aCwgXCJ7e2RhdGEgfCBudW1iZXI6Jy4zcyd9fVwiKTtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkgJiYgIWVuY29kaW5nLmZuKG5hbWUpKSB7XG4gICAgc2V0dGVyKGRlZiwgdGV4dFRlbXBsYXRlUGF0aCwgXCJ7e2RhdGEgfCB0aW1lOiclWS0lbS0lZCd9fVwiKTtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkgJiYgZW5jb2RpbmcuZm4obmFtZSkgPT09ICd5ZWFyJykge1xuICAgIHNldHRlcihkZWYsIHRleHRUZW1wbGF0ZVBhdGgsIFwie3tkYXRhIHwgbnVtYmVyOidkJ319XCIpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBPKSAmJiBlbmNvZGluZy5heGlzKG5hbWUpLm1heExhYmVsTGVuZ3RoKSB7XG4gICAgc2V0dGVyKGRlZiwgdGV4dFRlbXBsYXRlUGF0aCwgJ3t7ZGF0YSB8IHRydW5jYXRlOicgKyBlbmNvZGluZy5heGlzKG5hbWUpLm1heExhYmVsTGVuZ3RoICsgJ319Jyk7XG4gIH1cblxuICByZXR1cm4gZGVmO1xufVxuXG5mdW5jdGlvbiBheGlzVGl0bGVPZmZzZXQoZW5jb2RpbmcsIGxheW91dCwgbmFtZSkge1xuICB2YXIgdmFsdWUgPSBlbmNvZGluZy5heGlzKG5hbWUpLnRpdGxlT2Zmc2V0O1xuICBpZiAodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgc3dpdGNoIChuYW1lKSB7XG4gICAgY2FzZSBST1c6IHJldHVybiAwO1xuICAgIGNhc2UgQ09MOiByZXR1cm4gMzU7XG4gIH1cbiAgcmV0dXJuIGdldHRlcihsYXlvdXQsIFtuYW1lLCAnYXhpc1RpdGxlT2Zmc2V0J10pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBiaW5uaW5nO1xuXG5mdW5jdGlvbiBiaW5uaW5nKHNwZWMsIGVuY29kaW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICB2YXIgYmlucyA9IHt9O1xuXG4gIGlmIChvcHQucHJlYWdncmVnYXRlZERhdGEpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoIXNwZWMudHJhbnNmb3JtKSBzcGVjLnRyYW5zZm9ybSA9IFtdO1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jb2RpbmcuYmluKGVuY1R5cGUpKSB7XG4gICAgICBzcGVjLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2JpbicsXG4gICAgICAgIGZpZWxkOiAnZGF0YS4nICsgZmllbGQubmFtZSxcbiAgICAgICAgb3V0cHV0OiAnZGF0YS5iaW5fJyArIGZpZWxkLm5hbWUsXG4gICAgICAgIG1heGJpbnM6IGVuY29kaW5nLmJpbihlbmNUeXBlKS5tYXhiaW5zXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBjb21waWxlO1xuXG52YXIgRW5jb2RpbmcgPSByZXF1aXJlKCcuLi9FbmNvZGluZycpLFxuICBheGlzID0gY29tcGlsZS5heGlzID0gcmVxdWlyZSgnLi9heGlzJyksXG4gIGZpbHRlciA9IGNvbXBpbGUuZmlsdGVyID0gcmVxdWlyZSgnLi9maWx0ZXInKSxcbiAgbGVnZW5kID0gY29tcGlsZS5sZWdlbmQgPSByZXF1aXJlKCcuL2xlZ2VuZCcpLFxuICBtYXJrcyA9IGNvbXBpbGUubWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyksXG4gIHNjYWxlID0gY29tcGlsZS5zY2FsZSA9IHJlcXVpcmUoJy4vc2NhbGUnKTtcblxuY29tcGlsZS5hZ2dyZWdhdGUgPSByZXF1aXJlKCcuL2FnZ3JlZ2F0ZScpO1xuY29tcGlsZS5iaW4gPSByZXF1aXJlKCcuL2JpbicpO1xuY29tcGlsZS5mYWNldCA9IHJlcXVpcmUoJy4vZmFjZXQnKTtcbmNvbXBpbGUuZ3JvdXAgPSByZXF1aXJlKCcuL2dyb3VwJyk7XG5jb21waWxlLmxheW91dCA9IHJlcXVpcmUoJy4vbGF5b3V0Jyk7XG5jb21waWxlLnNvcnQgPSByZXF1aXJlKCcuL3NvcnQnKTtcbmNvbXBpbGUuc3RhY2sgPSByZXF1aXJlKCcuL3N0YWNrJyk7XG5jb21waWxlLnN0eWxlID0gcmVxdWlyZSgnLi9zdHlsZScpO1xuY29tcGlsZS5zdWJmYWNldCA9IHJlcXVpcmUoJy4vc3ViZmFjZXQnKTtcbmNvbXBpbGUudGVtcGxhdGUgPSByZXF1aXJlKCcuL3RlbXBsYXRlJyk7XG5jb21waWxlLnRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxuZnVuY3Rpb24gY29tcGlsZShzcGVjLCBzdGF0cywgdGhlbWUpIHtcbiAgcmV0dXJuIGNvbXBpbGUuZW5jb2RpbmcoRW5jb2RpbmcuZnJvbVNwZWMoc3BlYywgdGhlbWUpLCBzdGF0cyk7XG59XG5cbmNvbXBpbGUuc2hvcnRoYW5kID0gZnVuY3Rpb24gKHNob3J0aGFuZCwgc3RhdHMsIGNvbmZpZywgdGhlbWUpIHtcbiAgcmV0dXJuIGNvbXBpbGUuZW5jb2RpbmcoRW5jb2RpbmcuZnJvbVNob3J0aGFuZChzaG9ydGhhbmQsIGNvbmZpZywgdGhlbWUpLCBzdGF0cyk7XG59O1xuXG5jb21waWxlLmVuY29kaW5nID0gZnVuY3Rpb24gKGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgbGF5b3V0ID0gY29tcGlsZS5sYXlvdXQoZW5jb2RpbmcsIHN0YXRzKSxcbiAgICBzdHlsZSA9IGNvbXBpbGUuc3R5bGUoZW5jb2RpbmcsIHN0YXRzKSxcbiAgICBzcGVjID0gY29tcGlsZS50ZW1wbGF0ZShlbmNvZGluZywgbGF5b3V0LCBzdGF0cyksXG4gICAgZ3JvdXAgPSBzcGVjLm1hcmtzWzBdLFxuICAgIG1hcmsgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXSxcbiAgICBtZGVmcyA9IG1hcmtzLmRlZihtYXJrLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSksXG4gICAgbWRlZiA9IG1kZWZzWzBdOyAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgZGlydHkgaGFjayBieSByZWZhY3RvcmluZyB0aGUgd2hvbGUgZmxvd1xuXG4gIGZpbHRlci5hZGRGaWx0ZXJzKHNwZWMsIGVuY29kaW5nKTtcbiAgdmFyIHNvcnRpbmcgPSBjb21waWxlLnNvcnQoc3BlYywgZW5jb2RpbmcsIHN0YXRzKTtcblxuICB2YXIgaGFzUm93ID0gZW5jb2RpbmcuaGFzKFJPVyksIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpO1xuXG4gIHZhciBwcmVhZ2dyZWdhdGVkRGF0YSA9ICEhZW5jb2RpbmcuZGF0YSgndmVnYVNlcnZlcicpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWRlZnMubGVuZ3RoOyBpKyspIHtcbiAgICBncm91cC5tYXJrcy5wdXNoKG1kZWZzW2ldKTtcbiAgfVxuXG4gIGNvbXBpbGUuYmluKHNwZWMuZGF0YVsxXSwgZW5jb2RpbmcsIHtwcmVhZ2dyZWdhdGVkRGF0YTogcHJlYWdncmVnYXRlZERhdGF9KTtcblxuICB2YXIgbGluZVR5cGUgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5saW5lO1xuXG4gIGlmICghcHJlYWdncmVnYXRlZERhdGEpIHtcbiAgICBzcGVjID0gY29tcGlsZS50aW1lKHNwZWMsIGVuY29kaW5nKTtcbiAgfVxuXG4gIC8vIGhhbmRsZSBzdWJmYWNldHNcbiAgdmFyIGFnZ1Jlc3VsdCA9IGNvbXBpbGUuYWdncmVnYXRlKHNwZWMsIGVuY29kaW5nLCB7cHJlYWdncmVnYXRlZERhdGE6IHByZWFnZ3JlZ2F0ZWREYXRhfSksXG4gICAgZGV0YWlscyA9IGFnZ1Jlc3VsdC5kZXRhaWxzLFxuICAgIGhhc0RldGFpbHMgPSBkZXRhaWxzICYmIGRldGFpbHMubGVuZ3RoID4gMCxcbiAgICBzdGFjayA9IGhhc0RldGFpbHMgJiYgY29tcGlsZS5zdGFjayhzcGVjLCBlbmNvZGluZywgbWRlZiwgYWdnUmVzdWx0LmZhY2V0cyk7XG5cbiAgaWYgKGhhc0RldGFpbHMgJiYgKHN0YWNrIHx8IGxpbmVUeXBlKSkge1xuICAgIC8vc3ViZmFjZXQgdG8gZ3JvdXAgc3RhY2sgLyBsaW5lIHRvZ2V0aGVyIGluIG9uZSBncm91cFxuICAgIGNvbXBpbGUuc3ViZmFjZXQoZ3JvdXAsIG1kZWYsIGRldGFpbHMsIHN0YWNrLCBlbmNvZGluZyk7XG4gIH1cblxuICAvLyBhdXRvLXNvcnQgbGluZS9hcmVhIHZhbHVlc1xuICAvL1RPRE8oa2FuaXR3KTogaGF2ZSBzb21lIGNvbmZpZyB0byB0dXJuIG9mZiBhdXRvLXNvcnQgZm9yIGxpbmUgKGZvciBsaW5lIGNoYXJ0IHRoYXQgZW5jb2RlcyB0ZW1wb3JhbCBpbmZvcm1hdGlvbilcbiAgaWYgKGxpbmVUeXBlKSB7XG4gICAgdmFyIGYgPSAoZW5jb2RpbmcuaXNNZWFzdXJlKFgpICYmIGVuY29kaW5nLmlzRGltZW5zaW9uKFkpKSA/IFkgOiBYO1xuICAgIGlmICghbWRlZi5mcm9tKSBtZGVmLmZyb20gPSB7fTtcbiAgICAvLyBUT0RPOiB3aHkgLSA/XG4gICAgbWRlZi5mcm9tLnRyYW5zZm9ybSA9IFt7dHlwZTogJ3NvcnQnLCBieTogJy0nICsgZW5jb2RpbmcuZmllbGQoZil9XTtcbiAgfVxuXG4gIC8vIFNtYWxsIE11bHRpcGxlc1xuICBpZiAoaGFzUm93IHx8IGhhc0NvbCkge1xuICAgIHNwZWMgPSBjb21waWxlLmZhY2V0KGdyb3VwLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc29ydGluZywgc3BlYywgbWRlZiwgc3RhY2ssIHN0YXRzKTtcbiAgICBzcGVjLmxlZ2VuZHMgPSBsZWdlbmQuZGVmcyhlbmNvZGluZyk7XG4gIH0gZWxzZSB7XG4gICAgZ3JvdXAuc2NhbGVzID0gc2NhbGUuZGVmcyhzY2FsZS5uYW1lcyhtZGVmLnByb3BlcnRpZXMudXBkYXRlKSwgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIHNvcnRpbmcsXG4gICAgICB7c3RhY2s6IHN0YWNrLCBzdGF0czogc3RhdHN9KTtcbiAgICBncm91cC5heGVzID0gYXhpcy5kZWZzKGF4aXMubmFtZXMobWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZSksIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKTtcbiAgICBncm91cC5sZWdlbmRzID0gbGVnZW5kLmRlZnMoZW5jb2RpbmcpO1xuICB9XG5cbiAgZmlsdGVyLmZpbHRlckxlc3NUaGFuWmVybyhzcGVjLCBlbmNvZGluZyk7XG5cbiAgcmV0dXJuIHNwZWM7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgYXhpcyA9IHJlcXVpcmUoJy4vYXhpcycpLFxuICBncm91cGRlZiA9IHJlcXVpcmUoJy4vZ3JvdXAnKS5kZWYsXG4gIHNjYWxlID0gcmVxdWlyZSgnLi9zY2FsZScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZhY2V0aW5nO1xuXG5mdW5jdGlvbiBmYWNldGluZyhncm91cCwgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIHNvcnRpbmcsIHNwZWMsIG1kZWYsIHN0YWNrLCBzdGF0cykge1xuICB2YXIgZW50ZXIgPSBncm91cC5wcm9wZXJ0aWVzLmVudGVyO1xuICB2YXIgZmFjZXRLZXlzID0gW10sIGNlbGxBeGVzID0gW10sIGZyb20sIGF4ZXNHcnA7XG5cbiAgdmFyIGhhc1JvdyA9IGVuY29kaW5nLmhhcyhST1cpLCBoYXNDb2wgPSBlbmNvZGluZy5oYXMoQ09MKTtcblxuICBlbnRlci5maWxsID0ge3ZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxCYWNrZ3JvdW5kQ29sb3InKX07XG5cbiAgLy9tb3ZlIFwiZnJvbVwiIHRvIGNlbGwgbGV2ZWwgYW5kIGFkZCBmYWNldCB0cmFuc2Zvcm1cbiAgZ3JvdXAuZnJvbSA9IHtkYXRhOiBncm91cC5tYXJrc1swXS5mcm9tLmRhdGF9O1xuXG4gIC8vIEhhY2ssIHRoaXMgbmVlZHMgdG8gYmUgcmVmYWN0b3JlZFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLm1hcmtzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1hcmsgPSBncm91cC5tYXJrc1tpXTtcbiAgICBpZiAobWFyay5mcm9tLnRyYW5zZm9ybSkge1xuICAgICAgZGVsZXRlIG1hcmsuZnJvbS5kYXRhOyAvL25lZWQgdG8ga2VlcCB0cmFuc2Zvcm0gZm9yIHN1YmZhY2V0dGluZyBjYXNlXG4gICAgfSBlbHNlIHtcbiAgICAgIGRlbGV0ZSBtYXJrLmZyb207XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc1Jvdykge1xuICAgIGlmICghZW5jb2RpbmcuaXNEaW1lbnNpb24oUk9XKSkge1xuICAgICAgdXRpbC5lcnJvcignUm93IGVuY29kaW5nIHNob3VsZCBiZSBvcmRpbmFsLicpO1xuICAgIH1cbiAgICBlbnRlci55ID0ge3NjYWxlOiBST1csIGZpZWxkOiAna2V5cy4nICsgZmFjZXRLZXlzLmxlbmd0aH07XG4gICAgZW50ZXIuaGVpZ2h0ID0geyd2YWx1ZSc6IGxheW91dC5jZWxsSGVpZ2h0fTsgLy8gSEFDS1xuXG4gICAgZmFjZXRLZXlzLnB1c2goZW5jb2RpbmcuZmllbGQoUk9XKSk7XG5cbiAgICBpZiAoaGFzQ29sKSB7XG4gICAgICBmcm9tID0gdXRpbC5kdXBsaWNhdGUoZ3JvdXAuZnJvbSk7XG4gICAgICBmcm9tLnRyYW5zZm9ybSA9IGZyb20udHJhbnNmb3JtIHx8IFtdO1xuICAgICAgZnJvbS50cmFuc2Zvcm0udW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogW2VuY29kaW5nLmZpZWxkKENPTCldfSk7XG4gICAgfVxuXG4gICAgYXhlc0dycCA9IGdyb3VwZGVmKCd4LWF4ZXMnLCB7XG4gICAgICAgIGF4ZXM6IGVuY29kaW5nLmhhcyhYKSA/IGF4aXMuZGVmcyhbJ3gnXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpIDogdW5kZWZpbmVkLFxuICAgICAgICB4OiBoYXNDb2wgPyB7c2NhbGU6IENPTCwgZmllbGQ6ICdrZXlzLjAnfSA6IHt2YWx1ZTogMH0sXG4gICAgICAgIHdpZHRoOiBoYXNDb2wgJiYgeyd2YWx1ZSc6IGxheW91dC5jZWxsV2lkdGh9LCAvL0hBQ0s/XG4gICAgICAgIGZyb206IGZyb21cbiAgICAgIH0pO1xuXG4gICAgc3BlYy5tYXJrcy51bnNoaWZ0KGF4ZXNHcnApOyAvLyBuZWVkIHRvIHByZXBlbmQgc28gaXQgYXBwZWFycyB1bmRlciB0aGUgcGxvdHNcbiAgICAoc3BlYy5heGVzID0gc3BlYy5heGVzIHx8IFtdKTtcbiAgICBzcGVjLmF4ZXMucHVzaC5hcHBseShzcGVjLmF4ZXMsIGF4aXMuZGVmcyhbJ3JvdyddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICB9IGVsc2UgeyAvLyBkb2Vzbid0IGhhdmUgcm93XG4gICAgaWYgKGVuY29kaW5nLmhhcyhYKSkge1xuICAgICAgLy9rZWVwIHggYXhpcyBpbiB0aGUgY2VsbFxuICAgICAgY2VsbEF4ZXMucHVzaC5hcHBseShjZWxsQXhlcywgYXhpcy5kZWZzKFsneCddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChoYXNDb2wpIHtcbiAgICBpZiAoIWVuY29kaW5nLmlzRGltZW5zaW9uKENPTCkpIHtcbiAgICAgIHV0aWwuZXJyb3IoJ0NvbCBlbmNvZGluZyBzaG91bGQgYmUgb3JkaW5hbC4nKTtcbiAgICB9XG4gICAgZW50ZXIueCA9IHtzY2FsZTogQ09MLCBmaWVsZDogJ2tleXMuJyArIGZhY2V0S2V5cy5sZW5ndGh9O1xuICAgIGVudGVyLndpZHRoID0geyd2YWx1ZSc6IGxheW91dC5jZWxsV2lkdGh9OyAvLyBIQUNLXG5cbiAgICBmYWNldEtleXMucHVzaChlbmNvZGluZy5maWVsZChDT0wpKTtcblxuICAgIGlmIChoYXNSb3cpIHtcbiAgICAgIGZyb20gPSB1dGlsLmR1cGxpY2F0ZShncm91cC5mcm9tKTtcbiAgICAgIGZyb20udHJhbnNmb3JtID0gZnJvbS50cmFuc2Zvcm0gfHwgW107XG4gICAgICBmcm9tLnRyYW5zZm9ybS51bnNoaWZ0KHt0eXBlOiAnZmFjZXQnLCBrZXlzOiBbZW5jb2RpbmcuZmllbGQoUk9XKV19KTtcbiAgICB9XG5cbiAgICBheGVzR3JwID0gZ3JvdXBkZWYoJ3ktYXhlcycsIHtcbiAgICAgIGF4ZXM6IGVuY29kaW5nLmhhcyhZKSA/IGF4aXMuZGVmcyhbJ3knXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpIDogdW5kZWZpbmVkLFxuICAgICAgeTogaGFzUm93ICYmIHtzY2FsZTogUk9XLCBmaWVsZDogJ2tleXMuMCd9LFxuICAgICAgeDogaGFzUm93ICYmIHt2YWx1ZTogMH0sXG4gICAgICBoZWlnaHQ6IGhhc1JvdyAmJiB7J3ZhbHVlJzogbGF5b3V0LmNlbGxIZWlnaHR9LCAvL0hBQ0s/XG4gICAgICBmcm9tOiBmcm9tXG4gICAgfSk7XG5cbiAgICBzcGVjLm1hcmtzLnVuc2hpZnQoYXhlc0dycCk7IC8vIG5lZWQgdG8gcHJlcGVuZCBzbyBpdCBhcHBlYXJzIHVuZGVyIHRoZSBwbG90c1xuICAgIChzcGVjLmF4ZXMgPSBzcGVjLmF4ZXMgfHwgW10pO1xuICAgIHNwZWMuYXhlcy5wdXNoLmFwcGx5KHNwZWMuYXhlcywgYXhpcy5kZWZzKFsnY29sJ10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gIH0gZWxzZSB7IC8vIGRvZXNuJ3QgaGF2ZSBjb2xcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFkpKSB7XG4gICAgICBjZWxsQXhlcy5wdXNoLmFwcGx5KGNlbGxBeGVzLCBheGlzLmRlZnMoWyd5J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gICAgfVxuICB9XG5cbiAgLy8gYXNzdW1pbmcgZXF1YWwgY2VsbFdpZHRoIGhlcmVcbiAgLy8gVE9ETzogc3VwcG9ydCBoZXRlcm9nZW5vdXMgY2VsbFdpZHRoIChtYXliZSBieSB1c2luZyBtdWx0aXBsZSBzY2FsZXM/KVxuICBzcGVjLnNjYWxlcyA9IChzcGVjLnNjYWxlcyB8fCBbXSkuY29uY2F0KHNjYWxlLmRlZnMoXG4gICAgc2NhbGUubmFtZXMoZW50ZXIpLmNvbmNhdChzY2FsZS5uYW1lcyhtZGVmLnByb3BlcnRpZXMudXBkYXRlKSksXG4gICAgZW5jb2RpbmcsXG4gICAgbGF5b3V0LFxuICAgIHN0eWxlLFxuICAgIHNvcnRpbmcsXG4gICAge3N0YWNrOiBzdGFjaywgZmFjZXQ6IHRydWUsIHN0YXRzOiBzdGF0c31cbiAgKSk7IC8vIHJvdy9jb2wgc2NhbGVzICsgY2VsbCBzY2FsZXNcblxuICBpZiAoY2VsbEF4ZXMubGVuZ3RoID4gMCkge1xuICAgIGdyb3VwLmF4ZXMgPSBjZWxsQXhlcztcbiAgfVxuXG4gIC8vIGFkZCBmYWNldCB0cmFuc2Zvcm1cbiAgdmFyIHRyYW5zID0gKGdyb3VwLmZyb20udHJhbnNmb3JtIHx8IChncm91cC5mcm9tLnRyYW5zZm9ybSA9IFtdKSk7XG4gIHRyYW5zLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IGZhY2V0S2V5c30pO1xuXG4gIHJldHVybiBzcGVjO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGZpbHRlciA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZhciBCSU5BUlkgPSB7XG4gICc+JzogIHRydWUsXG4gICc+PSc6IHRydWUsXG4gICc9JzogIHRydWUsXG4gICchPSc6IHRydWUsXG4gICc8JzogIHRydWUsXG4gICc8PSc6IHRydWVcbn07XG5cbmZpbHRlci5hZGRGaWx0ZXJzID0gZnVuY3Rpb24oc3BlYywgZW5jb2RpbmcpIHtcbiAgdmFyIGZpbHRlcnMgPSBlbmNvZGluZy5maWx0ZXIoKSxcbiAgICBkYXRhID0gc3BlYy5kYXRhWzBdOyAgLy8gYXBwbHkgZmlsdGVycyB0byByYXcgZGF0YSBiZWZvcmUgYWdncmVnYXRpb25cblxuICBpZiAoIWRhdGEudHJhbnNmb3JtKVxuICAgIGRhdGEudHJhbnNmb3JtID0gW107XG5cbiAgLy8gYWRkIGN1c3RvbSBmaWx0ZXJzXG4gIGZvciAodmFyIGkgaW4gZmlsdGVycykge1xuICAgIHZhciBmaWx0ZXIgPSBmaWx0ZXJzW2ldO1xuXG4gICAgdmFyIGNvbmRpdGlvbiA9ICcnO1xuICAgIHZhciBvcGVyYXRvciA9IGZpbHRlci5vcGVyYXRvcjtcbiAgICB2YXIgb3BlcmFuZHMgPSBmaWx0ZXIub3BlcmFuZHM7XG5cbiAgICBpZiAoQklOQVJZW29wZXJhdG9yXSkge1xuICAgICAgLy8gZXhwZWN0cyBhIGZpZWxkIGFuZCBhIHZhbHVlXG4gICAgICBpZiAob3BlcmF0b3IgPT09ICc9Jykge1xuICAgICAgICBvcGVyYXRvciA9ICc9PSc7XG4gICAgICB9XG5cbiAgICAgIHZhciBvcDEgPSBvcGVyYW5kc1swXTtcbiAgICAgIHZhciBvcDIgPSBvcGVyYW5kc1sxXTtcbiAgICAgIGNvbmRpdGlvbiA9ICdkLmRhdGEuJyArIG9wMSArIG9wZXJhdG9yICsgb3AyO1xuICAgIH0gZWxzZSBpZiAob3BlcmF0b3IgPT09ICdub3ROdWxsJykge1xuICAgICAgLy8gZXhwZWN0cyBhIG51bWJlciBvZiBmaWVsZHNcbiAgICAgIGZvciAodmFyIGogaW4gb3BlcmFuZHMpIHtcbiAgICAgICAgY29uZGl0aW9uICs9ICdkLmRhdGEuJyArIG9wZXJhbmRzW2pdICsgJyE9PW51bGwnO1xuICAgICAgICBpZiAoaiA8IG9wZXJhbmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBjb25kaXRpb24gKz0gJyAmJiAnO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnNvbGUud2FybignVW5zdXBwb3J0ZWQgb3BlcmF0b3I6ICcsIG9wZXJhdG9yKTtcbiAgICB9XG5cbiAgICBkYXRhLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgIHR5cGU6ICdmaWx0ZXInLFxuICAgICAgdGVzdDogY29uZGl0aW9uXG4gICAgfSk7XG4gIH1cbn07XG5cbi8vIHJlbW92ZSBsZXNzIHRoYW4gMCB2YWx1ZXMgaWYgd2UgdXNlIGxvZyBmdW5jdGlvblxuZmlsdGVyLmZpbHRlckxlc3NUaGFuWmVybyA9IGZ1bmN0aW9uKHNwZWMsIGVuY29kaW5nKSB7XG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZW5jb2Rpbmcuc2NhbGUoZW5jVHlwZSkudHlwZSA9PT0gJ2xvZycpIHtcbiAgICAgIHNwZWMuZGF0YVsxXS50cmFuc2Zvcm0ucHVzaCh7XG4gICAgICAgIHR5cGU6ICdmaWx0ZXInLFxuICAgICAgICB0ZXN0OiAnZC4nICsgZW5jb2RpbmcuZmllbGQoZW5jVHlwZSkgKyAnPjAnXG4gICAgICB9KTtcbiAgICB9XG4gIH0pO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgZGVmOiBncm91cGRlZlxufTtcblxuZnVuY3Rpb24gZ3JvdXBkZWYobmFtZSwgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcbiAgcmV0dXJuIHtcbiAgICBfbmFtZTogbmFtZSB8fCB1bmRlZmluZWQsXG4gICAgdHlwZTogJ2dyb3VwJyxcbiAgICBmcm9tOiBvcHQuZnJvbSxcbiAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICBlbnRlcjoge1xuICAgICAgICB4OiBvcHQueCB8fCB1bmRlZmluZWQsXG4gICAgICAgIHk6IG9wdC55IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgd2lkdGg6IG9wdC53aWR0aCB8fCB7Z3JvdXA6ICd3aWR0aCd9LFxuICAgICAgICBoZWlnaHQ6IG9wdC5oZWlnaHQgfHwge2dyb3VwOiAnaGVpZ2h0J31cbiAgICAgIH1cbiAgICB9LFxuICAgIHNjYWxlczogb3B0LnNjYWxlcyB8fCB1bmRlZmluZWQsXG4gICAgYXhlczogb3B0LmF4ZXMgfHwgdW5kZWZpbmVkLFxuICAgIG1hcmtzOiBvcHQubWFya3MgfHwgW11cbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHNldHRlciA9IHV0aWwuc2V0dGVyLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuLi9zY2hlbWEvc2NoZW1hJyksXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKSxcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gdmxsYXlvdXQ7XG5cbmZ1bmN0aW9uIHZsbGF5b3V0KGVuY29kaW5nLCBzdGF0cykge1xuICB2YXIgbGF5b3V0ID0gYm94KGVuY29kaW5nLCBzdGF0cyk7XG4gIGxheW91dCA9IG9mZnNldChlbmNvZGluZywgc3RhdHMsIGxheW91dCk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG5cbi8qXG4gIEhBQ0sgdG8gc2V0IGNoYXJ0IHNpemVcbiAgTk9URTogdGhpcyBmYWlscyBmb3IgcGxvdHMgZHJpdmVuIGJ5IGRlcml2ZWQgdmFsdWVzIChlLmcuLCBhZ2dyZWdhdGVzKVxuICBPbmUgc29sdXRpb24gaXMgdG8gdXBkYXRlIFZlZ2EgdG8gc3VwcG9ydCBhdXRvLXNpemluZ1xuICBJbiB0aGUgbWVhbnRpbWUsIGF1dG8tcGFkZGluZyAobW9zdGx5KSBkb2VzIHRoZSB0cmlja1xuICovXG5mdW5jdGlvbiBib3goZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBoYXNSb3cgPSBlbmNvZGluZy5oYXMoUk9XKSxcbiAgICAgIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpLFxuICAgICAgaGFzWCA9IGVuY29kaW5nLmhhcyhYKSxcbiAgICAgIGhhc1kgPSBlbmNvZGluZy5oYXMoWSksXG4gICAgICBtYXJrdHlwZSA9IGVuY29kaW5nLm1hcmt0eXBlKCk7XG5cbiAgLy8gRklYTUUvSEFDSyB3ZSBuZWVkIHRvIHRha2UgZmlsdGVyIGludG8gYWNjb3VudFxuICB2YXIgeENhcmRpbmFsaXR5ID0gaGFzWCAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihYKSA/IGVuY29kaW5nLmNhcmRpbmFsaXR5KFgsIHN0YXRzKSA6IDEsXG4gICAgeUNhcmRpbmFsaXR5ID0gaGFzWSAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihZKSA/IGVuY29kaW5nLmNhcmRpbmFsaXR5KFksIHN0YXRzKSA6IDE7XG5cbiAgdmFyIHVzZVNtYWxsQmFuZCA9IHhDYXJkaW5hbGl0eSA+IGVuY29kaW5nLmNvbmZpZygnbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHknKSB8fFxuICAgIHlDYXJkaW5hbGl0eSA+IGVuY29kaW5nLmNvbmZpZygnbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHknKTtcblxuICB2YXIgY2VsbFdpZHRoLCBjZWxsSGVpZ2h0LCBjZWxsUGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZygnY2VsbFBhZGRpbmcnKTtcblxuICAvLyBzZXQgY2VsbFdpZHRoXG4gIGlmIChoYXNYKSB7XG4gICAgaWYgKGVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKFgpKSB7XG4gICAgICAvLyBmb3Igb3JkaW5hbCwgaGFzQ29sIG9yIG5vdCBkb2Vzbid0IG1hdHRlciAtLSB3ZSBzY2FsZSBiYXNlZCBvbiBjYXJkaW5hbGl0eVxuICAgICAgY2VsbFdpZHRoID0gKHhDYXJkaW5hbGl0eSArIGVuY29kaW5nLmJhbmQoWCkucGFkZGluZykgKiBlbmNvZGluZy5iYW5kU2l6ZShYLCB1c2VTbWFsbEJhbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsV2lkdGggPSBoYXNDb2wgfHwgaGFzUm93ID8gZW5jb2RpbmcuZW5jKENPTCkud2lkdGggOiAgZW5jb2RpbmcuY29uZmlnKFwic2luZ2xlV2lkdGhcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChtYXJrdHlwZSA9PT0gVEVYVCkge1xuICAgICAgY2VsbFdpZHRoID0gZW5jb2RpbmcuY29uZmlnKCd0ZXh0Q2VsbFdpZHRoJyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGxXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFgpO1xuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBjZWxsSGVpZ2h0XG4gIGlmIChoYXNZKSB7XG4gICAgaWYgKGVuY29kaW5nLmlzT3JkaW5hbFNjYWxlKFkpKSB7XG4gICAgICAvLyBmb3Igb3JkaW5hbCwgaGFzQ29sIG9yIG5vdCBkb2Vzbid0IG1hdHRlciAtLSB3ZSBzY2FsZSBiYXNlZCBvbiBjYXJkaW5hbGl0eVxuICAgICAgY2VsbEhlaWdodCA9ICh5Q2FyZGluYWxpdHkgKyBlbmNvZGluZy5iYW5kKFkpLnBhZGRpbmcpICogZW5jb2RpbmcuYmFuZFNpemUoWSwgdXNlU21hbGxCYW5kKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbEhlaWdodCA9IGhhc0NvbCB8fCBoYXNSb3cgPyBlbmNvZGluZy5lbmMoUk9XKS5oZWlnaHQgOiAgZW5jb2RpbmcuY29uZmlnKFwic2luZ2xlSGVpZ2h0XCIpO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBjZWxsSGVpZ2h0ID0gZW5jb2RpbmcuYmFuZFNpemUoWSk7XG4gIH1cblxuICAvLyBDZWxsIGJhbmRzIHVzZSByYW5nZUJhbmRzKCkuIFRoZXJlIGFyZSBuLTEgcGFkZGluZy4gIE91dGVycGFkZGluZyA9IDAgZm9yIGNlbGxzXG5cbiAgdmFyIHdpZHRoID0gY2VsbFdpZHRoLCBoZWlnaHQgPSBjZWxsSGVpZ2h0O1xuICBpZiAoaGFzQ29sKSB7XG4gICAgdmFyIGNvbENhcmRpbmFsaXR5ID0gZW5jb2RpbmcuY2FyZGluYWxpdHkoQ09MLCBzdGF0cyk7XG4gICAgd2lkdGggPSBjZWxsV2lkdGggKiAoKDEgKyBjZWxsUGFkZGluZykgKiAoY29sQ2FyZGluYWxpdHkgLSAxKSArIDEpO1xuICB9XG4gIGlmIChoYXNSb3cpIHtcbiAgICB2YXIgcm93Q2FyZGluYWxpdHkgPSAgZW5jb2RpbmcuY2FyZGluYWxpdHkoUk9XLCBzdGF0cyk7XG4gICAgaGVpZ2h0ID0gY2VsbEhlaWdodCAqICgoMSArIGNlbGxQYWRkaW5nKSAqIChyb3dDYXJkaW5hbGl0eSAtIDEpICsgMSk7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIHdob2xlIGNlbGxcbiAgICBjZWxsV2lkdGg6IGNlbGxXaWR0aCxcbiAgICBjZWxsSGVpZ2h0OiBjZWxsSGVpZ2h0LFxuICAgIGNlbGxQYWRkaW5nOiBjZWxsUGFkZGluZyxcbiAgICAvLyB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBjaGFydFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAvLyBpbmZvcm1hdGlvbiBhYm91dCB4IGFuZCB5LCBzdWNoIGFzIGJhbmQgc2l6ZVxuICAgIHg6IHt1c2VTbWFsbEJhbmQ6IHVzZVNtYWxsQmFuZH0sXG4gICAgeToge3VzZVNtYWxsQmFuZDogdXNlU21hbGxCYW5kfVxuICB9O1xufVxuXG5mdW5jdGlvbiBnZXRNYXhMZW5ndGgoZW5jb2RpbmcsIHN0YXRzLCBldCkge1xuICAvLyBGSVhNRSBkZXRlcm1pbmUgY29uc3RhbnQgZm9yIFEgYW5kIFQgaW4gYSBuaWNlciB3YXlcbiAgcmV0dXJuIGVuY29kaW5nLmlzVHlwZShldCwgUSkgPyAyMCA6XG4gICAgZW5jb2RpbmcuaXNUeXBlKGV0LCBUKSA/IDIwIDpcbiAgICBzdGF0c1tlbmNvZGluZy5maWVsZE5hbWUoZXQpXS5tYXg7XG59XG5cbmZ1bmN0aW9uIG9mZnNldChlbmNvZGluZywgc3RhdHMsIGxheW91dCkge1xuICBbWCwgWV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgIHZhciBtYXhMZW5ndGg7XG4gICAgaWYgKGVuY29kaW5nLmlzRGltZW5zaW9uKHgpIHx8IGVuY29kaW5nLmlzVHlwZSh4LCBUKSkge1xuICAgICAgbWF4TGVuZ3RoID0gIGdldE1heExlbmd0aChlbmNvZGluZywgc3RhdHMsIHgpO1xuICAgIH0gZWxzZSBpZiAoZW5jb2RpbmcuYWdncih4KSA9PT0gJ2NvdW50Jykge1xuICAgICAgLy9hc3NpZ24gZGVmYXVsdCB2YWx1ZSBmb3IgY291bnQgYXMgaXQgd29uJ3QgaGF2ZSBzdGF0c1xuICAgICAgbWF4TGVuZ3RoID0gIDM7XG4gICAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUoeCwgUSkpIHtcbiAgICAgIGlmICh4PT09WCkge1xuICAgICAgICBtYXhMZW5ndGggPSAzO1xuICAgICAgfSBlbHNlIHsgLy8gWVxuICAgICAgICAvL2Fzc3VtZSB0aGF0IGRlZmF1bHQgZm9ybWF0aW5nIGlzIGFsd2F5cyBzaG9ydGVyIHRoYW4gN1xuICAgICAgICBtYXhMZW5ndGggPSBNYXRoLm1pbihnZXRNYXhMZW5ndGgoZW5jb2RpbmcsIHN0YXRzLCB4KSwgNyk7XG4gICAgICB9XG4gICAgfVxuICAgIHNldHRlcihsYXlvdXQsW3gsICdheGlzVGl0bGVPZmZzZXQnXSwgZW5jb2RpbmcuY29uZmlnKCdjaGFyYWN0ZXJXaWR0aCcpICogIG1heExlbmd0aCArIDIwKTtcbiAgfSk7XG4gIHJldHVybiBsYXlvdXQ7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHRpbWUgPSByZXF1aXJlKCcuL3RpbWUnKTtcblxudmFyIGxlZ2VuZCA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmxlZ2VuZC5kZWZzID0gZnVuY3Rpb24oZW5jb2RpbmcpIHtcbiAgdmFyIGRlZnMgPSBbXTtcblxuICAvLyBUT0RPOiBzdXBwb3J0IGFscGhhXG5cbiAgaWYgKGVuY29kaW5nLmhhcyhDT0xPUikgJiYgZW5jb2RpbmcubGVnZW5kKENPTE9SKSkge1xuICAgIGRlZnMucHVzaChsZWdlbmQuZGVmKENPTE9SLCBlbmNvZGluZywge1xuICAgICAgZmlsbDogQ09MT1IsXG4gICAgICBvcmllbnQ6ICdyaWdodCdcbiAgICB9KSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuaGFzKFNJWkUpICYmIGVuY29kaW5nLmxlZ2VuZChTSVpFKSkge1xuICAgIGRlZnMucHVzaChsZWdlbmQuZGVmKFNJWkUsIGVuY29kaW5nLCB7XG4gICAgICBzaXplOiBTSVpFLFxuICAgICAgb3JpZW50OiBkZWZzLmxlbmd0aCA9PT0gMSA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB9KSk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuaGFzKFNIQVBFKSAmJiBlbmNvZGluZy5sZWdlbmQoU0hBUEUpKSB7XG4gICAgaWYgKGRlZnMubGVuZ3RoID09PSAyKSB7XG4gICAgICAvLyBUT0RPOiBmaXggdGhpc1xuICAgICAgY29uc29sZS5lcnJvcignVmVnYWxpdGUgY3VycmVudGx5IG9ubHkgc3VwcG9ydHMgdHdvIGxlZ2VuZHMnKTtcbiAgICAgIHJldHVybiBkZWZzO1xuICAgIH1cbiAgICBkZWZzLnB1c2gobGVnZW5kLmRlZihTSEFQRSwgZW5jb2RpbmcsIHtcbiAgICAgIHNoYXBlOiBTSEFQRSxcbiAgICAgIG9yaWVudDogZGVmcy5sZW5ndGggPT09IDEgPyAnbGVmdCcgOiAncmlnaHQnXG4gICAgfSkpO1xuICB9XG5cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5sZWdlbmQuZGVmID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIHByb3BzKSB7XG4gIHZhciBkZWYgPSBwcm9wcywgZm47XG5cbiAgZGVmLnRpdGxlID0gZW5jb2RpbmcuZmllbGRUaXRsZShuYW1lKTtcblxuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmIChmbiA9IGVuY29kaW5nLmZuKG5hbWUpKSAmJlxuICAgIHRpbWUuaGFzU2NhbGUoZm4pKSB7XG4gICAgdmFyIHByb3BlcnRpZXMgPSBkZWYucHJvcGVydGllcyA9IGRlZi5wcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgbGFiZWxzID0gcHJvcGVydGllcy5sYWJlbHMgPSBwcm9wZXJ0aWVzLmxhYmVscyB8fCB7fSxcbiAgICAgIHRleHQgPSBsYWJlbHMudGV4dCA9IGxhYmVscy50ZXh0IHx8IHt9O1xuXG4gICAgdGV4dC5zY2FsZSA9ICd0aW1lLScrIGZuO1xuICB9XG5cbiAgcmV0dXJuIGRlZjtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICB2bHNjYWxlID0gcmVxdWlyZSgnLi9zY2FsZScpO1xuXG52YXIgbWFya3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5tYXJrcy5kZWYgPSBmdW5jdGlvbihtYXJrLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSkge1xuICB2YXIgZGVmcyA9IFtdO1xuXG4gIC8vIHRvIGFkZCBhIGJhY2tncm91bmQgdG8gdGV4dCwgd2UgbmVlZCB0byBhZGQgaXQgYmVmb3JlIHRoZSB0ZXh0XG4gIGlmIChlbmNvZGluZy5tYXJrdHlwZSgpID09PSBURVhUICYmIGVuY29kaW5nLmhhcyhDT0xPUikpIHtcbiAgICB2YXIgYmcgPSB7XG4gICAgICB4OiB7dmFsdWU6IDB9LFxuICAgICAgeToge3ZhbHVlOiAwfSxcbiAgICAgIHgyOiB7dmFsdWU6IGxheW91dC5jZWxsV2lkdGh9LFxuICAgICAgeTI6IHt2YWx1ZTogbGF5b3V0LmNlbGxIZWlnaHR9LFxuICAgICAgZmlsbDoge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGVuY29kaW5nLmZpZWxkKENPTE9SKX1cbiAgICB9O1xuICAgIGRlZnMucHVzaCh7XG4gICAgICB0eXBlOiAncmVjdCcsXG4gICAgICBmcm9tOiB7ZGF0YTogVEFCTEV9LFxuICAgICAgcHJvcGVydGllczoge2VudGVyOiBiZywgdXBkYXRlOiBiZ31cbiAgICB9KTtcbiAgfVxuXG4gIC8vIGFkZCB0aGUgbWFyayBkZWYgZm9yIHRoZSBtYWluIHRoaW5nXG4gIHZhciBwID0gbWFyay5wcm9wKGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlKTtcbiAgZGVmcy5wdXNoKHtcbiAgICB0eXBlOiBtYXJrLnR5cGUsXG4gICAgZnJvbToge2RhdGE6IFRBQkxFfSxcbiAgICBwcm9wZXJ0aWVzOiB7ZW50ZXI6IHAsIHVwZGF0ZTogcH1cbiAgfSk7XG5cbiAgcmV0dXJuIGRlZnM7XG59O1xuXG5tYXJrcy5iYXIgPSB7XG4gIHR5cGU6ICdyZWN0JyxcbiAgc3RhY2s6IHRydWUsXG4gIHByb3A6IGJhcl9wcm9wcyxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd4JywgJ3knXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgc2l6ZTogMSwgY29sb3I6IDEsIGFscGhhOiAxfVxufTtcblxubWFya3MubGluZSA9IHtcbiAgdHlwZTogJ2xpbmUnLFxuICBsaW5lOiB0cnVlLFxuICBwcm9wOiBsaW5lX3Byb3BzLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3gnLCAneSddLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBjb2xvcjogMSwgYWxwaGE6IDEsIGRldGFpbDoxfVxufTtcblxubWFya3MuYXJlYSA9IHtcbiAgdHlwZTogJ2FyZWEnLFxuICBzdGFjazogdHJ1ZSxcbiAgbGluZTogdHJ1ZSxcbiAgcmVxdWlyZWRFbmNvZGluZzogWyd4JywgJ3knXSxcbiAgcHJvcDogYXJlYV9wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgY29sb3I6IDEsIGFscGhhOiAxfVxufTtcblxubWFya3MudGljayA9IHtcbiAgdHlwZTogJ3JlY3QnLFxuICBwcm9wOiB0aWNrX3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBjb2xvcjogMSwgYWxwaGE6IDEsIGRldGFpbDogMX1cbn07XG5cbm1hcmtzLmNpcmNsZSA9IHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHByb3A6IGZpbGxlZF9wb2ludF9wcm9wcygnY2lyY2xlJyksXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIHNpemU6IDEsIGNvbG9yOiAxLCBhbHBoYTogMSwgZGV0YWlsOiAxfVxufTtcblxubWFya3Muc3F1YXJlID0ge1xuICB0eXBlOiAnc3ltYm9sJyxcbiAgcHJvcDogZmlsbGVkX3BvaW50X3Byb3BzKCdzcXVhcmUnKSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IG1hcmtzLmNpcmNsZS5zdXBwb3J0ZWRFbmNvZGluZ1xufTtcblxubWFya3MucG9pbnQgPSB7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBwcm9wOiBwb2ludF9wcm9wcyxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgc2l6ZTogMSwgY29sb3I6IDEsIGFscGhhOiAxLCBzaGFwZTogMSwgZGV0YWlsOiAxfVxufTtcblxubWFya3MudGV4dCA9IHtcbiAgdHlwZTogJ3RleHQnLFxuICBwcm9wOiB0ZXh0X3Byb3BzLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3RleHQnXSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgc2l6ZTogMSwgY29sb3I6IDEsIGFscGhhOiAxLCB0ZXh0OiAxfVxufTtcblxuZnVuY3Rpb24gYmFyX3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmlzTWVhc3VyZShYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLngyID0ge3NjYWxlOiBYLCB2YWx1ZTogZS5zY2FsZShYKS50eXBlID09PSAnbG9nJyA/IDEgOiAwfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZS5oYXMoWCkpIHsgLy8gaXMgb3JkaW5hbFxuICAgIHAueGMgPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIHtcbiAgICAvLyBUT0RPIGFkZCBzaW5nbGUgYmFyIG9mZnNldFxuICAgIHAueGMgPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5pc01lYXN1cmUoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICBwLnkyID0ge3NjYWxlOiBZLCB2YWx1ZTogZS5zY2FsZShZKS50eXBlID09PSAnbG9nJyA/IDEgOiAwfTtcbiAgfSBlbHNlIGlmIChlLmhhcyhZKSkgeyAvLyBpcyBvcmRpbmFsXG4gICAgcC55YyA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8gYWRkIHNpbmdsZSBiYXIgb2Zmc2V0XG4gICAgcC55YyA9IHtncm91cDogJ2hlaWdodCd9O1xuICB9XG5cbiAgLy8gd2lkdGhcbiAgaWYgKCFlLmhhcyhYKSB8fCBlLmlzT3JkaW5hbFNjYWxlKFgpKSB7IC8vIG5vIFggb3IgWCBpcyBvcmRpbmFsXG4gICAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgICBwLndpZHRoID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAud2lkdGggPSB7XG4gICAgICAgIHZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCksXG4gICAgICAgIG9mZnNldDogLTFcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgeyAvLyBYIGlzIFF1YW50IG9yIFRpbWUgU2NhbGVcbiAgICBwLndpZHRoID0ge3ZhbHVlOiAyfTtcbiAgfVxuXG4gIC8vIGhlaWdodFxuICBpZiAoIWUuaGFzKFkpIHx8IGUuaXNPcmRpbmFsU2NhbGUoWSkpIHsgLy8gbm8gWSBvciBZIGlzIG9yZGluYWxcbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuaGVpZ2h0ID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAuaGVpZ2h0ID0ge1xuICAgICAgICB2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpLFxuICAgICAgICBvZmZzZXQ6IC0xXG4gICAgICB9O1xuICAgIH1cbiAgfSBlbHNlIHsgLy8gWSBpcyBRdWFudCBvciBUaW1lIFNjYWxlXG4gICAgcC5oZWlnaHQgPSB7dmFsdWU6IDJ9O1xuICB9XG5cbiAgLy8gZmlsbFxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9IGVsc2UgaWYgKGUudmFsdWUoQUxQSEEpICE9PSB1bmRlZmluZWQpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IGUudmFsdWUoQUxQSEEpfTtcbiAgfVxuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBwb2ludF9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8gc2l6ZVxuICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICBwLnNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoU0laRSkpIHtcbiAgICBwLnNpemUgPSB7dmFsdWU6IGUudmFsdWUoU0laRSl9O1xuICB9XG5cbiAgLy8gc2hhcGVcbiAgaWYgKGUuaGFzKFNIQVBFKSkge1xuICAgIHAuc2hhcGUgPSB7c2NhbGU6IFNIQVBFLCBmaWVsZDogZS5maWVsZChTSEFQRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSEFQRSkpIHtcbiAgICBwLnNoYXBlID0ge3ZhbHVlOiBlLnZhbHVlKFNIQVBFKX07XG4gIH1cblxuICAvLyBzdHJva2VcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuc3Ryb2tlID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9IGVsc2UgaWYgKGUudmFsdWUoQUxQSEEpICE9PSB1bmRlZmluZWQpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IGUudmFsdWUoQUxQSEEpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBzdHlsZS5vcGFjaXR5fTtcbiAgfVxuXG4gIHAuc3Ryb2tlV2lkdGggPSB7dmFsdWU6IGUuY29uZmlnKCdzdHJva2VXaWR0aCcpfTtcblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gbGluZV9wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9XG5cbiAgcC5zdHJva2VXaWR0aCA9IHt2YWx1ZTogZS5jb25maWcoJ3N0cm9rZVdpZHRoJyl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBhcmVhX3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmlzTWVhc3VyZShYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLngyID0ge3NjYWxlOiBYLCB2YWx1ZTogMH07XG4gICAgICBwLm9yaWVudCA9IHt2YWx1ZTogJ2hvcml6b250YWwnfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5pc01lYXN1cmUoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICBwLnkyID0ge3NjYWxlOiBZLCB2YWx1ZTogMH07XG4gIH0gZWxzZSBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIHtcbiAgICBwLnkgPSB7Z3JvdXA6ICdoZWlnaHQnfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3NjYWxlOiBDT0xPUiwgZmllbGQ6IGUuZmllbGQoQ09MT1IpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfSBlbHNlIGlmIChlLnZhbHVlKEFMUEhBKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBlLnZhbHVlKEFMUEhBKX07XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gdGlja19wcm9wcyhlLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBwID0ge307XG5cbiAgLy8geFxuICBpZiAoZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihYKSkge1xuICAgICAgcC54Lm9mZnNldCA9IC1lLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAzO1xuICAgIH1cbiAgfSBlbHNlIGlmICghZS5oYXMoWCkpIHtcbiAgICBwLnggPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICBpZiAoZS5pc0RpbWVuc2lvbihZKSkge1xuICAgICAgcC55Lm9mZnNldCA9IC1lLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAzO1xuICAgIH1cbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IDB9O1xuICB9XG5cbiAgLy8gd2lkdGhcbiAgaWYgKCFlLmhhcyhYKSB8fCBlLmlzRGltZW5zaW9uKFgpKSB7XG4gICAgcC53aWR0aCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMS41fTtcbiAgfSBlbHNlIHtcbiAgICBwLndpZHRoID0ge3ZhbHVlOiAxfTtcbiAgfVxuXG4gIC8vIGhlaWdodFxuICBpZiAoIWUuaGFzKFkpIHx8IGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICBwLmhlaWdodCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMS41fTtcbiAgfSBlbHNlIHtcbiAgICBwLmhlaWdodCA9IHt2YWx1ZTogMX07XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2Uge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IHN0eWxlLm9wYWNpdHl9O1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGZpbGxlZF9wb2ludF9wcm9wcyhzaGFwZSkge1xuICByZXR1cm4gZnVuY3Rpb24oZSwgbGF5b3V0LCBzdHlsZSkge1xuICAgIHZhciBwID0ge307XG5cbiAgICAvLyB4XG4gICAgaWYgKGUuaGFzKFgpKSB7XG4gICAgICBwLnggPSB7c2NhbGU6IFgsIGZpZWxkOiBlLmZpZWxkKFgpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgICAgcC54ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgICB9XG5cbiAgICAvLyB5XG4gICAgaWYgKGUuaGFzKFkpKSB7XG4gICAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgICAgcC55ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgICB9XG5cbiAgICAvLyBzaXplXG4gICAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgICBwLnNpemUgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgICAgcC5zaXplID0ge3ZhbHVlOiBlLnZhbHVlKFNJWkUpfTtcbiAgICB9XG5cbiAgICAvLyBzaGFwZVxuICAgIHAuc2hhcGUgPSB7dmFsdWU6IHNoYXBlfTtcblxuICAgIC8vIGZpbGxcbiAgICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gICAgfVxuXG4gICAgLy8gYWxwaGFcbiAgICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICAgIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBlLnZhbHVlKEFMUEhBKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IHN0eWxlLm9wYWNpdHl9O1xuICAgIH1cblxuICAgIHJldHVybiBwO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0ZXh0X3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIGlmIChlLmhhcyhURVhUKSAmJiBlLmlzVHlwZShURVhULCBRKSkge1xuICAgICAgcC54ID0ge3ZhbHVlOiBsYXlvdXQuY2VsbFdpZHRoLTV9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDJ9O1xuICAgIH1cbiAgfVxuXG4gIC8vIHlcbiAgaWYgKGUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZChZKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgcC55ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAyfTtcbiAgfVxuXG4gIC8vIHNpemVcbiAgaWYgKGUuaGFzKFNJWkUpKSB7XG4gICAgcC5mb250U2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGQoU0laRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSVpFKSkge1xuICAgIHAuZm9udFNpemUgPSB7dmFsdWU6IGUuZm9udCgnc2l6ZScpfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgLy8gY29sb3Igc2hvdWxkIGJlIHNldCB0byBiYWNrZ3JvdW5kXG4gIHAuZmlsbCA9IHt2YWx1ZTogJ2JsYWNrJ307XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9IGVsc2Uge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogc3R5bGUub3BhY2l0eX07XG4gIH1cblxuICAvLyB0ZXh0XG4gIGlmIChlLmhhcyhURVhUKSkge1xuICAgIGlmIChlLmlzVHlwZShURVhULCBRKSkge1xuICAgICAgcC50ZXh0ID0ge3RlbXBsYXRlOiBcInt7XCIgKyBlLmZpZWxkKFRFWFQpICsgXCIgfCBudW1iZXI6Jy4zcyd9fVwifTtcbiAgICAgIHAuYWxpZ24gPSB7dmFsdWU6ICdyaWdodCd9O1xuICAgIH0gZWxzZSB7XG4gICAgICBwLnRleHQgPSB7ZmllbGQ6IGUuZmllbGQoVEVYVCl9O1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwLnRleHQgPSB7dmFsdWU6ICdBYmMnfTtcbiAgfVxuXG4gIHAuZm9udCA9IHt2YWx1ZTogZS5mb250KCdmYW1pbHknKX07XG4gIHAuZm9udFdlaWdodCA9IHt2YWx1ZTogZS5mb250KCd3ZWlnaHQnKX07XG4gIHAuZm9udFN0eWxlID0ge3ZhbHVlOiBlLmZvbnQoJ3N0eWxlJyl9O1xuICBwLmJhc2VsaW5lID0ge3ZhbHVlOiBlLnRleHQoJ2Jhc2VsaW5lJyl9O1xuXG4gIHJldHVybiBwO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG52YXIgc2NhbGUgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG5zY2FsZS5uYW1lcyA9IGZ1bmN0aW9uKHByb3BzKSB7XG4gIHJldHVybiB1dGlsLmtleXModXRpbC5rZXlzKHByb3BzKS5yZWR1Y2UoZnVuY3Rpb24oYSwgeCkge1xuICAgIGlmIChwcm9wc1t4XSAmJiBwcm9wc1t4XS5zY2FsZSkgYVtwcm9wc1t4XS5zY2FsZV0gPSAxO1xuICAgIHJldHVybiBhO1xuICB9LCB7fSkpO1xufTtcblxuc2NhbGUuZGVmcyA9IGZ1bmN0aW9uKG5hbWVzLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc29ydGluZywgb3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICByZXR1cm4gbmFtZXMucmVkdWNlKGZ1bmN0aW9uKGEsIG5hbWUpIHtcbiAgICB2YXIgcyA9IHtcbiAgICAgIG5hbWU6IG5hbWUsXG4gICAgICB0eXBlOiBzY2FsZS50eXBlKG5hbWUsIGVuY29kaW5nKSxcbiAgICAgIGRvbWFpbjogc2NhbGVfZG9tYWluKG5hbWUsIGVuY29kaW5nLCBzb3J0aW5nLCBvcHQpXG4gICAgfTtcbiAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcgJiYgIWVuY29kaW5nLmJpbihuYW1lKSAmJiBlbmNvZGluZy5zb3J0KG5hbWUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcy5zb3J0ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBzY2FsZV9yYW5nZShzLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgb3B0KTtcblxuICAgIHJldHVybiAoYS5wdXNoKHMpLCBhKTtcbiAgfSwgW10pO1xufTtcblxuc2NhbGUudHlwZSA9IGZ1bmN0aW9uKG5hbWUsIGVuY29kaW5nKSB7XG5cbiAgc3dpdGNoIChlbmNvZGluZy50eXBlKG5hbWUpKSB7XG4gICAgY2FzZSBPOiByZXR1cm4gJ29yZGluYWwnO1xuICAgIGNhc2UgVDpcbiAgICAgIHZhciBmbiA9IGVuY29kaW5nLmZuKG5hbWUpO1xuICAgICAgcmV0dXJuIChmbiAmJiB0aW1lLnNjYWxlLnR5cGUoZm4sIG5hbWUpKSB8fCAndGltZSc7XG4gICAgY2FzZSBROlxuICAgICAgaWYgKGVuY29kaW5nLmJpbihuYW1lKSkge1xuICAgICAgICByZXR1cm4gbmFtZSA9PT0gQ09MT1IgPyAnbGluZWFyJyA6ICdvcmRpbmFsJztcbiAgICAgIH1cbiAgICAgIHJldHVybiBlbmNvZGluZy5zY2FsZShuYW1lKS50eXBlO1xuICB9XG59O1xuXG5mdW5jdGlvbiBzY2FsZV9kb21haW4obmFtZSwgZW5jb2RpbmcsIHNvcnRpbmcsIG9wdCkge1xuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpKSB7XG4gICAgdmFyIHJhbmdlID0gdGltZS5zY2FsZS5kb21haW4oZW5jb2RpbmcuZm4obmFtZSksIG5hbWUpO1xuICAgIGlmKHJhbmdlKSByZXR1cm4gcmFuZ2U7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcuYmluKG5hbWUpKSB7XG4gICAgLy8gVE9ETzogYWRkIGluY2x1ZGVFbXB0eUNvbmZpZyBoZXJlXG4gICAgaWYgKG9wdC5zdGF0cykge1xuICAgICAgdmFyIGJpbnMgPSB1dGlsLmdldGJpbnMob3B0LnN0YXRzW2VuY29kaW5nLmZpZWxkTmFtZShuYW1lKV0sIGVuY29kaW5nLmJpbihuYW1lKS5tYXhiaW5zKTtcbiAgICAgIHZhciBkb21haW4gPSB1dGlsLnJhbmdlKGJpbnMuc3RhcnQsIGJpbnMuc3RvcCwgYmlucy5zdGVwKTtcbiAgICAgIHJldHVybiBuYW1lID09PSBZID8gZG9tYWluLnJldmVyc2UoKSA6IGRvbWFpbjtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbmFtZSA9PSBvcHQuc3RhY2sgP1xuICAgIHtcbiAgICAgIGRhdGE6IFNUQUNLRUQsXG4gICAgICBmaWVsZDogJ2RhdGEuJyArIChvcHQuZmFjZXQgPyAnbWF4XycgOiAnJykgKyAnc3VtXycgKyBlbmNvZGluZy5maWVsZChuYW1lLCB0cnVlKVxuICAgIH0gOlxuICAgIHtkYXRhOiBzb3J0aW5nLmdldERhdGFzZXQobmFtZSksIGZpZWxkOiBlbmNvZGluZy5maWVsZChuYW1lKX07XG59XG5cbmZ1bmN0aW9uIHNjYWxlX3JhbmdlKHMsIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBvcHQpIHtcbiAgdmFyIHNwZWMgPSBlbmNvZGluZy5zY2FsZShzLm5hbWUpO1xuICBzd2l0Y2ggKHMubmFtZSkge1xuICAgIGNhc2UgWDpcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICBzLmJhbmRXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFgsIGxheW91dC54LnVzZVNtYWxsQmFuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnJhbmdlID0gbGF5b3V0LmNlbGxXaWR0aCA/IFswLCBsYXlvdXQuY2VsbFdpZHRoXSA6ICd3aWR0aCc7XG5cbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgZW5jb2RpbmcuZm4ocy5uYW1lKSA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBpZiAocy50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgcy5uaWNlID0gZW5jb2RpbmcuZm4ocy5uYW1lKTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWTpcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICBzLmJhbmRXaWR0aCA9IGVuY29kaW5nLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzLnJhbmdlID0gbGF5b3V0LmNlbGxIZWlnaHQgPyBbbGF5b3V0LmNlbGxIZWlnaHQsIDBdIDogJ2hlaWdodCc7XG5cbiAgICAgICAgaWYgKGVuY29kaW5nLmlzVHlwZShzLm5hbWUsVCkgJiYgZW5jb2RpbmcuZm4ocy5uYW1lKSA9PT0gJ3llYXInKSB7XG4gICAgICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcy56ZXJvID0gc3BlYy56ZXJvID09PSB1bmRlZmluZWQgPyB0cnVlIDogc3BlYy56ZXJvO1xuICAgICAgICB9XG5cbiAgICAgICAgcy5yZXZlcnNlID0gc3BlYy5yZXZlcnNlO1xuICAgICAgfVxuXG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcblxuICAgICAgaWYgKHMudHlwZSA9PT0gJ3RpbWUnKSB7XG4gICAgICAgIHMubmljZSA9IGVuY29kaW5nLmZuKHMubmFtZSkgfHwgZW5jb2RpbmcuY29uZmlnKCd0aW1lU2NhbGVOaWNlJyk7XG4gICAgICB9ZWxzZSB7XG4gICAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICBjYXNlIFJPVzogLy8gc3VwcG9ydCBvbmx5IG9yZGluYWxcbiAgICAgIHMuYmFuZFdpZHRoID0gbGF5b3V0LmNlbGxIZWlnaHQ7XG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcbiAgICAgIHMubmljZSA9IHRydWU7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENPTDogLy8gc3VwcG9ydCBvbmx5IG9yZGluYWxcbiAgICAgIHMuYmFuZFdpZHRoID0gbGF5b3V0LmNlbGxXaWR0aDtcbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0laRTpcbiAgICAgIGlmIChlbmNvZGluZy5pcygnYmFyJykpIHtcbiAgICAgICAgLy8gRklYTUUgdGhpcyBpcyBkZWZpbml0ZWx5IGluY29ycmVjdFxuICAgICAgICAvLyBidXQgbGV0J3MgZml4IGl0IGxhdGVyIHNpbmNlIGJhciBzaXplIGlzIGEgYmFkIGVuY29kaW5nIGFueXdheVxuICAgICAgICBzLnJhbmdlID0gWzMsIE1hdGgubWF4KGVuY29kaW5nLmJhbmRTaXplKFgpLCBlbmNvZGluZy5iYW5kU2l6ZShZKSldO1xuICAgICAgfSBlbHNlIGlmIChlbmNvZGluZy5pcyhURVhUKSkge1xuICAgICAgICBzLnJhbmdlID0gWzgsIDQwXTtcbiAgICAgIH0gZWxzZSB7IC8vcG9pbnRcbiAgICAgICAgdmFyIGJhbmRTaXplID0gTWF0aC5taW4oZW5jb2RpbmcuYmFuZFNpemUoWCksIGVuY29kaW5nLmJhbmRTaXplKFkpKSAtIDE7XG4gICAgICAgIHMucmFuZ2UgPSBbMTAsIDAuOCAqIGJhbmRTaXplKmJhbmRTaXplXTtcbiAgICAgIH1cbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy56ZXJvID0gZmFsc2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFNIQVBFOlxuICAgICAgcy5yYW5nZSA9ICdzaGFwZXMnO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBDT0xPUjpcbiAgICAgIHZhciByYW5nZSA9IGVuY29kaW5nLnNjYWxlKENPTE9SKS5yYW5nZTtcbiAgICAgIGlmIChyYW5nZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykge1xuICAgICAgICAgIC8vIEZJWE1FXG4gICAgICAgICAgcmFuZ2UgPSBzdHlsZS5jb2xvclJhbmdlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJhbmdlID0gWycjQTlEQjlGJywgJyMwRDVDMjEnXTtcbiAgICAgICAgICBzLnplcm8gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcy5yYW5nZSA9IHJhbmdlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBBTFBIQTpcbiAgICAgIHMucmFuZ2UgPSBbMC4yLCAxLjBdO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZyBuYW1lOiAnKyBzLm5hbWUpO1xuICB9XG5cbiAgc3dpdGNoIChzLm5hbWUpIHtcbiAgICBjYXNlIFJPVzpcbiAgICBjYXNlIENPTDpcbiAgICAgIHMucGFkZGluZyA9IGVuY29kaW5nLmNvbmZpZygnY2VsbFBhZGRpbmcnKTtcbiAgICAgIHMub3V0ZXJQYWRkaW5nID0gMDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgWDpcbiAgICBjYXNlIFk6XG4gICAgICBpZiAocy50eXBlID09PSAnb3JkaW5hbCcpIHsgLy8mJiAhcy5iYW5kV2lkdGhcbiAgICAgICAgcy5wb2ludHMgPSB0cnVlO1xuICAgICAgICBzLnBhZGRpbmcgPSBlbmNvZGluZy5iYW5kKHMubmFtZSkucGFkZGluZztcbiAgICAgIH1cbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBhZGRTb3J0VHJhbnNmb3JtcztcblxuLy8gYWRkcyBuZXcgdHJhbnNmb3JtcyB0aGF0IHByb2R1Y2Ugc29ydGVkIGZpZWxkc1xuZnVuY3Rpb24gYWRkU29ydFRyYW5zZm9ybXMoc3BlYywgZW5jb2RpbmcsIHN0YXRzLCBvcHQpIHtcbiAgdmFyIGRhdGFzZXRNYXBwaW5nID0ge307XG4gIHZhciBjb3VudGVyID0gMDtcblxuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgdmFyIHNvcnRCeSA9IGVuY29kaW5nLnNvcnQoZW5jVHlwZSwgc3RhdHMpO1xuICAgIGlmIChzb3J0QnkubGVuZ3RoID4gMCkge1xuICAgICAgdmFyIGZpZWxkcyA9IHNvcnRCeS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIG9wOiBkLmFnZ3IsXG4gICAgICAgICAgZmllbGQ6ICdkYXRhLicgKyBkLm5hbWVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgYnlDbGF1c2UgPSBzb3J0QnkubWFwKGZ1bmN0aW9uKGQpIHtcbiAgICAgICAgdmFyIHJldmVyc2UgPSAoZC5yZXZlcnNlID8gJy0nIDogJycpO1xuICAgICAgICByZXR1cm4gcmV2ZXJzZSArICdkYXRhLicgKyAoZC5hZ2dyPT09J2NvdW50JyA/ICdjb3VudCcgOiAoZC5hZ2dyICsgJ18nICsgZC5uYW1lKSk7XG4gICAgICB9KTtcblxuICAgICAgdmFyIGRhdGFOYW1lID0gJ3NvcnRlZCcgKyBjb3VudGVyKys7XG5cbiAgICAgIHZhciB0cmFuc2Zvcm1zID0gW1xuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICAgICAgZ3JvdXBieTogWydkYXRhLicgKyBmaWVsZC5uYW1lXSxcbiAgICAgICAgICBmaWVsZHM6IGZpZWxkc1xuICAgICAgICB9LFxuICAgICAgICB7XG4gICAgICAgICAgdHlwZTogJ3NvcnQnLFxuICAgICAgICAgIGJ5OiBieUNsYXVzZVxuICAgICAgICB9XG4gICAgICBdO1xuXG4gICAgICBzcGVjLmRhdGEucHVzaCh7XG4gICAgICAgIG5hbWU6IGRhdGFOYW1lLFxuICAgICAgICBzb3VyY2U6IFJBVyxcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2Zvcm1zXG4gICAgICB9KTtcblxuICAgICAgZGF0YXNldE1hcHBpbmdbZW5jVHlwZV0gPSBkYXRhTmFtZTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgc3BlYzogc3BlYyxcbiAgICBnZXREYXRhc2V0OiBmdW5jdGlvbihlbmNUeXBlKSB7XG4gICAgICB2YXIgZGF0YSA9IGRhdGFzZXRNYXBwaW5nW2VuY1R5cGVdO1xuICAgICAgaWYgKCFkYXRhKSB7XG4gICAgICAgIHJldHVybiBUQUJMRTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgfTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgbWFya3MgPSByZXF1aXJlKCcuL21hcmtzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gc3RhY2tpbmc7XG5cbmZ1bmN0aW9uIHN0YWNraW5nKHNwZWMsIGVuY29kaW5nLCBtZGVmLCBmYWNldHMpIHtcbiAgaWYgKCFtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXS5zdGFjaykgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFRPRE86IGFkZCB8fCBlbmNvZGluZy5oYXMoTE9EKSBoZXJlIG9uY2UgTE9EIGlzIGltcGxlbWVudGVkXG4gIGlmICghZW5jb2RpbmcuaGFzKENPTE9SKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBkaW09bnVsbCwgdmFsPW51bGwsIGlkeCA9bnVsbCxcbiAgICBpc1hNZWFzdXJlID0gZW5jb2RpbmcuaXNNZWFzdXJlKFgpLFxuICAgIGlzWU1lYXN1cmUgPSBlbmNvZGluZy5pc01lYXN1cmUoWSk7XG5cbiAgaWYgKGlzWE1lYXN1cmUgJiYgIWlzWU1lYXN1cmUpIHtcbiAgICBkaW0gPSBZO1xuICAgIHZhbCA9IFg7XG4gICAgaWR4ID0gMDtcbiAgfSBlbHNlIGlmIChpc1lNZWFzdXJlICYmICFpc1hNZWFzdXJlKSB7XG4gICAgZGltID0gWDtcbiAgICB2YWwgPSBZO1xuICAgIGlkeCA9IDE7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIG51bGw7IC8vIG5vIHN0YWNrIGVuY29kaW5nXG4gIH1cblxuICAvLyBhZGQgdHJhbnNmb3JtIHRvIGNvbXB1dGUgc3VtcyBmb3Igc2NhbGVcbiAgdmFyIHN0YWNrZWQgPSB7XG4gICAgbmFtZTogU1RBQ0tFRCxcbiAgICBzb3VyY2U6IFRBQkxFLFxuICAgIHRyYW5zZm9ybTogW3tcbiAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgZ3JvdXBieTogW2VuY29kaW5nLmZpZWxkKGRpbSldLmNvbmNhdChmYWNldHMpLCAvLyBkaW0gYW5kIG90aGVyIGZhY2V0c1xuICAgICAgZmllbGRzOiBbe29wOiAnc3VtJywgZmllbGQ6IGVuY29kaW5nLmZpZWxkKHZhbCl9XSAvLyBUT0RPIGNoZWNrIGlmIGZpZWxkIHdpdGggYWdnciBpcyBjb3JyZWN0P1xuICAgIH1dXG4gIH07XG5cbiAgaWYgKGZhY2V0cyAmJiBmYWNldHMubGVuZ3RoID4gMCkge1xuICAgIHN0YWNrZWQudHJhbnNmb3JtLnB1c2goeyAvL2NhbGN1bGF0ZSBtYXggZm9yIGVhY2ggZmFjZXRcbiAgICAgIHR5cGU6ICdhZ2dyZWdhdGUnLFxuICAgICAgZ3JvdXBieTogZmFjZXRzLFxuICAgICAgZmllbGRzOiBbe29wOiAnbWF4JywgZmllbGQ6ICdkYXRhLnN1bV8nICsgZW5jb2RpbmcuZmllbGQodmFsLCB0cnVlKX1dXG4gICAgfSk7XG4gIH1cblxuICBzcGVjLmRhdGEucHVzaChzdGFja2VkKTtcblxuICAvLyBhZGQgc3RhY2sgdHJhbnNmb3JtIHRvIG1hcmtcbiAgbWRlZi5mcm9tLnRyYW5zZm9ybSA9IFt7XG4gICAgdHlwZTogJ3N0YWNrJyxcbiAgICBwb2ludDogZW5jb2RpbmcuZmllbGQoZGltKSxcbiAgICBoZWlnaHQ6IGVuY29kaW5nLmZpZWxkKHZhbCksXG4gICAgb3V0cHV0OiB7eTE6IHZhbCwgeTA6IHZhbCArICcyJ31cbiAgfV07XG5cbiAgLy8gVE9ETzogVGhpcyBpcyBzdXBlciBoYWNrLWlzaCAtLSBjb25zb2xpZGF0ZSBpbnRvIG1vZHVsYXIgbWFyayBwcm9wZXJ0aWVzP1xuICBtZGVmLnByb3BlcnRpZXMudXBkYXRlW3ZhbF0gPSBtZGVmLnByb3BlcnRpZXMuZW50ZXJbdmFsXSA9IHtzY2FsZTogdmFsLCBmaWVsZDogdmFsfTtcbiAgbWRlZi5wcm9wZXJ0aWVzLnVwZGF0ZVt2YWwgKyAnMiddID0gbWRlZi5wcm9wZXJ0aWVzLmVudGVyW3ZhbCArICcyJ10gPSB7c2NhbGU6IHZhbCwgZmllbGQ6IHZhbCArICcyJ307XG5cbiAgcmV0dXJuIHZhbDsgLy9yZXR1cm4gc3RhY2sgZW5jb2Rpbmdcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHZsZmllbGQgPSByZXF1aXJlKCcuLi9maWVsZCcpLFxuICBFbmNvZGluZyA9IHJlcXVpcmUoJy4uL0VuY29kaW5nJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHJldHVybiB7XG4gICAgb3BhY2l0eTogZXN0aW1hdGVPcGFjaXR5KGVuY29kaW5nLCBzdGF0cyksXG4gICAgY29sb3JSYW5nZTogY29sb3JSYW5nZShlbmNvZGluZywgc3RhdHMpXG4gIH07XG59O1xuXG5mdW5jdGlvbiBjb2xvclJhbmdlKGVuY29kaW5nLCBzdGF0cyl7XG4gIGlmIChlbmNvZGluZy5oYXMoQ09MT1IpICYmIGVuY29kaW5nLmlzRGltZW5zaW9uKENPTE9SKSkge1xuICAgIHZhciBjYXJkaW5hbGl0eSA9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTE9SLCBzdGF0cyk7XG4gICAgaWYgKGNhcmRpbmFsaXR5IDw9IDEwKSB7XG4gICAgICByZXR1cm4gXCJjYXRlZ29yeTEwXCI7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBcImNhdGVnb3J5MjBcIjtcbiAgICB9XG4gICAgLy8gVE9ETyBjYW4gdmVnYSBpbnRlcnBvbGF0ZSByYW5nZSBmb3Igb3JkaW5hbCBzY2FsZT9cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cblxuZnVuY3Rpb24gZXN0aW1hdGVPcGFjaXR5KGVuY29kaW5nLHN0YXRzKSB7XG4gIGlmICghc3RhdHMpIHtcbiAgICByZXR1cm4gMTtcbiAgfVxuXG4gIHZhciBudW1Qb2ludHMgPSAwO1xuXG4gIGlmIChlbmNvZGluZy5pc0FnZ3JlZ2F0ZSgpKSB7IC8vIGFnZ3JlZ2F0ZSBwbG90XG4gICAgbnVtUG9pbnRzID0gMTtcblxuICAgIC8vICBnZXQgbnVtYmVyIG9mIHBvaW50cyBpbiBlYWNoIFwiY2VsbFwiXG4gICAgLy8gIGJ5IGNhbGN1bGF0aW5nIHByb2R1Y3Qgb2YgY2FyZGluYWxpdHlcbiAgICAvLyAgZm9yIGVhY2ggbm9uIGZhY2V0aW5nIGFuZCBub24tb3JkaW5hbCBYIC8gWSBmaWVsZHNcbiAgICAvLyAgbm90ZSB0aGF0IG9yZGluYWwgeCx5IGFyZSBub3QgaW5jbHVkZSBzaW5jZSB3ZSBjYW5cbiAgICAvLyAgY29uc2lkZXIgdGhhdCBvcmRpbmFsIHggYXJlIHN1YmRpdmlkaW5nIHRoZSBjZWxsIGludG8gc3ViY2VsbHMgYW55d2F5XG4gICAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuXG4gICAgICBpZiAoZW5jVHlwZSAhPT0gUk9XICYmIGVuY1R5cGUgIT09IENPTCAmJlxuICAgICAgICAgICEoKGVuY1R5cGUgPT09IFggfHwgZW5jVHlwZSA9PT0gWSkgJiZcbiAgICAgICAgICB2bGZpZWxkLmlzT3JkaW5hbFNjYWxlKGZpZWxkLCB0cnVlKSlcbiAgICAgICAgKSB7XG4gICAgICAgIG51bVBvaW50cyAqPSBlbmNvZGluZy5jYXJkaW5hbGl0eShlbmNUeXBlLCBzdGF0cyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgfSBlbHNlIHsgLy8gcmF3IHBsb3RcbiAgICBudW1Qb2ludHMgPSBzdGF0cy5jb3VudDtcblxuICAgIC8vIHNtYWxsIG11bHRpcGxlcyBkaXZpZGUgbnVtYmVyIG9mIHBvaW50c1xuICAgIHZhciBudW1NdWx0aXBsZXMgPSAxO1xuICAgIGlmIChlbmNvZGluZy5oYXMoUk9XKSkge1xuICAgICAgbnVtTXVsdGlwbGVzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KFJPVywgc3RhdHMpO1xuICAgIH1cbiAgICBpZiAoZW5jb2RpbmcuaGFzKENPTCkpIHtcbiAgICAgIG51bU11bHRpcGxlcyAqPSBlbmNvZGluZy5jYXJkaW5hbGl0eShDT0wsIHN0YXRzKTtcbiAgICB9XG4gICAgbnVtUG9pbnRzIC89IG51bU11bHRpcGxlcztcbiAgfVxuXG4gIHZhciBvcGFjaXR5ID0gMDtcbiAgaWYgKG51bVBvaW50cyA8IDIwKSB7XG4gICAgb3BhY2l0eSA9IDE7XG4gIH0gZWxzZSBpZiAobnVtUG9pbnRzIDwgMjAwKSB7XG4gICAgb3BhY2l0eSA9IDAuNztcbiAgfSBlbHNlIGlmIChudW1Qb2ludHMgPCAxMDAwIHx8IGVuY29kaW5nLmlzKCd0aWNrJykpIHtcbiAgICBvcGFjaXR5ID0gMC42O1xuICB9IGVsc2Uge1xuICAgIG9wYWNpdHkgPSAwLjM7XG4gIH1cblxuICByZXR1cm4gb3BhY2l0eTtcbn1cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFsID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgZ3JvdXBkZWYgPSByZXF1aXJlKCcuL2dyb3VwJykuZGVmO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHN1YmZhY2V0aW5nO1xuXG5mdW5jdGlvbiBzdWJmYWNldGluZyhncm91cCwgbWRlZiwgZGV0YWlscywgc3RhY2ssIGVuY29kaW5nKSB7XG4gIHZhciBtID0gZ3JvdXAubWFya3MsXG4gICAgZyA9IGdyb3VwZGVmKCdzdWJmYWNldCcsIHttYXJrczogbX0pO1xuXG4gIGdyb3VwLm1hcmtzID0gW2ddO1xuICBnLmZyb20gPSBtZGVmLmZyb207XG4gIGRlbGV0ZSBtZGVmLmZyb207XG5cbiAgLy9UT0RPIHRlc3QgTE9EIC0tIHdlIHNob3VsZCBzdXBwb3J0IHN0YWNrIC8gbGluZSB3aXRob3V0IGNvbG9yIChMT0QpIGZpZWxkXG4gIHZhciB0cmFucyA9IChnLmZyb20udHJhbnNmb3JtIHx8IChnLmZyb20udHJhbnNmb3JtID0gW10pKTtcbiAgdHJhbnMudW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogZGV0YWlsc30pO1xuXG4gIGlmIChzdGFjayAmJiBlbmNvZGluZy5oYXMoQ09MT1IpKSB7XG4gICAgdHJhbnMudW5zaGlmdCh7dHlwZTogJ3NvcnQnLCBieTogZW5jb2RpbmcuZmllbGQoQ09MT1IpfSk7XG4gIH1cbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBncm91cGRlZiA9IHJlcXVpcmUoJy4vZ3JvdXAnKS5kZWYsXG4gIHZsZGF0YSA9IHJlcXVpcmUoJy4uL2RhdGEnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0ZW1wbGF0ZTtcblxuZnVuY3Rpb24gdGVtcGxhdGUoZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpIHsgLy9oYWNrIHVzZSBzdGF0c1xuXG4gIHZhciBkYXRhID0ge25hbWU6IFJBVywgZm9ybWF0OiB7dHlwZTogZW5jb2RpbmcuZGF0YSgnZm9ybWF0VHlwZScpfX0sXG4gICAgdGFibGUgPSB7bmFtZTogVEFCTEUsIHNvdXJjZTogUkFXfSxcbiAgICBkYXRhVXJsID0gdmxkYXRhLmdldFVybChlbmNvZGluZywgc3RhdHMpO1xuICBpZiAoZGF0YVVybCkgZGF0YS51cmwgPSBkYXRhVXJsO1xuXG4gIHZhciBwcmVhZ2dyZWdhdGVkRGF0YSA9ICEhZW5jb2RpbmcuZGF0YSgndmVnYVNlcnZlcicpO1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgbmFtZTtcbiAgICBpZiAoZmllbGQudHlwZSA9PSBUKSB7XG4gICAgICBkYXRhLmZvcm1hdC5wYXJzZSA9IGRhdGEuZm9ybWF0LnBhcnNlIHx8IHt9O1xuICAgICAgZGF0YS5mb3JtYXQucGFyc2VbZmllbGQubmFtZV0gPSAnZGF0ZSc7XG4gICAgfSBlbHNlIGlmIChmaWVsZC50eXBlID09IFEpIHtcbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlID0gZGF0YS5mb3JtYXQucGFyc2UgfHwge307XG4gICAgICBpZiAoZmllbGQuYWdnciA9PT0gJ2NvdW50Jykge1xuICAgICAgICBuYW1lID0gJ2NvdW50JztcbiAgICAgIH0gZWxzZSBpZiAocHJlYWdncmVnYXRlZERhdGEgJiYgZmllbGQuYmluKSB7XG4gICAgICAgIG5hbWUgPSAnYmluXycgKyBmaWVsZC5uYW1lO1xuICAgICAgfSBlbHNlIGlmIChwcmVhZ2dyZWdhdGVkRGF0YSAmJiBmaWVsZC5hZ2dyKSB7XG4gICAgICAgIG5hbWUgPSBmaWVsZC5hZ2dyICsgJ18nICsgZmllbGQubmFtZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5hbWUgPSBmaWVsZC5uYW1lO1xuICAgICAgfVxuICAgICAgZGF0YS5mb3JtYXQucGFyc2VbbmFtZV0gPSAnbnVtYmVyJztcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiB7XG4gICAgd2lkdGg6IGxheW91dC53aWR0aCxcbiAgICBoZWlnaHQ6IGxheW91dC5oZWlnaHQsXG4gICAgcGFkZGluZzogJ2F1dG8nLFxuICAgIGRhdGE6IFtkYXRhLCB0YWJsZV0sXG4gICAgbWFya3M6IFtncm91cGRlZignY2VsbCcsIHtcbiAgICAgIHdpZHRoOiBsYXlvdXQuY2VsbFdpZHRoID8ge3ZhbHVlOiBsYXlvdXQuY2VsbFdpZHRofSA6IHVuZGVmaW5lZCxcbiAgICAgIGhlaWdodDogbGF5b3V0LmNlbGxIZWlnaHQgPyB7dmFsdWU6IGxheW91dC5jZWxsSGVpZ2h0fSA6IHVuZGVmaW5lZFxuICAgIH0pXVxuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB0aW1lO1xuXG5mdW5jdGlvbiB0aW1lKHNwZWMsIGVuY29kaW5nLCBvcHQpIHtcbiAgdmFyIHRpbWVGaWVsZHMgPSB7fSwgdGltZUZuID0ge307XG5cbiAgLy8gZmluZCB1bmlxdWUgZm9ybXVsYSB0cmFuc2Zvcm1hdGlvbiBhbmQgYmluIGZ1bmN0aW9uXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICBpZiAoZmllbGQudHlwZSA9PT0gVCAmJiBmaWVsZC5mbikge1xuICAgICAgdGltZUZpZWxkc1tlbmNvZGluZy5maWVsZChlbmNUeXBlKV0gPSB7XG4gICAgICAgIGZpZWxkOiBmaWVsZCxcbiAgICAgICAgZW5jVHlwZTogZW5jVHlwZVxuICAgICAgfTtcbiAgICAgIHRpbWVGbltmaWVsZC5mbl0gPSB0cnVlO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gYWRkIGZvcm11bGEgdHJhbnNmb3JtXG4gIHZhciBkYXRhID0gc3BlYy5kYXRhWzFdLFxuICAgIHRyYW5zZm9ybSA9IGRhdGEudHJhbnNmb3JtID0gZGF0YS50cmFuc2Zvcm0gfHwgW107XG5cbiAgZm9yICh2YXIgZiBpbiB0aW1lRmllbGRzKSB7XG4gICAgdmFyIHRmID0gdGltZUZpZWxkc1tmXTtcbiAgICB0aW1lLnRyYW5zZm9ybSh0cmFuc2Zvcm0sIGVuY29kaW5nLCB0Zi5lbmNUeXBlLCB0Zi5maWVsZCk7XG4gIH1cblxuICAvLyBhZGQgc2NhbGVzXG4gIHZhciBzY2FsZXMgPSBzcGVjLnNjYWxlcyA9IHNwZWMuc2NhbGVzIHx8IFtdO1xuICBmb3IgKHZhciBmbiBpbiB0aW1lRm4pIHtcbiAgICB0aW1lLnNjYWxlKHNjYWxlcywgZm4sIGVuY29kaW5nKTtcbiAgfVxuICByZXR1cm4gc3BlYztcbn1cblxudGltZS5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdHlwZSkge1xuICB2YXIgZm4gPSBmaWVsZC5mbjtcbiAgc3dpdGNoIChmbikge1xuICAgIGNhc2UgJ3NlY29uZHMnOiByZXR1cm4gNjA7XG4gICAgY2FzZSAnbWludXRlcyc6IHJldHVybiA2MDtcbiAgICBjYXNlICdob3Vycyc6IHJldHVybiAyNDtcbiAgICBjYXNlICdkYXknOiByZXR1cm4gNztcbiAgICBjYXNlICdkYXRlJzogcmV0dXJuIDMxO1xuICAgIGNhc2UgJ21vbnRoJzogcmV0dXJuIDEyO1xuICAgIGNhc2UgJ3llYXInOlxuICAgICAgdmFyIHN0YXQgPSBzdGF0c1tmaWVsZC5uYW1lXSxcbiAgICAgICAgeWVhcnN0YXQgPSBzdGF0c1sneWVhcl8nK2ZpZWxkLm5hbWVdO1xuXG4gICAgICBpZiAoIXllYXJzdGF0KSB7IHJldHVybiBudWxsOyB9XG5cbiAgICAgIHJldHVybiB5ZWFyc3RhdC5kaXN0aW5jdCAtXG4gICAgICAgIChzdGF0Lm51bGxzID4gMCAmJiBmaWx0ZXJOdWxsW3R5cGVdID8gMSA6IDApO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59O1xuXG5mdW5jdGlvbiBmaWVsZEZuKGZ1bmMsIGZpZWxkKSB7XG4gIHJldHVybiAndXRjJyArIGZ1bmMgKyAnKGQuZGF0YS4nKyBmaWVsZC5uYW1lICsnKSc7XG59XG5cbi8qKlxuICogQHJldHVybiB7U3RyaW5nfSBkYXRlIGJpbm5pbmcgZm9ybXVsYSBvZiB0aGUgZ2l2ZW4gZmllbGRcbiAqL1xudGltZS5mb3JtdWxhID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkRm4oZmllbGQuZm4sIGZpZWxkKTtcbn07XG5cbi8qKiBhZGQgZm9ybXVsYSB0cmFuc2Zvcm1zIHRvIGRhdGEgKi9cbnRpbWUudHJhbnNmb3JtID0gZnVuY3Rpb24odHJhbnNmb3JtLCBlbmNvZGluZywgZW5jVHlwZSwgZmllbGQpIHtcbiAgdHJhbnNmb3JtLnB1c2goe1xuICAgIHR5cGU6ICdmb3JtdWxhJyxcbiAgICBmaWVsZDogZW5jb2RpbmcuZmllbGQoZW5jVHlwZSksXG4gICAgZXhwcjogdGltZS5mb3JtdWxhKGZpZWxkKVxuICB9KTtcbn07XG5cbi8qKiBhcHBlbmQgY3VzdG9tIHRpbWUgc2NhbGVzIGZvciBheGlzIGxhYmVsICovXG50aW1lLnNjYWxlID0gZnVuY3Rpb24oc2NhbGVzLCBmbiwgZW5jb2RpbmcpIHtcbiAgdmFyIGxhYmVsTGVuZ3RoID0gZW5jb2RpbmcuY29uZmlnKCd0aW1lU2NhbGVMYWJlbExlbmd0aCcpO1xuICAvLyBUT0RPIGFkZCBvcHRpb24gZm9yIHNob3J0ZXIgc2NhbGUgLyBjdXN0b20gcmFuZ2VcbiAgc3dpdGNoIChmbikge1xuICAgIGNhc2UgJ2RheSc6XG4gICAgICBzY2FsZXMucHVzaCh7XG4gICAgICAgIG5hbWU6ICd0aW1lLScrZm4sXG4gICAgICAgIHR5cGU6ICdvcmRpbmFsJyxcbiAgICAgICAgZG9tYWluOiB1dGlsLnJhbmdlKDAsIDcpLFxuICAgICAgICByYW5nZTogWydNb25kYXknLCAnVHVlc2RheScsICdXZWRuZXNkYXknLCAnVGh1cnNkYXknLCAnRnJpZGF5JywgJ1NhdHVyZGF5JywgJ1N1bmRheSddLm1hcChcbiAgICAgICAgICBmdW5jdGlvbihzKSB7IHJldHVybiBzLnN1YnN0cigwLCBsYWJlbExlbmd0aCk7fVxuICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHNjYWxlcy5wdXNoKHtcbiAgICAgICAgbmFtZTogJ3RpbWUtJytmbixcbiAgICAgICAgdHlwZTogJ29yZGluYWwnLFxuICAgICAgICBkb21haW46IHV0aWwucmFuZ2UoMCwgMTIpLFxuICAgICAgICByYW5nZTogWydKYW51YXJ5JywgJ0ZlYnJ1YXJ5JywgJ01hcmNoJywgJ0FwcmlsJywgJ01heScsICdKdW5lJywgJ0p1bHknLCAnQXVndXN0JywgJ1NlcHRlbWJlcicsICdPY3RvYmVyJywgJ05vdmVtYmVyJywgJ0RlY2VtYmVyJ10ubWFwKFxuICAgICAgICAgICAgZnVuY3Rpb24ocykgeyByZXR1cm4gcy5zdWJzdHIoMCwgbGFiZWxMZW5ndGgpO31cbiAgICAgICAgICApXG4gICAgICB9KTtcbiAgICAgIGJyZWFrO1xuICB9XG59O1xuXG50aW1lLmlzT3JkaW5hbEZuID0gZnVuY3Rpb24oZm4pIHtcbiAgc3dpdGNoIChmbikge1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ2hvdXJzJzpcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ2RhdGUnOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cbnRpbWUuc2NhbGUudHlwZSA9IGZ1bmN0aW9uKGZuLCBuYW1lKSB7XG4gIGlmIChuYW1lID09PSBDT0xPUikge1xuICAgIHJldHVybiAnbGluZWFyJzsgLy8gdGhpcyBoYXMgb3JkZXJcbiAgfVxuXG4gIHJldHVybiB0aW1lLmlzT3JkaW5hbEZuKGZuKSB8fCBuYW1lID09PSBDT0wgfHwgbmFtZSA9PT0gUk9XID8gJ29yZGluYWwnIDogJ2xpbmVhcic7XG59O1xuXG50aW1lLnNjYWxlLmRvbWFpbiA9IGZ1bmN0aW9uKGZuLCBuYW1lKSB7XG4gIHZhciBpc0NvbG9yID0gbmFtZSA9PT0gQ09MT1I7XG4gIHN3aXRjaCAoZm4pIHtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdtaW51dGVzJzogcmV0dXJuIGlzQ29sb3IgPyBbMCw1OV0gOiB1dGlsLnJhbmdlKDAsIDYwKTtcbiAgICBjYXNlICdob3Vycyc6IHJldHVybiBpc0NvbG9yID8gWzAsMjNdIDogdXRpbC5yYW5nZSgwLCAyNCk7XG4gICAgY2FzZSAnZGF5JzogcmV0dXJuIGlzQ29sb3IgPyBbMCw2XSA6IHV0aWwucmFuZ2UoMCwgNyk7XG4gICAgY2FzZSAnZGF0ZSc6IHJldHVybiBpc0NvbG9yID8gWzEsMzFdIDogdXRpbC5yYW5nZSgxLCAzMik7XG4gICAgY2FzZSAnbW9udGgnOiByZXR1cm4gaXNDb2xvciA/IFswLDExXSA6IHV0aWwucmFuZ2UoMCwgMTIpO1xuICB9XG4gIHJldHVybiBudWxsO1xufTtcblxuLyoqIHdoZXRoZXIgYSBwYXJ0aWN1bGFyIHRpbWUgZnVuY3Rpb24gaGFzIGN1c3RvbSBzY2FsZSBmb3IgbGFiZWxzIGltcGxlbWVudGVkIGluIHRpbWUuc2NhbGUgKi9cbnRpbWUuaGFzU2NhbGUgPSBmdW5jdGlvbihmbikge1xuICBzd2l0Y2ggKGZuKSB7XG4gICAgY2FzZSAnZGF5JzpcbiAgICBjYXNlICdtb250aCc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuL2dsb2JhbHMnKTtcblxudmFyIGNvbnN0cyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmNvbnN0cy5lbmNvZGluZ1R5cGVzID0gW1gsIFksIFJPVywgQ09MLCBTSVpFLCBTSEFQRSwgQ09MT1IsIEFMUEhBLCBURVhULCBERVRBSUxdO1xuXG5jb25zdHMuZGF0YVR5cGVzID0geydPJzogTywgJ1EnOiBRLCAnVCc6IFR9O1xuXG5jb25zdHMuZGF0YVR5cGVOYW1lcyA9IFsnTycsICdRJywgJ1QnXS5yZWR1Y2UoZnVuY3Rpb24ociwgeCkge1xuICByW2NvbnN0cy5kYXRhVHlwZXNbeF1dID0geDtcbiAgcmV0dXJuIHI7XG59LHt9KTtcblxuY29uc3RzLnNob3J0aGFuZCA9IHtcbiAgZGVsaW06ICAnfCcsXG4gIGFzc2lnbjogJz0nLFxuICB0eXBlOiAgICcsJyxcbiAgZnVuYzogICAnXydcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBkbCA9IHJlcXVpcmUoJ2RhdGFsaWInKTtcblxudmFyIHZsZGF0YSA9IG1vZHVsZS5leHBvcnRzID0ge30sXG4gIHZsZmllbGQgPSByZXF1aXJlKCcuL2ZpZWxkJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKTtcblxudmxkYXRhLmdldFVybCA9IGZ1bmN0aW9uIGdldERhdGFVcmwoZW5jb2RpbmcsIHN0YXRzKSB7XG4gIGlmICghZW5jb2RpbmcuZGF0YSgndmVnYVNlcnZlcicpKSB7XG4gICAgLy8gZG9uJ3QgdXNlIHZlZ2Egc2VydmVyXG4gICAgcmV0dXJuIGVuY29kaW5nLmRhdGEoJ3VybCcpO1xuICB9XG5cbiAgaWYgKGVuY29kaW5nLmxlbmd0aCgpID09PSAwKSB7XG4gICAgLy8gbm8gZmllbGRzXG4gICAgcmV0dXJuO1xuICB9XG5cbiAgdmFyIGZpZWxkcyA9IFtdO1xuICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIG5hbWU6IGVuY29kaW5nLmZpZWxkKGVuY1R5cGUsIHRydWUpLFxuICAgICAgZmllbGQ6IGZpZWxkLm5hbWVcbiAgICB9O1xuICAgIGlmIChmaWVsZC5hZ2dyKSB7XG4gICAgICBvYmouYWdnciA9IGZpZWxkLmFnZ3I7XG4gICAgfVxuICAgIGlmIChmaWVsZC5iaW4pIHtcbiAgICAgIG9iai5iaW5TaXplID0gdXRpbC5nZXRiaW5zKHN0YXRzW2ZpZWxkLm5hbWVdLCBlbmNvZGluZy5iaW4oZW5jVHlwZSkubWF4Ymlucykuc3RlcDtcbiAgICB9XG4gICAgZmllbGRzLnB1c2gob2JqKTtcbiAgfSk7XG5cbiAgdmFyIHF1ZXJ5ID0ge1xuICAgIHRhYmxlOiBlbmNvZGluZy5kYXRhKCd2ZWdhU2VydmVyJykudGFibGUsXG4gICAgZmllbGRzOiBmaWVsZHNcbiAgfTtcblxuICByZXR1cm4gZW5jb2RpbmcuZGF0YSgndmVnYVNlcnZlcicpLnVybCArICcvcXVlcnkvP3E9JyArIEpTT04uc3RyaW5naWZ5KHF1ZXJ5KTtcbn07XG5cbi8qKiBNYXBwaW5nIGZyb20gZGF0YWxpYidzIGluZmVycmVkIHR5cGUgdG8gdmVnYWxpdGUncyB0eXBlICovXG52bGRhdGEudHlwZXMgPSB7XG4gICdib29sZWFuJzogJ08nLFxuICAnbnVtYmVyJzogJ1EnLFxuICAnaW50ZWdlcic6ICdRJyxcbiAgJ2RhdGUnOiAnVCcsXG4gICdzdHJpbmcnOiAnTydcbn07XG5cbnZsZGF0YS5nZXRTdGF0cyA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgdmFyIHN0YXRzID0ge30sXG4gICAgZmllbGRzID0gdXRpbC5rZXlzKGRhdGFbMF0pO1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICB2YXIgc3RhdCA9IGRsLnByb2ZpbGUoZGF0YSwgZnVuY3Rpb24oZCkge1xuICAgICAgcmV0dXJuIGRba107XG4gICAgfSk7XG5cbiAgICB2YXIgc2FtcGxlID0ge307XG4gICAgd2hpbGUoT2JqZWN0LmtleXMoc2FtcGxlKS5sZW5ndGggPCBNYXRoLm1pbihzdGF0LmRpc3RpbmN0LCAxMCkpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGRhdGFbTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogZGF0YS5sZW5ndGgpXVtrXTtcbiAgICAgIHNhbXBsZVt2YWx1ZV0gPSB0cnVlO1xuICAgIH1cbiAgICBzdGF0LnNhbXBsZSA9IE9iamVjdC5rZXlzKHNhbXBsZSk7XG5cbiAgICBzdGF0c1trXSA9IHN0YXQ7XG4gIH0pO1xuXG4gIHN0YXRzLmNvdW50ID0gZGF0YS5sZW5ndGg7XG4gIHJldHVybiBzdGF0cztcbn07XG4iLCIvLyB1dGlsaXR5IGZvciBlbmNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHRpbWUgPSByZXF1aXJlKCcuL2NvbXBpbGUvdGltZScpLFxuICB2bGZpZWxkID0gcmVxdWlyZSgnLi9maWVsZCcpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpLFxuICBlbmNUeXBlcyA9IHNjaGVtYS5lbmNUeXBlcztcblxudmFyIHZsZW5jID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudmxlbmMuY291bnRSZXRpbmFsID0gZnVuY3Rpb24oZW5jKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGlmIChlbmMuY29sb3IpIGNvdW50Kys7XG4gIGlmIChlbmMuYWxwaGEpIGNvdW50Kys7XG4gIGlmIChlbmMuc2l6ZSkgY291bnQrKztcbiAgaWYgKGVuYy5zaGFwZSkgY291bnQrKztcbiAgcmV0dXJuIGNvdW50O1xufTtcblxudmxlbmMuaGFzID0gZnVuY3Rpb24oZW5jLCBlbmNUeXBlKSB7XG4gIHZhciBmaWVsZERlZiA9IGVuYyAmJiBlbmNbZW5jVHlwZV07XG4gIHJldHVybiBmaWVsZERlZiAmJiBmaWVsZERlZi5uYW1lO1xufTtcblxudmxlbmMuaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbihlbmMpIHtcbiAgZm9yICh2YXIgayBpbiBlbmMpIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykgJiYgZW5jW2tdLmFnZ3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52bGVuYy5mb3JFYWNoID0gZnVuY3Rpb24oZW5jLCBmKSB7XG4gIHZhciBpID0gMDtcbiAgZW5jVHlwZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspKSB7XG4gICAgICBmKGVuY1trXSwgaywgaSsrKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmxlbmMubWFwID0gZnVuY3Rpb24oZW5jLCBmKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgZW5jVHlwZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspKSB7XG4gICAgICBhcnIucHVzaChmKGVuY1trXSwgaywgZW5jKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbnZsZW5jLnJlZHVjZSA9IGZ1bmN0aW9uKGVuYywgZiwgaW5pdCkge1xuICB2YXIgciA9IGluaXQsIGkgPSAwLCBrO1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIHIgPSBmKHIsIGVuY1trXSwgaywgIGVuYyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vKlxuICogcmV0dXJuIGtleS12YWx1ZSBwYWlycyBvZiBmaWVsZCBuYW1lIGFuZCBsaXN0IG9mIGZpZWxkcyBvZiB0aGF0IGZpZWxkIG5hbWVcbiAqL1xudmxlbmMuZmllbGRzID0gZnVuY3Rpb24oZW5jKSB7XG4gIHJldHVybiB2bGVuYy5yZWR1Y2UoZW5jLCBmdW5jdGlvbiAobSwgZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgZmllbGRMaXN0ID0gbVtmaWVsZC5uYW1lXSA9IG1bZmllbGQubmFtZV0gfHwgW10sXG4gICAgICBjb250YWluc1R5cGUgPSBmaWVsZExpc3QuY29udGFpbnNUeXBlID0gZmllbGRMaXN0LmNvbnRhaW5zVHlwZSB8fCB7fTtcblxuICAgIGlmIChmaWVsZExpc3QuaW5kZXhPZihmaWVsZCkgPT09IC0xKSB7XG4gICAgICBmaWVsZExpc3QucHVzaChmaWVsZCk7XG4gICAgICAvLyBhdWdtZW50IHRoZSBhcnJheSB3aXRoIGNvbnRhaW5zVHlwZS5RIC8gTyAvIFRcbiAgICAgIGNvbnRhaW5zVHlwZVtmaWVsZC50eXBlXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9LCB7fSk7XG59O1xuXG52bGVuYy5zaG9ydGhhbmQgPSBmdW5jdGlvbihlbmMpIHtcbiAgcmV0dXJuIHZsZW5jLm1hcChlbmMsIGZ1bmN0aW9uKGZpZWxkLCBldCkge1xuICAgIHJldHVybiBldCArIGMuYXNzaWduICsgdmxmaWVsZC5zaG9ydGhhbmQoZmllbGQpO1xuICB9KS5qb2luKGMuZGVsaW0pO1xufTtcblxudmxlbmMuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCwgY29udmVydFR5cGUpIHtcbiAgdmFyIGVuYyA9IHV0aWwuaXNBcnJheShzaG9ydGhhbmQpID8gc2hvcnRoYW5kIDogc2hvcnRoYW5kLnNwbGl0KGMuZGVsaW0pO1xuICByZXR1cm4gZW5jLnJlZHVjZShmdW5jdGlvbihtLCBlKSB7XG4gICAgdmFyIHNwbGl0ID0gZS5zcGxpdChjLmFzc2lnbiksXG4gICAgICAgIGVuY3R5cGUgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgIGZpZWxkID0gc3BsaXRbMV07XG5cbiAgICBtW2VuY3R5cGVdID0gdmxmaWVsZC5mcm9tU2hvcnRoYW5kKGZpZWxkLCBjb252ZXJ0VHlwZSk7XG4gICAgcmV0dXJuIG07XG4gIH0sIHt9KTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyB1dGlsaXR5IGZvciBmaWVsZFxuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHRpbWUgPSByZXF1aXJlKCcuL2NvbXBpbGUvdGltZScpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpO1xuXG52YXIgdmxmaWVsZCA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZsZmllbGQuc2hvcnRoYW5kID0gZnVuY3Rpb24oZikge1xuICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQ7XG4gIHJldHVybiAoZi5hZ2dyID8gZi5hZ2dyICsgYy5mdW5jIDogJycpICtcbiAgICAoZi5mbiA/IGYuZm4gKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLmJpbiA/ICdiaW4nICsgYy5mdW5jIDogJycpICtcbiAgICAoZi5uYW1lIHx8ICcnKSArIGMudHlwZSArXG4gICAgKGNvbnN0cy5kYXRhVHlwZU5hbWVzW2YudHlwZV0gfHwgZi50eXBlKTtcbn07XG5cbnZsZmllbGQuc2hvcnRoYW5kcyA9IGZ1bmN0aW9uKGZpZWxkcywgZGVsaW0pIHtcbiAgZGVsaW0gPSBkZWxpbSB8fCBjLmRlbGltO1xuICByZXR1cm4gZmllbGRzLm1hcCh2bGZpZWxkLnNob3J0aGFuZCkuam9pbihkZWxpbSk7XG59O1xuXG52bGZpZWxkLmZyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGNvbnZlcnRUeXBlKSB7XG4gIHZhciBzcGxpdCA9IHNob3J0aGFuZC5zcGxpdChjLnR5cGUpLCBpO1xuICB2YXIgbyA9IHtcbiAgICBuYW1lOiBzcGxpdFswXS50cmltKCksXG4gICAgdHlwZTogY29udmVydFR5cGUgPyBjb25zdHMuZGF0YVR5cGVzW3NwbGl0WzFdLnRyaW0oKV0gOiBzcGxpdFsxXS50cmltKClcbiAgfTtcblxuICAvLyBjaGVjayBhZ2dyZWdhdGUgdHlwZVxuICBmb3IgKGkgaW4gc2NoZW1hLmFnZ3IuZW51bSkge1xuICAgIHZhciBhID0gc2NoZW1hLmFnZ3IuZW51bVtpXTtcbiAgICBpZiAoby5uYW1lLmluZGV4T2YoYSArICdfJykgPT09IDApIHtcbiAgICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoYS5sZW5ndGggKyAxKTtcbiAgICAgIGlmIChhID09ICdjb3VudCcgJiYgby5uYW1lLmxlbmd0aCA9PT0gMCkgby5uYW1lID0gJyonO1xuICAgICAgby5hZ2dyID0gYTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHRpbWUgZm5cbiAgZm9yIChpIGluIHNjaGVtYS50aW1lZm5zKSB7XG4gICAgdmFyIGYgPSBzY2hlbWEudGltZWZuc1tpXTtcbiAgICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKGYgKyAnXycpID09PSAwKSB7XG4gICAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKG8ubGVuZ3RoICsgMSk7XG4gICAgICBvLmZuID0gZjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGJpblxuICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKCdiaW5fJykgPT09IDApIHtcbiAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKDQpO1xuICAgIG8uYmluID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvO1xufTtcblxudmFyIHR5cGVPcmRlciA9IHtcbiAgTzogMCxcbiAgRzogMSxcbiAgVDogMixcbiAgUTogM1xufTtcblxudmxmaWVsZC5vcmRlciA9IHt9O1xuXG52bGZpZWxkLm9yZGVyLnR5cGUgPSBmdW5jdGlvbihmaWVsZCkge1xuICBpZiAoZmllbGQuYWdncj09PSdjb3VudCcpIHJldHVybiA0O1xuICByZXR1cm4gdHlwZU9yZGVyW2ZpZWxkLnR5cGVdO1xufTtcblxudmxmaWVsZC5vcmRlci50eXBlVGhlbk5hbWUgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gdmxmaWVsZC5vcmRlci50eXBlKGZpZWxkKSArICdfJyArIGZpZWxkLm5hbWUudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZsZmllbGQub3JkZXIub3JpZ2luYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7IC8vIG5vIHN3YXAgd2lsbCBvY2N1clxufTtcblxudmxmaWVsZC5vcmRlci5uYW1lID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkLm5hbWU7XG59O1xuXG52bGZpZWxkLm9yZGVyLnR5cGVUaGVuQ2FyZGluYWxpdHkgPSBmdW5jdGlvbihmaWVsZCwgc3RhdHMpe1xuICByZXR1cm4gc3RhdHNbZmllbGQubmFtZV0uZGlzdGluY3Q7XG59O1xuXG4vLyBGSVhNRSByZWZhY3RvclxudmxmaWVsZC5pc1R5cGUgPSBmdW5jdGlvbiAoZmllbGREZWYsIHR5cGUpIHtcbiAgcmV0dXJuIChmaWVsZERlZi50eXBlICYgdHlwZSkgPiAwO1xufTtcblxudmxmaWVsZC5pc1R5cGUuYnlDb2RlID0gdmxmaWVsZC5pc1R5cGU7XG5cbnZsZmllbGQuaXNUeXBlLmJ5TmFtZSA9IGZ1bmN0aW9uIChmaWVsZCwgdHlwZSkge1xuICByZXR1cm4gZmllbGQudHlwZSA9PT0gY29uc3RzLmRhdGFUeXBlTmFtZXNbdHlwZV07XG59O1xuXG5cbmZ1bmN0aW9uIGdldElzVHlwZSh1c2VUeXBlQ29kZSkge1xuICByZXR1cm4gdXNlVHlwZUNvZGUgPyB2bGZpZWxkLmlzVHlwZS5ieUNvZGUgOiB2bGZpZWxkLmlzVHlwZS5ieU5hbWU7XG59XG5cbnZsZmllbGQuaXNUeXBlLmdldCA9IGdldElzVHlwZTsgLy9GSVhNRVxuXG4vKlxuICogTW9zdCBmaWVsZHMgdGhhdCB1c2Ugb3JkaW5hbCBzY2FsZSBhcmUgZGltZW5zaW9ucy5cbiAqIEhvd2V2ZXIsIFlFQVIoVCksIFlFQVJNT05USChUKSB1c2UgdGltZSBzY2FsZSwgbm90IG9yZGluYWwgYnV0IGFyZSBkaW1lbnNpb25zIHRvby5cbiAqL1xudmxmaWVsZC5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGZpZWxkLCB1c2VUeXBlQ29kZSAvKm9wdGlvbmFsKi8pIHtcbiAgdmFyIGlzVHlwZSA9IGdldElzVHlwZSh1c2VUeXBlQ29kZSk7XG4gIHJldHVybiAgaXNUeXBlKGZpZWxkLCBPKSB8fCBmaWVsZC5iaW4gfHxcbiAgICAoIGlzVHlwZShmaWVsZCwgVCkgJiYgZmllbGQuZm4gJiYgdGltZS5pc09yZGluYWxGbihmaWVsZC5mbikgKTtcbn07XG5cbmZ1bmN0aW9uIGlzRGltZW5zaW9uKGZpZWxkLCB1c2VUeXBlQ29kZSAvKm9wdGlvbmFsKi8pIHtcbiAgdmFyIGlzVHlwZSA9IGdldElzVHlwZSh1c2VUeXBlQ29kZSk7XG4gIHJldHVybiAgaXNUeXBlKGZpZWxkLCBPKSB8fCAhIWZpZWxkLmJpbiB8fFxuICAgICggaXNUeXBlKGZpZWxkLCBUKSAmJiAhIWZpZWxkLmZuICk7XG59XG5cbi8qKlxuICogRm9yIGVuY29kaW5nLCB1c2UgZW5jb2RpbmcuaXNEaW1lbnNpb24oKSB0byBhdm9pZCBjb25mdXNpb24uXG4gKiBPciB1c2UgRW5jb2RpbmcuaXNUeXBlIGlmIHlvdXIgZmllbGQgaXMgZnJvbSBFbmNvZGluZyAoYW5kIHRodXMgaGF2ZSBudW1lcmljIGRhdGEgdHlwZSkuXG4gKiBvdGhlcndpc2UsIGRvIG5vdCBzcGVjaWZpYyBpc1R5cGUgc28gd2UgY2FuIHVzZSB0aGUgZGVmYXVsdCBpc1R5cGVOYW1lIGhlcmUuXG4gKi9cbnZsZmllbGQuaXNEaW1lbnNpb24gPSBmdW5jdGlvbihmaWVsZCwgdXNlVHlwZUNvZGUgLypvcHRpb25hbCovKSB7XG4gIHJldHVybiBmaWVsZCAmJiBpc0RpbWVuc2lvbihmaWVsZCwgdXNlVHlwZUNvZGUpO1xufTtcblxudmxmaWVsZC5pc01lYXN1cmUgPSBmdW5jdGlvbihmaWVsZCwgdXNlVHlwZUNvZGUpIHtcbiAgcmV0dXJuIGZpZWxkICYmICFpc0RpbWVuc2lvbihmaWVsZCwgdXNlVHlwZUNvZGUpO1xufTtcblxudmxmaWVsZC5yb2xlID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGlzRGltZW5zaW9uKGZpZWxkKSA/ICdkaW1lbnNpb24nIDogJ21lYXN1cmUnO1xufTtcblxudmxmaWVsZC5jb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge25hbWU6JyonLCBhZ2dyOiAnY291bnQnLCB0eXBlOidRJywgZGlzcGxheU5hbWU6IHZsZmllbGQuY291bnQuZGlzcGxheU5hbWV9O1xufTtcblxudmxmaWVsZC5jb3VudC5kaXNwbGF5TmFtZSA9ICdOdW1iZXIgb2YgUmVjb3Jkcyc7XG5cbnZsZmllbGQuaXNDb3VudCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZC5hZ2dyID09PSAnY291bnQnO1xufTtcblxuLyoqXG4gKiBGb3IgZW5jb2RpbmcsIHVzZSBlbmNvZGluZy5jYXJkaW5hbGl0eSgpIHRvIGF2b2lkIGNvbmZ1c2lvbi4gIE9yIHVzZSBFbmNvZGluZy5pc1R5cGUgaWYgeW91ciBmaWVsZCBpcyBmcm9tIEVuY29kaW5nIChhbmQgdGh1cyBoYXZlIG51bWVyaWMgZGF0YSB0eXBlKS5cbiAqIG90aGVyd2lzZSwgZG8gbm90IHNwZWNpZmljIGlzVHlwZSBzbyB3ZSBjYW4gdXNlIHRoZSBkZWZhdWx0IGlzVHlwZU5hbWUgaGVyZS5cbiAqL1xudmxmaWVsZC5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdXNlVHlwZUNvZGUpIHtcbiAgLy8gRklYTUUgbmVlZCB0byB0YWtlIGZpbHRlciBpbnRvIGFjY291bnRcblxuICB2YXIgc3RhdCA9IHN0YXRzW2ZpZWxkLm5hbWVdO1xuICB2YXIgaXNUeXBlID0gZ2V0SXNUeXBlKHVzZVR5cGVDb2RlKSxcbiAgICB0eXBlID0gdXNlVHlwZUNvZGUgPyBjb25zdHMuZGF0YVR5cGVOYW1lc1tmaWVsZC50eXBlXSA6IGZpZWxkLnR5cGU7XG5cbiAgZmlsdGVyTnVsbCA9IGZpbHRlck51bGwgfHwge307XG5cbiAgaWYgKGZpZWxkLmJpbikge1xuICAgIHZhciBiaW5zID0gdXRpbC5nZXRiaW5zKHN0YXQsIGZpZWxkLmJpbi5tYXhiaW5zIHx8IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFQpO1xuICAgIHJldHVybiAoYmlucy5zdG9wIC0gYmlucy5zdGFydCkgLyBiaW5zLnN0ZXA7XG4gIH1cbiAgaWYgKGlzVHlwZShmaWVsZCwgVCkpIHtcbiAgICB2YXIgY2FyZGluYWxpdHkgPSB0aW1lLmNhcmRpbmFsaXR5KGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdHlwZSk7XG4gICAgaWYoY2FyZGluYWxpdHkgIT09IG51bGwpIHJldHVybiBjYXJkaW5hbGl0eTtcbiAgICAvL290aGVyd2lzZSB1c2UgY2FsY3VsYXRpb24gYmVsb3dcbiAgfVxuICBpZiAoZmllbGQuYWdncikge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgLy8gcmVtb3ZlIG51bGxcbiAgcmV0dXJuIHN0YXQuZGlzdGluY3QgLVxuICAgIChzdGF0Lm51bGxzID4gMCAmJiBmaWx0ZXJOdWxsW3R5cGVdID8gMSA6IDApO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gZGVjbGFyZSBnbG9iYWwgY29uc3RhbnRcbnZhciBnID0gZ2xvYmFsIHx8IHdpbmRvdztcblxuZy5UQUJMRSA9ICd0YWJsZSc7XG5nLlJBVyA9ICdyYXcnO1xuZy5TVEFDS0VEID0gJ3N0YWNrZWQnO1xuZy5JTkRFWCA9ICdpbmRleCc7XG5cbmcuWCA9ICd4JztcbmcuWSA9ICd5JztcbmcuUk9XID0gJ3Jvdyc7XG5nLkNPTCA9ICdjb2wnO1xuZy5TSVpFID0gJ3NpemUnO1xuZy5TSEFQRSA9ICdzaGFwZSc7XG5nLkNPTE9SID0gJ2NvbG9yJztcbmcuQUxQSEEgPSAnYWxwaGEnO1xuZy5URVhUID0gJ3RleHQnO1xuZy5ERVRBSUwgPSAnZGV0YWlsJztcblxuZy5PID0gMTtcbmcuUSA9IDI7XG5nLlQgPSA0O1xuIiwiLy8gUGFja2FnZSBvZiBkZWZpbmluZyBWZWdhbGl0ZSBTcGVjaWZpY2F0aW9uJ3MganNvbiBzY2hlbWFcblwidXNlIHN0cmljdFwiO1xuXG52YXIgc2NoZW1hID0gbW9kdWxlLmV4cG9ydHMgPSB7fSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxuc2NoZW1hLnV0aWwgPSByZXF1aXJlKCcuL3NjaGVtYXV0aWwnKTtcblxuc2NoZW1hLm1hcmt0eXBlID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogWydwb2ludCcsICd0aWNrJywgJ2JhcicsICdsaW5lJywgJ2FyZWEnLCAnY2lyY2xlJywgJ3NxdWFyZScsICd0ZXh0J11cbn07XG5cbnNjaGVtYS5hZ2dyID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogWydhdmcnLCAnc3VtJywgJ21pbicsICdtYXgnLCAnY291bnQnXSxcbiAgc3VwcG9ydGVkRW51bXM6IHtcbiAgICBROiBbJ2F2ZycsICdzdW0nLCAnbWluJywgJ21heCcsICdjb3VudCddLFxuICAgIE86IFtdLFxuICAgIFQ6IFsnYXZnJywgJ21pbicsICdtYXgnXSxcbiAgICAnJzogWydjb3VudCddXG4gIH0sXG4gIHN1cHBvcnRlZFR5cGVzOiB7J1EnOiB0cnVlLCAnTyc6IHRydWUsICdUJzogdHJ1ZSwgJyc6IHRydWV9XG59O1xuc2NoZW1hLmJhbmQgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgc2l6ZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgcGFkZGluZzoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIGRlZmF1bHQ6IDFcbiAgICB9XG4gIH1cbn07XG5cbnNjaGVtYS5nZXRTdXBwb3J0ZWRSb2xlID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICByZXR1cm4gc2NoZW1hLnNjaGVtYS5wcm9wZXJ0aWVzLmVuYy5wcm9wZXJ0aWVzW2VuY1R5cGVdLnN1cHBvcnRlZFJvbGU7XG59O1xuXG5zY2hlbWEudGltZWZucyA9IFsneWVhcicsICdtb250aCcsICdkYXknLCAnZGF0ZScsICdob3VycycsICdtaW51dGVzJywgJ3NlY29uZHMnXTtcblxuc2NoZW1hLmRlZmF1bHRUaW1lRm4gPSAnbW9udGgnO1xuXG5zY2hlbWEuZm4gPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBlbnVtOiBzY2hlbWEudGltZWZucyxcbiAgc3VwcG9ydGVkVHlwZXM6IHsnVCc6IHRydWV9XG59O1xuXG4vL1RPRE8oa2FuaXR3KTogYWRkIG90aGVyIHR5cGUgb2YgZnVuY3Rpb24gaGVyZVxuXG5zY2hlbWEuc2NhbGVfdHlwZSA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGVudW06IFsnbGluZWFyJywgJ2xvZycsICdwb3cnLCAnc3FydCcsICdxdWFudGlsZSddLFxuICBkZWZhdWx0OiAnbGluZWFyJyxcbiAgc3VwcG9ydGVkVHlwZXM6IHsnUSc6IHRydWV9XG59O1xuXG5zY2hlbWEuZmllbGQgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbmFtZToge1xuICAgICAgdHlwZTogJ3N0cmluZydcbiAgICB9XG4gIH1cbn07XG5cbnZhciBjbG9uZSA9IHV0aWwuZHVwbGljYXRlO1xudmFyIG1lcmdlID0gc2NoZW1hLnV0aWwubWVyZ2U7XG5cbnNjaGVtYS5NQVhCSU5TX0RFRkFVTFQgPSAxNTtcblxudmFyIGJpbiA9IHtcbiAgdHlwZTogWydib29sZWFuJywgJ29iamVjdCddLFxuICBkZWZhdWx0OiBmYWxzZSxcbiAgcHJvcGVydGllczoge1xuICAgIG1heGJpbnM6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFQsXG4gICAgICBtaW5pbXVtOiAyXG4gICAgfVxuICB9LFxuICBzdXBwb3J0ZWRUeXBlczogeydRJzogdHJ1ZX0gLy8gVE9ETzogYWRkICdPJyBhZnRlciBmaW5pc2hpbmcgIzgxXG59O1xuXG52YXIgdHlwaWNhbEZpZWxkID0gbWVyZ2UoY2xvbmUoc2NoZW1hLmZpZWxkKSwge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydPJywgJ1EnLCAnVCddXG4gICAgfSxcbiAgICBhZ2dyOiBzY2hlbWEuYWdncixcbiAgICBmbjogc2NoZW1hLmZuLFxuICAgIGJpbjogYmluLFxuICAgIHNjYWxlOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdHlwZTogc2NoZW1hLnNjYWxlX3R5cGUsXG4gICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHsnUSc6IHRydWUsICdUJzogdHJ1ZX1cbiAgICAgICAgfSxcbiAgICAgICAgemVybzoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0luY2x1ZGUgemVybycsXG4gICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczogeydRJzogdHJ1ZSwgJ1QnOiB0cnVlfVxuICAgICAgICB9LFxuICAgICAgICBuaWNlOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydzZWNvbmQnLCAnbWludXRlJywgJ2hvdXInLCAnZGF5JywgJ3dlZWsnLCAnbW9udGgnLCAneWVhciddLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB7J1QnOiB0cnVlfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59KTtcblxudmFyIG9ubHlPcmRpbmFsRmllbGQgPSBtZXJnZShjbG9uZShzY2hlbWEuZmllbGQpLCB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgZGltZW5zaW9uOiB0cnVlXG4gIH0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0eXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnTycsJ1EnLCAnVCddIC8vIG9yZGluYWwtb25seSBmaWVsZCBzdXBwb3J0cyBRIHdoZW4gYmluIGlzIGFwcGxpZWQgYW5kIFQgd2hlbiBmbiBpcyBhcHBsaWVkLlxuICAgIH0sXG4gICAgZm46IHNjaGVtYS5mbixcbiAgICBiaW46IGJpbixcbiAgICBhZ2dyOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnY291bnQnXSxcbiAgICAgIHN1cHBvcnRlZFR5cGVzOiB7J08nOiB0cnVlfVxuICAgIH1cbiAgfVxufSk7XG5cbnZhciBheGlzTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBheGlzOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgZ3JpZDoge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSBmbGFnIGluZGljYXRlIGlmIGdyaWRsaW5lcyBzaG91bGQgYmUgY3JlYXRlZCBpbiBhZGRpdGlvbiB0byB0aWNrcy4nXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIHRpdGxlIGZvciB0aGUgYXhpcy4nXG4gICAgICAgIH0sXG4gICAgICAgIHRpdGxlT2Zmc2V0OiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgIC8vIGF1dG9cbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0EgdGl0bGUgb2Zmc2V0IHZhbHVlIGZvciB0aGUgYXhpcy4nXG4gICAgICAgIH0sXG4gICAgICAgIGZvcm1hdDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgIC8vIGF1dG9cbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RoZSBmb3JtYXR0aW5nIHBhdHRlcm4gZm9yIGF4aXMgbGFiZWxzLidcbiAgICAgICAgfSxcbiAgICAgICAgbWF4TGFiZWxMZW5ndGg6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogMjUsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RydW5jYXRlIGxhYmVscyB0aGF0IGFyZSB0b28gbG9uZy4nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzb3J0TWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgc29ydDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGRlZmF1bHQ6IFtdLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICAgIHN1cHBvcnRlZFR5cGVzOiB7J08nOiB0cnVlfSxcbiAgICAgICAgcmVxdWlyZWQ6IFsnbmFtZScsICdhZ2dyJ10sXG4gICAgICAgIG5hbWU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgICAgICB9LFxuICAgICAgICBhZ2dyOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZW51bTogWydhdmcnLCAnc3VtJywgJ21pbicsICdtYXgnLCAnY291bnQnXVxuICAgICAgICB9LFxuICAgICAgICByZXZlcnNlOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IGZhbHNlXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBiYW5kTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgYmFuZDogc2NoZW1hLmJhbmRcbiAgfVxufTtcblxudmFyIGxlZ2VuZE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIGxlZ2VuZDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZVxuICAgIH1cbiAgfVxufTtcblxudmFyIHRleHRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczogeyd0ZXh0JzogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB0ZXh0OiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgYWxpZ246IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnbGVmdCdcbiAgICAgICAgfSxcbiAgICAgICAgYmFzZWxpbmU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnbWlkZGxlJ1xuICAgICAgICB9LFxuICAgICAgICBtYXJnaW46IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogNCxcbiAgICAgICAgICBtaW5pbXVtOiAwXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZvbnQ6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB3ZWlnaHQ6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ25vcm1hbCcsICdib2xkJ10sXG4gICAgICAgICAgZGVmYXVsdDogJ25vcm1hbCdcbiAgICAgICAgfSxcbiAgICAgICAgc2l6ZToge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiAxMCxcbiAgICAgICAgICBtaW5pbXVtOiAwXG4gICAgICAgIH0sXG4gICAgICAgIGZhbWlseToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdIZWx2ZXRpY2EgTmV1ZSdcbiAgICAgICAgfSxcbiAgICAgICAgc3R5bGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJyxcbiAgICAgICAgICBlbnVtOiBbJ25vcm1hbCcsICdpdGFsaWMnXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgc2l6ZU1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIGJhcjogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsIHRleHQ6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDMwLFxuICAgICAgbWluaW11bTogMFxuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbG9yTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgJ3RleHQnOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAnc3RlZWxibHVlJ1xuICAgIH0sXG4gICAgc2NhbGU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByYW5nZToge1xuICAgICAgICAgIHR5cGU6IFsnc3RyaW5nJywgJ2FycmF5J11cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGFscGhhTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgJ3RleHQnOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZCwgIC8vIGF1dG9cbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxXG4gICAgfVxuICB9XG59O1xuXG52YXIgc2hhcGVNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2NpcmNsZScsICdzcXVhcmUnLCAnY3Jvc3MnLCAnZGlhbW9uZCcsICd0cmlhbmdsZS11cCcsICd0cmlhbmdsZS1kb3duJ10sXG4gICAgICBkZWZhdWx0OiAnY2lyY2xlJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGRldGFpbE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGxpbmU6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfVxufTtcblxudmFyIHJvd01peGluID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgaGVpZ2h0OiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZWZhdWx0OiAxNTBcbiAgICB9LFxuICAgIGdyaWQ6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ0EgZmxhZyBpbmRpY2F0ZSBpZiBncmlkbGluZXMgc2hvdWxkIGJlIGNyZWF0ZWQgaW4gYWRkaXRpb24gdG8gdGlja3MuJ1xuICAgIH0sXG4gIH1cbn07XG5cbnZhciBjb2xNaXhpbiA9IHtcbiAgcHJvcGVydGllczoge1xuICAgIHdpZHRoOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBkZWZhdWx0OiAxNTBcbiAgICB9LFxuICAgIGF4aXM6IHtcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgbWF4TGFiZWxMZW5ndGg6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogMTIsXG4gICAgICAgICAgbWluaW11bTogMCxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1RydW5jYXRlIGxhYmVscyB0aGF0IGFyZSB0b28gbG9uZy4nXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBmYWNldE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIHRpY2s6IHRydWUsIGJhcjogdHJ1ZSwgbGluZTogdHJ1ZSwgYXJlYTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWUsIHRleHQ6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgcGFkZGluZzoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgbWF4aW11bTogMSxcbiAgICAgIGRlZmF1bHQ6IDAuMVxuICAgIH1cbiAgfVxufTtcblxudmFyIHJlcXVpcmVkTmFtZVR5cGUgPSB7XG4gIHJlcXVpcmVkOiBbJ25hbWUnLCAndHlwZSddXG59O1xuXG52YXIgbXVsdGlSb2xlRmllbGQgPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCB7XG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIGRpbWVuc2lvbjogdHJ1ZVxuICB9XG59KTtcblxudmFyIHF1YW50aXRhdGl2ZUZpZWxkID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwge1xuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBkaW1lbnNpb246ICdvcmRpbmFsLW9ubHknIC8vIHVzaW5nIGFscGhhIC8gc2l6ZSB0byBlbmNvZGluZyBjYXRlZ29yeSBsZWFkIHRvIG9yZGVyIGludGVycHJldGF0aW9uXG4gIH1cbn0pO1xuXG52YXIgb25seVF1YW50aXRhdGl2ZUZpZWxkID0gbWVyZ2UoY2xvbmUodHlwaWNhbEZpZWxkKSwge1xuICBzdXBwb3J0ZWRSb2xlOiB7XG4gICAgbWVhc3VyZTogdHJ1ZVxuICB9XG59KTtcblxudmFyIHggPSBtZXJnZShjbG9uZShtdWx0aVJvbGVGaWVsZCksIGF4aXNNaXhpbiwgYmFuZE1peGluLCByZXF1aXJlZE5hbWVUeXBlLCBzb3J0TWl4aW4pO1xudmFyIHkgPSBjbG9uZSh4KTtcblxudmFyIGZhY2V0ID0gbWVyZ2UoY2xvbmUob25seU9yZGluYWxGaWVsZCksIHJlcXVpcmVkTmFtZVR5cGUsIGZhY2V0TWl4aW4sIHNvcnRNaXhpbik7XG52YXIgcm93ID0gbWVyZ2UoY2xvbmUoZmFjZXQpLCBheGlzTWl4aW4sIHJvd01peGluKTtcbnZhciBjb2wgPSBtZXJnZShjbG9uZShmYWNldCksIGF4aXNNaXhpbiwgY29sTWl4aW4pO1xuXG52YXIgc2l6ZSA9IG1lcmdlKGNsb25lKHF1YW50aXRhdGl2ZUZpZWxkKSwgbGVnZW5kTWl4aW4sIHNpemVNaXhpbiwgc29ydE1peGluKTtcbnZhciBjb2xvciA9IG1lcmdlKGNsb25lKG11bHRpUm9sZUZpZWxkKSwgbGVnZW5kTWl4aW4sIGNvbG9yTWl4aW4sIHNvcnRNaXhpbik7XG52YXIgYWxwaGEgPSBtZXJnZShjbG9uZShxdWFudGl0YXRpdmVGaWVsZCksIGFscGhhTWl4aW4sIHNvcnRNaXhpbik7XG52YXIgc2hhcGUgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgbGVnZW5kTWl4aW4sIHNoYXBlTWl4aW4sIHNvcnRNaXhpbik7XG52YXIgZGV0YWlsID0gbWVyZ2UoY2xvbmUob25seU9yZGluYWxGaWVsZCksIGRldGFpbE1peGluLCBzb3J0TWl4aW4pO1xuXG4vLyB3ZSBvbmx5IHB1dCBhZ2dyZWdhdGVkIG1lYXN1cmUgaW4gcGl2b3QgdGFibGVcbnZhciB0ZXh0ID0gbWVyZ2UoY2xvbmUob25seVF1YW50aXRhdGl2ZUZpZWxkKSwgdGV4dE1peGluLCBzb3J0TWl4aW4pO1xuXG4vLyBUT0RPIGFkZCBsYWJlbFxuXG52YXIgZmlsdGVyID0ge1xuICB0eXBlOiAnYXJyYXknLFxuICBpdGVtczoge1xuICAgIHR5cGU6ICdvYmplY3QnLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIG9wZXJhbmRzOiB7XG4gICAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICAgIGl0ZW1zOiB7XG4gICAgICAgICAgdHlwZTogWydzdHJpbmcnLCAnYm9vbGVhbicsICdpbnRlZ2VyJywgJ251bWJlciddXG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBvcGVyYXRvcjoge1xuICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgZW51bTogWyc+JywgJz49JywgJz0nLCAnIT0nLCAnPCcsICc8PScsICdub3ROdWxsJ11cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBkYXRhID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgcHJvcGVydGllczoge1xuICAgIC8vIGRhdGEgc291cmNlXG4gICAgZm9ybWF0VHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ2pzb24nLCAnY3N2J10sXG4gICAgICBkZWZhdWx0OiAnanNvbidcbiAgICB9LFxuICAgIHVybDoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIHZlZ2FTZXJ2ZXI6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgZGVmYXVsdDogbnVsbCxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgdGFibGU6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICAgICAgfSxcbiAgICAgICAgdXJsOiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ2h0dHA6Ly9sb2NhbGhvc3Q6MzAwMSdcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGNvbmZpZyA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICAvLyB0ZW1wbGF0ZVxuICAgIHdpZHRoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGhlaWdodDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICB2aWV3cG9ydDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6ICdpbnRlZ2VyJ1xuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgZ3JpZENvbG9yOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAnI2VlZWVlZSdcbiAgICB9LFxuXG4gICAgLy8gZmlsdGVyIG51bGxcbiAgICBmaWx0ZXJOdWxsOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgTzoge3R5cGU6J2Jvb2xlYW4nLCBkZWZhdWx0OiBmYWxzZX0sXG4gICAgICAgIFE6IHt0eXBlOidib29sZWFuJywgZGVmYXVsdDogdHJ1ZX0sXG4gICAgICAgIFQ6IHt0eXBlOidib29sZWFuJywgZGVmYXVsdDogdHJ1ZX1cbiAgICAgIH1cbiAgICB9LFxuICAgIHRvZ2dsZVNvcnQ6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZGVmYXVsdDogJ08nXG4gICAgfSxcblxuICAgIC8vIHNpbmdsZSBwbG90XG4gICAgc2luZ2xlSGVpZ2h0OiB7XG4gICAgICAvLyB3aWxsIGJlIG92ZXJ3cml0dGVuIGJ5IGJhbmRXaWR0aCAqIChjYXJkaW5hbGl0eSArIHBhZGRpbmcpXG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMDAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBzaW5nbGVXaWR0aDoge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBiYW5kV2lkdGggKiAoY2FyZGluYWxpdHkgKyBwYWRkaW5nKVxuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjAwLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgLy8gYmFuZCBzaXplXG4gICAgbGFyZ2VCYW5kU2l6ZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjEsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBzbWFsbEJhbmRTaXplOiB7XG4gICAgICAvL3NtYWxsIG11bHRpcGxlcyBvciBzaW5nbGUgcGxvdCB3aXRoIGhpZ2ggY2FyZGluYWxpdHlcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDEyLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgbGFyZ2VCYW5kTWF4Q2FyZGluYWxpdHk6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDEwXG4gICAgfSxcbiAgICAvLyBzbWFsbCBtdWx0aXBsZXNcbiAgICBjZWxsUGFkZGluZzoge1xuICAgICAgdHlwZTogJ251bWJlcicsXG4gICAgICBkZWZhdWx0OiAwLjFcbiAgICB9LFxuICAgIGNlbGxHcmlkQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICcjYWFhYWFhJ1xuICAgIH0sXG4gICAgY2VsbEJhY2tncm91bmRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJ3RyYW5zcGFyZW50J1xuICAgIH0sXG4gICAgdGV4dENlbGxXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogOTAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcblxuICAgIC8vIG1hcmtzXG4gICAgc3Ryb2tlV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcblxuICAgIC8vIHNjYWxlc1xuICAgIHRpbWVTY2FsZUxhYmVsTGVuZ3RoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAzLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgLy8gb3RoZXJcbiAgICBjaGFyYWN0ZXJXaWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNlxuICAgIH1cbiAgfVxufTtcblxuLyoqIEB0eXBlIE9iamVjdCBTY2hlbWEgb2YgYSB2ZWdhbGl0ZSBzcGVjaWZpY2F0aW9uICovXG5zY2hlbWEuc2NoZW1hID0ge1xuICAkc2NoZW1hOiAnaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNC9zY2hlbWEjJyxcbiAgZGVzY3JpcHRpb246ICdTY2hlbWEgZm9yIHZlZ2FsaXRlIHNwZWNpZmljYXRpb24nLFxuICB0eXBlOiAnb2JqZWN0JyxcbiAgcmVxdWlyZWQ6IFsnbWFya3R5cGUnLCAnZW5jJywgJ2RhdGEnLCAnY29uZmlnJ10sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBkYXRhOiBkYXRhLFxuICAgIG1hcmt0eXBlOiBzY2hlbWEubWFya3R5cGUsXG4gICAgZW5jOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgIHByb3BlcnRpZXM6IHtcbiAgICAgICAgeDogeCxcbiAgICAgICAgeTogeSxcbiAgICAgICAgcm93OiByb3csXG4gICAgICAgIGNvbDogY29sLFxuICAgICAgICBzaXplOiBzaXplLFxuICAgICAgICBjb2xvcjogY29sb3IsXG4gICAgICAgIGFscGhhOiBhbHBoYSxcbiAgICAgICAgc2hhcGU6IHNoYXBlLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBkZXRhaWw6IGRldGFpbFxuICAgICAgfVxuICAgIH0sXG4gICAgZmlsdGVyOiBmaWx0ZXIsXG4gICAgY29uZmlnOiBjb25maWdcbiAgfVxufTtcblxuc2NoZW1hLmVuY1R5cGVzID0gdXRpbC5rZXlzKHNjaGVtYS5zY2hlbWEucHJvcGVydGllcy5lbmMucHJvcGVydGllcyk7XG5cbi8qKiBJbnN0YW50aWF0ZSBhIHZlcmJvc2Ugdmwgc3BlYyBmcm9tIHRoZSBzY2hlbWEgKi9cbnNjaGVtYS5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gc2NoZW1hLnV0aWwuaW5zdGFudGlhdGUoc2NoZW1hLnNjaGVtYSk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgc2NoZW1hdXRpbCA9IG1vZHVsZS5leHBvcnRzID0ge30sXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBpc0VtcHR5ID0gZnVuY3Rpb24ob2JqKSB7XG4gIHJldHVybiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbn07XG5cbnNjaGVtYXV0aWwuZXh0ZW5kID0gZnVuY3Rpb24oaW5zdGFuY2UsIHNjaGVtYSkge1xuICByZXR1cm4gc2NoZW1hdXRpbC5tZXJnZShzY2hlbWF1dGlsLmluc3RhbnRpYXRlKHNjaGVtYSksIGluc3RhbmNlKTtcbn07XG5cbi8vIGluc3RhbnRpYXRlIGEgc2NoZW1hXG5zY2hlbWF1dGlsLmluc3RhbnRpYXRlID0gZnVuY3Rpb24oc2NoZW1hKSB7XG4gIHZhciB2YWw7XG4gIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH0gZWxzZSBpZiAoJ2RlZmF1bHQnIGluIHNjaGVtYSkge1xuICAgIHZhbCA9IHNjaGVtYS5kZWZhdWx0O1xuICAgIHJldHVybiB1dGlsLmlzT2JqZWN0KHZhbCkgPyB1dGlsLmR1cGxpY2F0ZSh2YWwpIDogdmFsO1xuICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHZhciBpbnN0YW5jZSA9IHt9O1xuICAgIGZvciAodmFyIG5hbWUgaW4gc2NoZW1hLnByb3BlcnRpZXMpIHtcbiAgICAgIHZhbCA9IHNjaGVtYXV0aWwuaW5zdGFudGlhdGUoc2NoZW1hLnByb3BlcnRpZXNbbmFtZV0pO1xuICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluc3RhbmNlW25hbWVdID0gdmFsO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zdGFuY2U7XG4gIH0gZWxzZSBpZiAoc2NoZW1hLnR5cGUgPT09ICdhcnJheScpIHtcbiAgICByZXR1cm4gW107XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbi8vIHJlbW92ZSBhbGwgZGVmYXVsdHMgZnJvbSBhbiBpbnN0YW5jZVxuc2NoZW1hdXRpbC5zdWJ0cmFjdCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBkZWZhdWx0cykge1xuICB2YXIgY2hhbmdlcyA9IHt9O1xuICBmb3IgKHZhciBwcm9wIGluIGluc3RhbmNlKSB7XG4gICAgdmFyIGRlZiA9IGRlZmF1bHRzW3Byb3BdO1xuICAgIHZhciBpbnMgPSBpbnN0YW5jZVtwcm9wXTtcbiAgICAvLyBOb3RlOiBkb2VzIG5vdCBwcm9wZXJseSBzdWJ0cmFjdCBhcnJheXNcbiAgICBpZiAoIWRlZmF1bHRzIHx8IGRlZiAhPT0gaW5zKSB7XG4gICAgICBpZiAodHlwZW9mIGlucyA9PT0gJ29iamVjdCcgJiYgIXV0aWwuaXNBcnJheShpbnMpICYmIGRlZikge1xuICAgICAgICB2YXIgYyA9IHNjaGVtYXV0aWwuc3VidHJhY3QoaW5zLCBkZWYpO1xuICAgICAgICBpZiAoIWlzRW1wdHkoYykpXG4gICAgICAgICAgY2hhbmdlc1twcm9wXSA9IGM7XG4gICAgICB9IGVsc2UgaWYgKCF1dGlsLmlzQXJyYXkoaW5zKSB8fCBpbnMubGVuZ3RoID4gMCkge1xuICAgICAgICBjaGFuZ2VzW3Byb3BdID0gaW5zO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hhbmdlcztcbn07XG5cbnNjaGVtYXV0aWwubWVyZ2UgPSBmdW5jdGlvbigvKmRlc3QqLCBzcmMwLCBzcmMxLCAuLi4qLyl7XG4gIHZhciBkZXN0ID0gYXJndW1lbnRzWzBdO1xuICBmb3IgKHZhciBpPTEgOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGRlc3QgPSBtZXJnZShkZXN0LCBhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiBkZXN0O1xufTtcblxuLy8gcmVjdXJzaXZlbHkgbWVyZ2VzIHNyYyBpbnRvIGRlc3RcbmZ1bmN0aW9uIG1lcmdlKGRlc3QsIHNyYykge1xuICBpZiAodHlwZW9mIHNyYyAhPT0gJ29iamVjdCcgfHwgc3JjID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGRlc3Q7XG4gIH1cblxuICBmb3IgKHZhciBwIGluIHNyYykge1xuICAgIGlmICghc3JjLmhhc093blByb3BlcnR5KHApKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHNyY1twXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBzcmNbcF0gIT09ICdvYmplY3QnIHx8IHNyY1twXSA9PT0gbnVsbCkge1xuICAgICAgZGVzdFtwXSA9IHNyY1twXTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBkZXN0W3BdICE9PSAnb2JqZWN0JyB8fCBkZXN0W3BdID09PSBudWxsKSB7XG4gICAgICBkZXN0W3BdID0gbWVyZ2Uoc3JjW3BdLmNvbnN0cnVjdG9yID09PSBBcnJheSA/IFtdIDoge30sIHNyY1twXSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG1lcmdlKGRlc3RbcF0sIHNyY1twXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkZXN0O1xufSIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL3V0aWwnKTtcblxudXRpbC5leHRlbmQodXRpbCwgcmVxdWlyZSgnZGF0YWxpYi9zcmMvZ2VuZXJhdGUnKSk7XG51dGlsLmJpbiA9IHJlcXVpcmUoJ2RhdGFsaWIvc3JjL2JpbicpO1xuXG51dGlsLmlzaW4gPSBmdW5jdGlvbihpdGVtLCBhcnJheSkge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59O1xuXG51dGlsLmZvckVhY2ggPSBmdW5jdGlvbihvYmosIGYsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5mb3JFYWNoKSB7XG4gICAgb2JqLmZvckVhY2guY2FsbCh0aGlzQXJnLCBmKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKHZhciBrIGluIG9iaikge1xuICAgICAgZi5jYWxsKHRoaXNBcmcsIG9ialtrXSwgayAsIG9iaik7XG4gICAgfVxuICB9XG59O1xuXG51dGlsLmdldGJpbnMgPSBmdW5jdGlvbihzdGF0cywgbWF4Ymlucykge1xuICByZXR1cm4gdXRpbC5iaW4oe1xuICAgIG1pbjogc3RhdHMubWluLFxuICAgIG1heDogc3RhdHMubWF4LFxuICAgIG1heGJpbnM6IG1heGJpbnNcbiAgfSk7XG59O1xuXG4vKipcbiAqIHhbcFswXV0uLi5bcFtuXV0gPSB2YWxcbiAqIEBwYXJhbSBub2F1Z21lbnQgZGV0ZXJtaW5lIHdoZXRoZXIgbmV3IG9iamVjdCBzaG91bGQgYmUgYWRkZWQgZlxuICogb3Igbm9uLWV4aXN0aW5nIHByb3BlcnRpZXMgYWxvbmcgdGhlIHBhdGhcbiAqL1xudXRpbC5zZXR0ZXIgPSBmdW5jdGlvbih4LCBwLCB2YWwsIG5vYXVnbWVudCkge1xuICBmb3IgKHZhciBpPTA7IGk8cC5sZW5ndGgtMTsgKytpKSB7XG4gICAgaWYgKCFub2F1Z21lbnQgJiYgIShwW2ldIGluIHgpKXtcbiAgICAgIHggPSB4W3BbaV1dID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4W3BbaV1dO1xuICAgIH1cbiAgfVxuICB4W3BbaV1dID0gdmFsO1xufTtcblxuXG4vKipcbiAqIHJldHVybnMgeFtwWzBdXS4uLltwW25dXVxuICogQHBhcmFtIGF1Z21lbnQgZGV0ZXJtaW5lIHdoZXRoZXIgbmV3IG9iamVjdCBzaG91bGQgYmUgYWRkZWQgZlxuICogb3Igbm9uLWV4aXN0aW5nIHByb3BlcnRpZXMgYWxvbmcgdGhlIHBhdGhcbiAqL1xudXRpbC5nZXR0ZXIgPSBmdW5jdGlvbih4LCBwLCBub2F1Z21lbnQpIHtcbiAgZm9yICh2YXIgaT0wOyBpPHAubGVuZ3RoOyArK2kpIHtcbiAgICBpZiAoIW5vYXVnbWVudCAmJiAhKHBbaV0gaW4geCkpe1xuICAgICAgeCA9IHhbcFtpXV0gPSB7fTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHhbcFtpXV07XG4gICAgfVxuICB9XG4gIHJldHVybiB4O1xufTtcblxudXRpbC5lcnJvciA9IGZ1bmN0aW9uKG1zZykge1xuICBjb25zb2xlLmVycm9yKCdbVkwgRXJyb3JdJywgbXNnKTtcbn07XG5cbiJdfQ==\n","// shim for using process in browser\n\nvar process = module.exports = {};\nvar queue = [];\nvar draining = false;\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    draining = true;\n    var currentQueue;\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        var i = -1;\n        while (++i < len) {\n            currentQueue[i]();\n        }\n        len = queue.length;\n    }\n    draining = false;\n}\nprocess.nextTick = function (fun) {\n    queue.push(fun);\n    if (!draining) {\n        setTimeout(drainQueue, 0);\n    }\n};\n\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\n// TODO(shtylman)\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","var util = require('./util');\nvar units = require('./date-units');\nvar EPSILON = 1e-15;\n\nfunction bin(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 15,\n      base = opt.base || 10,\n      logb = Math.log(base),\n      div = opt.div || [5, 2],      \n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step, logb, level, minstep, precision, v, i, eps;\n\n  if (opt.step != null) {\n    // if step size is explicitly given, use that\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n      opt.steps.length - 1,\n      bisect(opt.steps, span/maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // else use span to determine step size\n    level = Math.ceil(Math.log(maxb) / logb);\n    minstep = opt.minstep || 0;\n    step = Math.max(\n      minstep,\n      Math.pow(base, Math.round(Math.log(span) / logb) - level)\n    );\n    \n    // increase step size if too many bins\n    do { step *= base; } while (Math.ceil(span/step) > maxb);\n\n    // decrease step size if allowed\n    for (i=0; i<div.length; ++i) {\n      v = step / div[i];\n      if (v >= minstep && span / v <= maxb) step = v;\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop:  max,\n    step:  step,\n    unit:  {precision: precision},\n    value: value,\n    index: index\n  };\n};\n\nfunction bisect(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n};\n\nfunction value(v) {\n  return this.step * Math.floor(v / this.step + EPSILON);\n}\n\nfunction index(v) {\n  return Math.floor((v - this.start) / this.step + EPSILON);\n}\n\nfunction date_value(v) {\n  return this.unit.date(value.call(this, v));\n}\n\nfunction date_index(v) {\n  return index.call(this, this.unit.unit(v));\n}\n\nbin.date = function(opt) {\n  opt = opt || {};\n\n  // find time step, then bin\n  var dmin = opt.min,\n      dmax = opt.max,\n      maxb = opt.maxbins || 20,\n      minb = opt.minbins || 4,\n      span = (+dmax) - (+dmin);\n      unit = opt.unit ? units[opt.unit] : units.find(span, minb, maxb),\n      bins = bin({\n        min:     unit.min != null ? unit.min : unit.unit(dmin),\n        max:     unit.max != null ? unit.max : unit.unit(dmax),\n        maxbins: maxb,\n        minstep: unit.minstep,\n        steps:   unit.step\n      });\n\n  bins.unit = unit;\n  bins.index = date_index;\n  if (!opt.raw) bins.value = date_value;\n  return bins;\n};\n\nmodule.exports = bin;\n","var util = require('./util');\n\nvar STEPS = [\n  [31536e6, 5],  // 1-year\n  [7776e6, 4],   // 3-month\n  [2592e6, 4],   // 1-month\n  [12096e5, 3],  // 2-week\n  [6048e5, 3],   // 1-week\n  [1728e5, 3],   // 2-day\n  [864e5, 3],    // 1-day\n  [432e5, 2],    // 12-hour\n  [216e5, 2],    // 6-hour\n  [108e5, 2],    // 3-hour\n  [36e5, 2],     // 1-hour\n  [18e5, 1],     // 30-minute\n  [9e5, 1],      // 15-minute\n  [3e5, 1],      // 5-minute\n  [6e4, 1],      // 1-minute\n  [3e4, 0],      // 30-second\n  [15e3, 0],     // 15-second\n  [5e3, 0],      // 5-second\n  [1e3, 0]       // 1-second\n];\n\nvar entries = [\n  {\n    type: \"second\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M:%S.%L\",\n    date: function(d) {\n      return new Date(d * 1e3);\n    },\n    unit: function(d) {\n      return (+d / 1e3);\n    }\n  },\n  {\n    type: \"minute\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:%M\",\n    date: function(d) {\n      return new Date(d * 6e4);\n    },\n    unit: function(d) {\n      return ~~(+d / 6e4);\n    }\n  },\n  {\n    type: \"hour\",\n    minstep: 1,\n    format: \"%Y %b %-d %H:00\",\n    date: function(d) {\n      return new Date(d * 36e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 36e5);\n    }\n  },\n  {\n    type: \"day\",\n    minstep: 1,\n    step: [1, 7],\n    format: \"%Y %b %-d\",\n    date: function(d) {\n      return new Date(d * 864e5);\n    },\n    unit: function(d) {\n      return ~~(+d / 864e5);\n    }\n  },\n  {\n    type: \"month\",\n    minstep: 1,\n    step: [1, 3, 6],\n    format: \"%b %Y\",\n    date: function(d) {\n      return new Date(Date.UTC(~~(d / 12), d % 12, 1));\n    },\n    unit: function(d) {\n      if (util.isNumber(d)) d = new Date(d);\n      return 12 * d.getUTCFullYear() + d.getUTCMonth();\n    }\n  },\n  {\n    type: \"year\",\n    minstep: 1,\n    format: \"%Y\",\n    date: function(d) {\n      return new Date(Date.UTC(d, 0, 1));\n    },\n    unit: function(d) {\n      return (util.isNumber(d) ? new Date(d) : d).getUTCFullYear();\n    }\n  }\n];\n\nvar minuteOfHour = {\n  type: \"minuteOfHour\",\n  min: 0,\n  max: 59,\n  minstep: 1,\n  format: \"%M\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMinutes();\n  }\n};\n\nvar hourOfDay = {\n  type: \"hourOfDay\",\n  min: 0,\n  max: 23,\n  minstep: 1,\n  format: \"%H\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 1, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCHours();\n  }\n};\n\nvar dayOfWeek = {\n  type: \"dayOfWeek\",\n  min: 0,\n  max: 6,\n  step: [1],\n  format: \"%a\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, 4 + d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDay();\n  }\n};\n\nvar dayOfMonth = {\n  type: \"dayOfMonth\",\n  min: 1,\n  max: 31,\n  step: [1],\n  format: \"%-d\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, 0, d));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCDate();\n  }\n};\n\nvar monthOfYear = {\n  type: \"monthOfYear\",\n  min: 0,\n  max: 11,\n  step: [1],\n  format: \"%b\",\n  date: function(d) {\n    return new Date(Date.UTC(1970, d % 12, 1));\n  },\n  unit: function(d) {\n    return (util.isNumber(d) ? new Date(d) : d).getUTCMonth();\n  }\n};\n\nvar units = {\n  \"second\":       entries[0],\n  \"minute\":       entries[1],\n  \"hour\":         entries[2],\n  \"day\":          entries[3],\n  \"month\":        entries[4],\n  \"year\":         entries[5],\n  \"minuteOfHour\": minuteOfHour,\n  \"hourOfDay\":    hourOfDay,\n  \"dayOfWeek\":    dayOfWeek,\n  \"dayOfMonth\":   dayOfMonth,\n  \"monthOfYear\":  monthOfYear,\n  \"timesteps\":    entries\n};\n\nunits.find = function(span, minb, maxb) {\n  var i, len, bins, step = STEPS[0];\n\n  for (i = 1, len = STEPS.length; i < len; ++i) {\n    step = STEPS[i];\n    if (span > step[0]) {\n      bins = span / step[0];\n      if (bins > maxb) {\n        return entries[STEPS[i - 1][1]];\n      }\n      if (bins >= minb) {\n        return entries[step[1]];\n      }\n    }\n  }\n  return entries[STEPS[STEPS.length - 1][1]];\n};\n\nmodule.exports = units;\n","var gen = module.exports = {};\n\ngen.repeat = function(val, n) {\n  var a = Array(n), i;\n  for (i=0; i<n; ++i) a[i] = val;\n  return a;\n};\n\ngen.zeros = function(n) {\n  return gen.repeat(0, n);\n};\n\ngen.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('Infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\ngen.random = {};\n\ngen.random.uniform = function(min, max) {\n  if (max === undefined) {\n\t\tmax = min;\n\t\tmin = 0;\n\t}\n\tvar d = max - min;\n\tvar f = function() {\n\t\treturn min + d * Math.random();\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.integer = function(a, b) {\n\tif (b === undefined) {\n\t\tb = a;\n\t\ta = 0;\n\t}\n  var d = b - a;\n\tvar f = function() {\n\t\treturn a + Math.floor(d * Math.random());\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};\n\ngen.random.normal = function(mean, stdev) {\n\tmean = mean || 0;\n\tstdev = stdev || 1;\n\tvar next = undefined;\n\tvar f = function() {\n\t\tvar x = 0, y = 0, rds, c;\n\t\tif (next !== undefined) {\n\t\t\tx = next;\n\t\t\tnext = undefined;\n\t\t\treturn x;\n\t\t}\n\t\tdo {\n\t\t\tx = Math.random()*2-1;\n\t\t\ty = Math.random()*2-1;\n\t\t\trds = x*x + y*y;\n\t\t} while (rds == 0 || rds > 1);\n\t\tc = Math.sqrt(-2*Math.log(rds)/rds); // Box-Muller transform\n\t\tnext = mean + y*c*stdev;\n\t\treturn mean + x*c*stdev;\n\t};\n\tf.samples = function(n) { return gen.zeros(n).map(f); };\n\treturn f;\n};","var stats = require('./stats');\nvar util = require('./util');\nvar bin = require('./bin');\nvar gen = require('./generate');\n\nmodule.exports = function(values, f, options) {\n  if (options === undefined && !util.isFunction(f)) { options = f; f = null; }\n\n  var type = options && options.type || infer(values, f);\n  if (type !== 'number' && type !== 'date' && type !== 'integer') {\n    return categorical(values, f, options && options.sort);\n  }\n\n  var ext = stats.extent(values, f),\n      opt = util.extend({min: ext[0], max: ext[1]}, options);\n  if (type === 'integer' && opt.minstep == null) opt.minstep = 1;\n  var b = type === 'date' ? bin.date(opt) : bin(opt);\n  return numerical(values, f, b);\n};\n\nfunction infer(values, f) {\n  var v = null, i;\n\n  // if data array has type annotations, use them\n  if (values.types) {\n    v = f(values.types);\n    if (util.isString(v)) return v;\n  }\n\n  for (i=0; !util.isNotNull(v) && i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n  }\n  return util.isDate(v) ? 'date' : util.isNumber(v) ? 'number' : 'string';\n}\n\nfunction numerical(values, f, b) {\n  var h = gen.range(b.start, b.stop + b.step/2, b.step)\n    .map(function(v) { return {value: b.value(v), count: 0}; });\n\n  for (var i=0, v, j; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (util.isNotNull(v)) {\n      j = b.index(v);\n      if (j < 0 || j >= h.length || !isFinite(j)) continue;\n      h[j].count += 1;\n    }\n  }\n  h.bins = b;\n  return h;\n}\n\nfunction categorical(values, f, sort) {\n  var c = stats.unique(values, f).counts;\n  return util.keys(c)\n    .map(function(k) { return {value: k, count: c[k]}; })\n    .sort(util.comparator(sort ? \"-count\" : \"+value\"));\n}","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.csv.parse(data ? data.toString() : data);\n  return d;\n};\n","module.exports = {\n  json: require('./json'),\n  csv: require('./csv'),\n  tsv: require('./tsv'),\n  topojson: require('./topojson'),\n  treejson: require('./treejson')\n};","var util = require('../../util');\n\nmodule.exports = function(data, format) {\n  var d = util.isObject(data) && !util.isBuffer(data)\n    ? data : JSON.parse(data);\n  if (format && format.property) {\n    d = util.accessor(format.property)(d);\n  }\n  return d;\n};\n","var json = require('./json');\nvar topojson = (typeof window !== \"undefined\" ? window.topojson : typeof global !== \"undefined\" ? global.topojson : null);\n\nmodule.exports = function(data, format) {\n  if (topojson == null) { throw Error(\"TopoJSON library not loaded.\"); }\n\n  var t = json(data, format), obj;\n\n  if (format && format.feature) {\n    if (obj = t.objects[format.feature]) {\n      return topojson.feature(t, obj).features\n    } else {\n      throw Error(\"Invalid TopoJSON object: \"+format.feature);\n    }\n  } else if (format && format.mesh) {\n    if (obj = t.objects[format.mesh]) {\n      return [topojson.mesh(t, t.objects[format.mesh])];\n    } else {\n      throw Error(\"Invalid TopoJSON object: \" + format.mesh);\n    }\n  } else {\n    throw Error(\"Missing TopoJSON feature or mesh parameter.\");\n  }\n\n  return [];\n};\n","var json = require('./json');\n\nmodule.exports = function(data, format) {\n  data = json(data, format);\n  return toTable(data, (format && format.children));\n};\n\nfunction toTable(root, childrenField) {\n  childrenField = childrenField || \"children\";\n  var table = [];\n  \n  function visit(node, parent) {\n    table.push(node);\n    var children = node[childrenField];\n    if (children) {\n      for (var i=0; i<children.length; ++i) {\n        visit(children[i], node);\n      }\n    }\n  }\n  \n  visit(root, null);\n  return (table.root = root, table);\n}","var d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nmodule.exports = function(data, format) {\n  var d = d3.tsv.parse(data ? data.toString() : data);\n  return d;\n};\n","var util = require('../util');\n\n// Matches absolute URLs with optional protocol\n//   https://...    file://...    //...\nvar protocol_re = /^([A-Za-z]+:)?\\/\\//;\n\n// Special treatment in node.js for the file: protocol\nvar fileProtocol = 'file://';\n\n// Validate and cleanup URL to ensure that it is allowed to be accessed\n// Returns cleaned up URL, or false if access is not allowed\nfunction sanitizeUrl(opt) {\n  var url = opt.url;\n  if (!url && opt.file) { return fileProtocol + opt.file; }\n\n  // In case this is a relative url (has no host), prepend opt.baseURL\n  if (opt.baseURL && !protocol_re.test(url)) {\n    if (!util.startsWith(url, '/') && opt.baseURL[opt.baseURL.length-1] !== '/') {\n      url = '/' + url; // Ensure that there is a slash between the baseURL (e.g. hostname) and url\n    }\n    url = opt.baseURL + url;\n  }\n  // relative protocol, starts with '//'\n  if (util.isNode && util.startsWith(url, '//')) {\n    url = (opt.defaultProtocol || 'http') + ':' + url;\n  }\n  // If opt.domainWhiteList is set, only allows url, whose hostname\n  // * Is the same as the origin (window.location.hostname)\n  // * Equals one of the values in the whitelist\n  // * Is a proper subdomain of one of the values in the whitelist\n  if (opt.domainWhiteList) {\n    var domain, origin;\n    if (util.isNode) {\n      // relative protocol is broken: https://github.com/defunctzombie/node-url/issues/5\n      var parts = require('url').parse(url);\n      domain = parts.hostname;\n      origin = null;\n    } else {\n      var a = document.createElement('a');\n      a.href = url;\n      // From http://stackoverflow.com/questions/736513/how-do-i-parse-a-url-into-hostname-and-path-in-javascript\n      // IE doesn't populate all link properties when setting .href with a relative URL,\n      // however .href will return an absolute URL which then can be used on itself\n      // to populate these additional fields.\n      if (a.host == \"\") {\n        a.href = a.href;\n      }\n      domain = a.hostname.toLowerCase();\n      origin = window.location.hostname;\n    }\n\n    if (origin !== domain) {\n      var whiteListed = opt.domainWhiteList.some(function (d) {\n        var idx = domain.length - d.length;\n        return d === domain ||\n          (idx > 1 && domain[idx-1] === '.' && domain.lastIndexOf(d) === idx);\n      });\n      if (!whiteListed) {\n        throw 'URL is not whitelisted: ' + url;\n      }\n    }\n  }\n  return url;\n}\n\nfunction load(opt, callback) {\n  var error = callback || function(e) { throw e; };\n  \n  try {\n    var url = load.sanitizeUrl(opt); // enable override\n  } catch (err) {\n    error(err);\n    return;\n  }\n\n  if (!url) {\n    error('Invalid URL: ' + url);\n  } else if (!util.isNode) {\n    // in browser, use xhr\n    return xhr(url, callback);\n  } else if (util.startsWith(url, fileProtocol)) {\n    // in node.js, if url starts with 'file://', strip it and load from file\n    return file(url.slice(fileProtocol.length), callback);\n  } else {\n    // for regular URLs in node.js\n    return http(url, callback);\n  }\n}\n\nfunction xhrHasResponse(request) {\n  var type = request.responseType;\n  return type && type !== \"text\"\n      ? request.response // null on error\n      : request.responseText; // \"\" on error\n}\n\nfunction xhr(url, callback) {\n  var async = !!callback;\n  var request = new XMLHttpRequest;\n  // If IE does not support CORS, use XDomainRequest (copied from d3.xhr)\n  if (this.XDomainRequest\n      && !(\"withCredentials\" in request)\n      && /^(http(s)?:)?\\/\\//.test(url)) request = new XDomainRequest;\n\n  function respond() {\n    var status = request.status;\n    if (!status && xhrHasResponse(request) || status >= 200 && status < 300 || status === 304) {\n      callback(null, request.responseText);\n    } else {\n      callback(request, null);\n    }\n  }\n\n  if (async) {\n    \"onload\" in request\n      ? request.onload = request.onerror = respond\n      : request.onreadystatechange = function() { request.readyState > 3 && respond(); };\n  }\n  \n  request.open(\"GET\", url, async);\n  request.send();\n  \n  if (!async && xhrHasResponse(request)) {\n    return request.responseText;\n  }\n}\n\nfunction file(file, callback) {\n  var fs = require('fs');\n  if (!callback) {\n    return fs.readFileSync(file, 'utf8');\n  }\n  require('fs').readFile(file, callback);\n}\n\nfunction http(url, callback) {\n  if (!callback) {\n    return require('sync-request')('GET', url).getBody();\n  }\n  require('request')(url, function(error, response, body) {\n    if (!error && response.statusCode === 200) {\n      callback(null, body);\n    } else {\n      callback(error, null);\n    }\n  });\n}\n\nload.sanitizeUrl = sanitizeUrl;\n\nmodule.exports = load;\n","var util = require('../util');\nvar load = require('./load');\nvar read = require('./read');\n\nmodule.exports = util\n  .keys(read.formats)\n  .reduce(function(out, type) {\n    out[type] = function(opt, format, callback) {\n      // process arguments\n      if (util.isString(opt)) opt = {url: opt};\n      if (arguments.length === 2 && util.isFunction(format)) {\n        callback = format;\n        format = undefined;\n      }\n\n      // set up read format\n      format = util.extend({parse: 'auto'}, format);\n      format.type = type;\n\n      // load data\n      var data = load(opt, callback ? function(error, data) {\n        if (error) callback(error, null);\n        try {\n          // data loaded, now parse it (async)\n          data = read(data, format);\n        } catch (e) {\n          callback(e, null);\n        }\n        callback(null, data);\n      } : undefined);\n      \n      // data loaded, now parse it (sync)\n      if (data) return read(data, format);\n    };\n    return out;\n  }, {});\n","var util = require('../util');\nvar formats = require('./formats');\n\nvar PARSERS = {\n  boolean: util.boolean,\n  integer: util.number,\n  number:  util.number,\n  date:    util.date,\n  string:  util.identity\n};\n\nvar TESTS = {\n  boolean: function(x) { return x===\"true\" || x===\"false\" || util.isBoolean(x); },\n  integer: function(x) { return TESTS.number(x) && (x=+x) === ~~x; },\n  number: function(x) { return !isNaN(+x) && !util.isDate(x); },\n  date: function(x) { return !isNaN(Date.parse(x)); }\n};\n\nfunction read(data, format) {\n  var type = (format && format.type) || \"json\";\n  data = formats[type](data, format);\n  if (format && format.parse) parse(data, format.parse);\n  return data;\n}\n\nfunction infer_type(values, f) {\n  var i, j, v;\n\n  // types to test for, in precedence order\n  var types = ['boolean', 'integer', 'number', 'date'];\n\n  for (i=0; i<values.length; ++i) {\n    // get next value to test\n    v = f ? f(values[i]) : values[i];\n    // test value against remaining types\n    for (j=0; j<types.length; ++j) {\n      if (util.isNotNull(v) && !TESTS[types[j]](v)) {\n        types.splice(j, 1);\n        j -= 1;\n      }\n    }\n    // if no types left, return 'string'\n    if (types.length === 0) return 'string';\n  }\n\n  return types[0];\n}\n\nfunction infer_types(data, fields) {\n  fields = fields || util.keys(data[0]);\n  return fields.reduce(function(types, f) {\n    var type = infer_type(data, util.accessor(f));\n    if (PARSERS[type]) types[f] = type;\n    return types;\n  }, {});\n}\n\nfunction parse(data, types) {\n  var cols, parsers, d, i, j, clen, len = data.length;\n\n  types = (types==='auto') ? infer_types(data) : util.duplicate(types);\n  cols = util.keys(types);\n  parsers = cols.map(function(c) { return PARSERS[types[c]]; });\n\n  for (i=0, clen=cols.length; i<len; ++i) {\n    d = data[i];\n    for (j=0; j<clen; ++j) {\n      d[cols[j]] = parsers[j](d[cols[j]]);\n    }\n  }\n  data.types = types;\n}\n\nread.type = infer_type;\nread.types = infer_types;\nread.formats = formats;\nread.parse = parse;\nmodule.exports = read;\n","var util = require('./util');\n\nvar dl = {\n  load:      require('./import/load'),\n  read:      require('./import/read'),\n  bin:       require('./bin'),\n  histogram: require('./histogram'),\n  summary:   require('./summary'),\n  template:  require('./template'),\n  dateunits: require('./date-units')\n};\n\nutil.extend(dl, util);\nutil.extend(dl, require('./generate'));\nutil.extend(dl, require('./stats'));\nutil.extend(dl, require('./import/loaders'));\n\nmodule.exports = dl;","var util = require('./util');\nvar gen = require('./generate');\nvar stats = {};\n\n// Collect unique values and associated counts.\n// Output: an array of unique values, in observed order\n// The array includes an additional 'counts' property,\n// which is a hash from unique values to occurrence counts.\nstats.unique = function(values, f, results) {\n  if (!util.isArray(values) || values.length===0) return [];\n  results = results || [];\n  var u = {}, v, i;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) {\n      u[v] += 1;\n    } else {\n      u[v] = 1;\n      results.push(v);\n    }\n  }\n  results.counts = u;\n  return results;\n};\n\n// Count the number of non-null values.\nstats.count = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null) count += 1;\n  }\n  return count;\n};\n\n// Count the number of distinct values.\nstats.count.distinct = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var u = {}, v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v in u) continue;\n    u[v] = 1;\n    count += 1;\n  }\n  return count;\n};\n\n// Count the number of null or undefined values.\nstats.count.nulls = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var v, i, count = 0;\n  for (i=0, n=values.length; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v == null) count += 1;\n  }\n  return count;\n};\n\n// Compute the median of an array of numbers.\nstats.median = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  if (f) values = values.map(f);\n  values = values.filter(util.isNotNull).sort(util.cmp);\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\n// Compute the quantile of a sorted array of numbers.\n// Adapted from the D3.js implementation.\nstats.quantile = function(values, f, p) {\n  if (p === undefined) { p = f; f = util.identity; }\n  var H = (values.length - 1) * p + 1,\n      h = Math.floor(H),\n      v = +f(values[h - 1]),\n      e = H - h;\n  return e ? v + e * (f(values[h]) - v) : v;\n};\n\n// Compute the mean (average) of an array of numbers.\nstats.mean = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n    }\n  }\n  return mean;\n};\n\n// Compute the sample variance of an array of numbers.\nstats.variance = function(values, f) {\n  if (!util.isArray(values) || values.length===0) return 0;\n  var mean = 0, M2 = 0, delta, i, c, v;\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n    if (v != null && !isNaN(v)) {\n      delta = v - mean;\n      mean = mean + delta / (++c);\n      M2 = M2 + delta * (v - mean);\n    }\n  }\n  M2 = M2 / (c - 1);\n  return M2;\n};\n\n// Compute the sample standard deviation of an array of numbers.\nstats.stdev = function(values, f) {\n  return Math.sqrt(stats.variance(values, f));\n};\n\n// Compute the Pearson mode skewness ((median-mean)/stdev) of an array of numbers.\nstats.modeskew = function(values, f) {\n  var avg = stats.mean(values, f),\n      med = stats.median(values, f),\n      std = stats.stdev(values, f);\n  return std === 0 ? 0 : (avg - med) / std;\n};\n\n// Find the minimum and maximum of an array of values.\nstats.extent = function(values, f) {\n  var a, b, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    v = (typeof v === 'string') ? v.length : v;\n    if (util.isNotNull(v)) { a = b = v; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    v = (typeof v === 'string') ? v.length : v;\n    if (util.isNotNull(v)) {\n      if (v < a) a = v;\n      if (v > b) b = v;\n    }\n  }\n  return [a, b];\n};\n\n// Find the integer indices of the minimum and maximum values.\nstats.extent.index = function(values, f) {\n  var a, b, x, y, v, i, n = values.length;\n  for (i=0; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    v = (typeof v === 'string') ? v.length : v;\n    if (util.isNotNull(v)) { a = b = v; x = y = i; break; }\n  }\n  for (; i<n; ++i) {\n    v = f ? f(values[i]) : values[i];\n    v = (typeof v === 'string') ? v.length : v;\n    if (util.isNotNull(v)) {\n      if (v < a) { a = v; x = i; }\n      if (v > b) { b = v; y = i; }\n    }\n  }\n  return [x, y];\n};\n\n// Compute the dot product of two arrays of numbers.\nstats.dot = function(values, a, b) {\n  var sum = 0, i, v;\n  if (!b) {\n    if (values.length !== a.length) {\n      throw Error(\"Array lengths must match.\");\n    }\n    for (i=0; i<values.length; ++i) {\n      v = values[i] * a[i];\n      if (!isNaN(v)) sum += v;\n    }\n  } else {\n    for (i=0; i<values.length; ++i) {\n      v = a(values[i]) * b(values[i]);\n      if (!isNaN(v)) sum += v;\n    }\n  }\n  return sum;\n};\n\n// Compute ascending rank scores for an array of values.\n// Ties are assigned their collective mean rank.\nstats.rank = function(values, f) {\n  var a = values.map(function(v, i) {\n      return {\n        idx: i,\n        val: (f ? f(v) : v)\n      };\n    })\n    .sort(util.comparator(\"val\"));\n\n  var n = values.length,\n      r = Array(n),\n      tie = -1, p = {}, i, v, mu;\n\n  for (i=0; i<n; ++i) {\n    v = a[i].val;\n    if (tie < 0 && p === v) {\n      tie = i - 1;\n    } else if (tie > -1 && p !== v) {\n      mu = 1 + (i-1 + tie) / 2;\n      for (; tie<i; ++tie) r[a[tie].idx] = mu;\n      tie = -1;\n    }\n    r[a[i].idx] = i + 1;\n    p = v;\n  }\n\n  if (tie > -1) {\n    mu = 1 + (n-1 + tie) / 2;\n    for (; tie<n; ++tie) r[a[tie].idx] = mu;\n  }\n\n  return r;\n};\n\n// Compute the sample Pearson product-moment correlation of two arrays of numbers.\nstats.cor = function(values, a, b) {\n  var fn = b;\n  b = fn ? values.map(b) : a,\n  a = fn ? values.map(a) : values;\n\n  var dot = stats.dot(a, b),\n      mua = stats.mean(a),\n      mub = stats.mean(b),\n      sda = stats.stdev(a),\n      sdb = stats.stdev(b),\n      n = values.length;\n\n  return (dot - n*mua*mub) / ((n-1) * sda * sdb);\n};\n\n// Compute the Spearman rank correlation of two arrays of values.\nstats.cor.rank = function(values, a, b) {\n  var ra = b ? stats.rank(values, a) : stats.rank(values),\n      rb = b ? stats.rank(values, b) : stats.rank(a),\n      n = values.length, i, s, d;\n\n  for (i=0, s=0; i<n; ++i) {\n    d = ra[i] - rb[i];\n    s += d * d;\n  }\n\n  return 1 - 6*s / (n * (n*n-1));\n};\n\n// Compute the distance correlation of two arrays of numbers.\n// http://en.wikipedia.org/wiki/Distance_correlation\nstats.cor.dist = function(values, a, b) {\n  var X = b ? values.map(a) : values,\n      Y = b ? values.map(b) : a;\n\n  var A = stats.dist.mat(X),\n      B = stats.dist.mat(Y),\n      n = A.length,\n      i, aa, bb, ab;\n\n  for (i=0, aa=0, bb=0, ab=0; i<n; ++i) {\n    aa += A[i]*A[i];\n    bb += B[i]*B[i];\n    ab += A[i]*B[i];\n  }\n\n  return Math.sqrt(ab / Math.sqrt(aa*bb));\n};\n\n// Compute the vector distance between two arrays of numbers.\n// Default is Euclidean (exp=2) distance, configurable via exp argument.\nstats.dist = function(values, a, b, exp) {\n  var f = util.isFunction(b),\n      X = values,\n      Y = f ? values : a,\n      e = f ? exp : b,\n      n = values.length, s = 0, d, i;\n\n  if (e === 2 || e === undefined) {\n    for (i=0; i<n; ++i) {\n      d = f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]);\n      s += d*d;\n    }\n    return Math.sqrt(s);\n  } else {\n    for (i=0; i<n; ++i) {\n      d = Math.abs(f ? (a(X[i])-b(Y[i])) : (X[i]-Y[i]));\n      s += Math.pow(d, e);\n    }\n    return Math.pow(s, 1/e);\n  }\n};\n\n// Construct a mean-centered distance matrix for an array of numbers.\nstats.dist.mat = function(X) {\n  var n = X.length,\n      m = n*n,\n      A = Array(m),\n      R = gen.zeros(n),\n      M = 0, v, i, j;\n\n  for (i=0; i<n; ++i) {\n    A[i*n+i] = 0;\n    for (j=i+1; j<n; ++j) {\n      A[i*n+j] = (v = Math.abs(X[i] - X[j]));\n      A[j*n+i] = v;\n      R[i] += v;\n      R[j] += v;\n    }\n  }\n\n  for (i=0; i<n; ++i) {\n    M += R[i];\n    R[i] /= n;\n  }\n  M /= m;\n\n  for (i=0; i<n; ++i) {\n    for (j=i; j<n; ++j) {\n      A[i*n+j] += M - R[i] - R[j];\n      A[j*n+i] = A[i*n+j];\n    }\n  }\n\n  return A;\n};\n\n// Compute the Shannon entropy (log base 2) of an array of counts.\nstats.entropy = function(counts, f) {\n  var i, p, s = 0, H = 0, N = counts.length;\n  for (i=0; i<N; ++i) {\n    s += (f ? f(counts[i]) : counts[i]);\n  }\n  if (s === 0) return 0;\n  for (i=0; i<N; ++i) {\n    p = (f ? f(counts[i]) : counts[i]) / s;\n    if (p > 0) H += p * Math.log(p) / Math.LN2;\n  }\n  return -H;\n};\n\n// Compute the normalized Shannon entropy (log base 2) of an array of counts.\nstats.entropy.normalized = function(counts, f) {\n  var H = stats.entropy(counts, f);\n  return H===0 ? 0 : H * Math.LN2 / Math.log(counts.length);\n};\n\n// Compute the mutual information between two discrete variables.\n// http://en.wikipedia.org/wiki/Mutual_information\nstats.entropy.mutual = function(values, a, b, counts) {\n  var x = counts ? values.map(a) : values,\n      y = counts ? values.map(b) : a,\n      z = counts ? values.map(counts) : b;\n\n  var px = {},\n\t    py = {},\n\t    i, xx, yy, zz, s = 0, t, N = z.length, p, I = 0;\n\n\tfor (i=0; i<N; ++i) {\n\t  px[x[i]] = 0;\n\t  py[y[i]] = 0;\n  }\n\n\tfor (i=0; i<N; ++i) {\n\t\tpx[x[i]] += z[i];\n\t\tpy[y[i]] += z[i];\n\t\ts += z[i];\n\t}\n\n\tt = 1 / (s * Math.LN2);\n\tfor (i=0; i<N; ++i) {\n\t\tif (z[i] === 0) continue;\n\t\tp = (s * z[i]) / (px[x[i]] * py[y[i]]);\n\t\tI += z[i] * t * Math.log(p);\n\t}\n\n\treturn I;\n};\n\n// Compute a profile of summary statistics for a variable.\nstats.profile = function(values, f) {\n  var p = {},\n      mean = 0,\n      count = 0,\n      distinct = 0,\n      min = null,\n      max = null,\n      M2 = 0,\n      vals = [],\n      u = {}, delta, sd, i, v, x, half, h, h2;\n\n  // compute summary stats\n  for (i=0, c=0; i<values.length; ++i) {\n    v = f ? f(values[i]) : values[i];\n\n    // update unique values\n    u[v] = (v in u) ? u[v] + 1 : (distinct += 1, 1);\n\n    if (util.isNotNull(v)) {\n      // update stats\n      x = (typeof v === 'string') ? v.length : v;\n      if (min===null || x < min) min = x;\n      if (max===null || x > max) max = x;\n\n      delta = x - mean;\n      mean = mean + delta / (++count);\n      M2 = M2 + delta * (x - mean);\n      vals.push(x);\n    }\n  }\n  M2 = M2 / (count - 1);\n  sd = Math.sqrt(M2);\n\n  // sort values for median and iqr\n  vals.sort(util.cmp);\n\n  return {\n    unique:   u,\n    count:    count,\n    nulls:    values.length - count,\n    distinct: distinct,\n    min:      min,\n    max:      max,\n    mean:     mean,\n    stdev:    sd,\n    median:   (v = stats.quantile(vals, 0.5)),\n    modeskew: sd === 0 ? 0 : (mean - v) / sd,\n    iqr:      [stats.quantile(vals, 0.25), stats.quantile(vals, 0.75)]\n  };\n};\n\nmodule.exports = stats;","var util = require('./util');\nvar stats = require('./stats');\n\n// Compute profiles for all variables in a data set.\nmodule.exports = function(data, fields) {\n  if (data == null || data.length === 0) return null;\n  fields = fields || util.keys(data[0]);\n\n  var profiles = fields.map(function(f) {\n    var p = stats.profile(data, util.accessor(f));\n    return (p.field = f, p);\n  });\n  \n  profiles.toString = printSummary;\n  return profiles;\n};\n\nfunction printSummary() {\n  var profiles = this;\n  var str = [];\n  profiles.forEach(function(p) {\n    str.push(\"----- Field: '\" + p.field + \"' -----\");\n    if (typeof p.min === 'string' || p.distinct < 10) {\n      str.push(printCategoricalProfile(p));\n    } else {\n      str.push(printQuantitativeProfile(p));\n    }\n    str.push(\"\");\n  });\n  return str.join(\"\\n\");\n}\n\nfunction printQuantitativeProfile(p) {\n  return [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"min:      \" + p.min,\n    \"max:      \" + p.max,\n    \"median:   \" + p.median,\n    \"mean:     \" + p.mean,\n    \"stdev:    \" + p.stdev,\n    \"modeskew: \" + p.modeskew\n  ].join(\"\\n\");\n}\n\nfunction printCategoricalProfile(p) {\n  var list = [\n    \"distinct: \" + p.distinct,\n    \"nulls:    \" + p.nulls,\n    \"top values: \"\n  ];\n  var u = p.unique;\n  var top = util.keys(u)\n    .sort(function(a,b) { return u[b] - u[a]; })\n    .slice(0, 6)\n    .map(function(v) { return \" '\" + v + \"' (\" + u[v] + \")\"; });\n  return list.concat(top).join(\"\\n\");\n}","var util = require('./util');\nvar d3 = (typeof window !== \"undefined\" ? window.d3 : typeof global !== \"undefined\" ? global.d3 : null);\n\nvar context = {\n  formats:    [],\n  format_map: {},\n  truncate:   util.truncate\n};\n\nfunction template(text) {\n  var src = source(text, \"d\");\n  src = \"var __t; return \" + src + \";\";\n\n  try {\n    return (new Function(\"d\", src)).bind(context);\n  } catch (e) {\n    e.source = src;\n    throw e;\n  }\n}\n\nmodule.exports = template;\n\n// clear cache of format objects\n// can *break* prior template functions, so invoke with care\ntemplate.clearFormatCache = function() {\n  context.formats = [];\n  context.format_map = {};\n};\n\nfunction source(text, variable) {\n  variable = variable || \"obj\";\n  var index = 0;\n  var src = \"'\";\n  var regex = template_re;\n\n  // Compile the template source, escaping string literals appropriately.\n  text.replace(regex, function(match, interpolate, offset) {\n    src += text\n      .slice(index, offset)\n      .replace(template_escaper, template_escapeChar);\n    index = offset + match.length;\n\n    if (interpolate) {\n      src += \"'\\n+((__t=(\"\n        + template_var(interpolate, variable)\n        + \"))==null?'':__t)+\\n'\";\n    }\n\n    // Adobe VMs need the match returned to produce the correct offest.\n    return match;\n  });\n  return src + \"'\";\n}\n\nfunction template_var(text, variable) {\n  var filters = text.split('|');\n  var prop = filters.shift().trim();\n  var format = [];\n  var stringCast = true;\n  \n  function strcall(fn) {\n    fn = fn || \"\";\n    if (stringCast) {\n      stringCast = false;\n      src = \"String(\" + src + \")\" + fn;\n    } else {\n      src += fn;\n    }\n    return src;\n  }\n  \n  var src = util.field(prop).map(util.str).join(\"][\");\n  src = variable + \"[\" + src + \"]\";\n  \n  for (var i=0; i<filters.length; ++i) {\n    var f = filters[i], args = null, pidx, a, b;\n\n    if ((pidx=f.indexOf(':')) > 0) {\n      f = f.slice(0, pidx);\n      args = filters[i].slice(pidx+1).split(',')\n        .map(function(s) { return s.trim(); });\n    }\n    f = f.trim();\n\n    switch (f) {\n      case 'length':\n        strcall('.length');\n        break;\n      case 'lower':\n        strcall('.toLowerCase()');\n        break;\n      case 'upper':\n        strcall('.toUpperCase()');\n        break;\n      case 'lower-locale':\n        strcall('.toLocaleLowerCase()');\n        break;\n      case 'upper-locale':\n        strcall('.toLocaleUpperCase()');\n        break;\n      case 'trim':\n        strcall('.trim()');\n        break;\n      case 'left':\n        a = util.number(args[0]);\n        strcall('.slice(0,' + a + ')');\n        break;\n      case 'right':\n        a = util.number(args[0]);\n        strcall('.slice(-' + a +')');\n        break;\n      case 'mid':\n        a = util.number(args[0]);\n        b = a + util.number(args[1]);\n        strcall('.slice(+'+a+','+b+')');\n        break;\n      case 'slice':\n        a = util.number(args[0]);\n        strcall('.slice('+ a\n          + (args.length > 1 ? ',' + util.number(args[1]) : '')\n          + ')');\n        break;\n      case 'truncate':\n        a = util.number(args[0]);\n        b = args[1];\n        b = (b!==\"left\" && b!==\"middle\" && b!==\"center\") ? \"right\" : b;\n        src = 'this.truncate(' + strcall() + ',' + a + ',\"' + b + '\")';\n        break;\n      case 'number':\n        a = template_format(args[0], d3.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      case 'time':\n        a = template_format(args[0], d3.time.format);\n        stringCast = false;\n        src = 'this.formats['+a+']('+src+')';\n        break;\n      default:\n        throw Error(\"Unrecognized template filter: \" + f);\n    }\n  }\n\n  return src;\n}\n\nvar template_re = /\\{\\{(.+?)\\}\\}|$/g;\n\n// Certain characters need to be escaped so that they can be put into a\n// string literal.\nvar template_escapes = {\n  \"'\":      \"'\",\n  '\\\\':     '\\\\',\n  '\\r':     'r',\n  '\\n':     'n',\n  '\\u2028': 'u2028',\n  '\\u2029': 'u2029'\n};\n\nvar template_escaper = /\\\\|'|\\r|\\n|\\u2028|\\u2029/g;\n\nfunction template_escapeChar(match) {\n  return '\\\\' + template_escapes[match];\n}\n\nfunction template_format(pattern, fmt) {\n  if ((pattern[0] === \"'\" && pattern[pattern.length-1] === \"'\") ||\n      (pattern[0] !== '\"' && pattern[pattern.length-1] === '\"')) {\n    pattern = pattern.slice(1, -1);\n  } else {\n    throw Error(\"Format pattern must be quoted: \" + pattern);\n  }\n  if (!context.format_map[pattern]) {\n    var f = fmt(pattern);\n    var i = context.formats.length;\n    context.formats.push(f);\n    context.format_map[pattern] = i;\n  }\n  return context.format_map[pattern];\n}\n","var Buffer = require('buffer').Buffer;\nvar u = module.exports = {};\n\n// where are we?\n\nu.isNode = typeof process !== 'undefined'\n        && typeof process.stderr !== 'undefined';\n\n// type checking functions\n\nvar toString = Object.prototype.toString;\n\nu.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nu.isFunction = function(obj) {\n  return toString.call(obj) == '[object Function]';\n};\n\nu.isString = function(obj) {\n  return toString.call(obj) == '[object String]';\n};\n\nu.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nu.isNumber = function(obj) {\n  return !isNaN(parseFloat(obj)) && isFinite(obj);\n};\n\nu.isBoolean = function(obj) {\n  return toString.call(obj) == '[object Boolean]';\n};\n\nu.isDate = function(obj) {\n  return toString.call(obj) == '[object Date]';\n};\n\nu.isNotNull = function(obj) {\n  return obj != null && (typeof obj !== 'number' ? true : !isNaN(obj));\n};\n\nu.isBuffer = (Buffer && Buffer.isBuffer) || u.false;\n\n// type coercion functions\n\nu.number = function(s) { return s == null ? null : +s; };\n\nu.boolean = function(s) { return s == null ? null : s==='false' ? false : !!s; };\n\nu.date = function(s) { return s == null ? null : Date.parse(s); }\n\nu.array = function(x) { return x != null ? (u.isArray(x) ? x : [x]) : []; };\n\nu.str = function(x) {\n  return u.isArray(x) ? \"[\" + x.map(u.str) + \"]\"\n    : u.isObject(x) ? JSON.stringify(x)\n    : u.isString(x) ? (\"'\"+util_escape_str(x)+\"'\") : x;\n};\n\nvar escape_str_re = /(^|[^\\\\])'/g;\n\nfunction util_escape_str(x) {\n  return x.replace(escape_str_re, \"$1\\\\'\");\n}\n\n// utility functions\n\nu.identity = function(x) { return x; };\n\nu.true = function() { return true; };\n\nu.false = function() { return false; };\n\nu.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nu.equal = function(a, b) {\n  return JSON.stringify(a) === JSON.stringify(b);\n};\n\nu.extend = function(obj) {\n  for (var x, name, i=1, len=arguments.length; i<len; ++i) {\n    x = arguments[i];\n    for (name in x) { obj[name] = x[name]; }\n  }\n  return obj;\n};\n\nu.keys = function(x) {\n  var keys = [], k;\n  for (k in x) keys.push(k);\n  return keys;\n};\n\nu.vals = function(x) {\n  var vals = [], k;\n  for (k in x) vals.push(x[k]);\n  return vals;\n};\n\nu.toMap = function(list) {\n  return list.reduce(function(obj, x) {\n    return (obj[x] = 1, obj);\n  }, {});\n};\n\nu.keystr = function(values) {\n  // use to ensure consistent key generation across modules\n  return values.join(\"|\");\n};\n\n// data access functions\n\nu.field = function(f) {\n  return f.split(\"\\\\.\")\n    .map(function(d) { return d.split(\".\"); })\n    .reduce(function(a, b) {\n      if (a.length) { a[a.length-1] += \".\" + b.shift(); }\n      a.push.apply(a, b);\n      return a;\n    }, []);\n};\n\nu.accessor = function(f) {\n  var s;\n  return (u.isFunction(f) || f==null)\n    ? f : u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x) { return s.reduce(function(x,f) {\n          return x[f];\n        }, x);\n      }\n    : function(x) { return x[f]; };\n};\n\nu.mutator = function(f) {\n  var s;\n  return u.isString(f) && (s=u.field(f)).length > 1\n    ? function(x, v) {\n        for (var i=0; i<s.length-1; ++i) x = x[s[i]];\n        x[s[i]] = v;\n      }\n    : function(x, v) { x[f] = v; };\n};\n\n\n// comparison / sorting functions\n\nu.comparator = function(sort) {\n  var sign = [];\n  if (sort === undefined) sort = [];\n  sort = u.array(sort).map(function(f) {\n    var s = 1;\n    if      (f[0] === \"-\") { s = -1; f = f.slice(1); }\n    else if (f[0] === \"+\") { s = +1; f = f.slice(1); }\n    sign.push(s);\n    return u.accessor(f);\n  });\n  return function(a,b) {\n    var i, n, f, x, y;\n    for (i=0, n=sort.length; i<n; ++i) {\n      f = sort[i]; x = f(a); y = f(b);\n      if (x < y) return -1 * sign[i];\n      if (x > y) return sign[i];\n    }\n    return 0;\n  };\n};\n\nu.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nu.numcmp = function(a, b) { return a - b; };\n\nu.stablesort = function(array, sortBy, keyFn) {\n  var indices = array.reduce(function(idx, v, i) {\n    return (idx[keyFn(v)] = i, idx);\n  }, {});\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n        sb = sortBy(b);\n    return sa < sb ? -1 : sa > sb ? 1\n         : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n\n  return array;\n};\n\n\n// string functions\n\n// ES6 compatibility per https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith#Polyfill\n// We could have used the polyfill code, but lets wait until ES6 becomes a standard first\nu.startsWith = String.prototype.startsWith\n  ? function(string, searchString) {\n    return string.startsWith(searchString);\n  }\n  : function(string, searchString) {\n    return string.lastIndexOf(searchString, 0) === 0;\n  };\n\nu.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis !== undefined ? String(ellipsis) : \"…\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis\n        + (word ? truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n","'use strict';\n\nvar globals = require('./globals'),\n  consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema'),\n  time = require('./compile/time');\n\nvar Encoding = module.exports = (function() {\n\n  function Encoding(marktype, enc, data, config, filter, theme) {\n    var defaults = schema.instantiate();\n\n    var spec = {\n      data: data,\n      marktype: marktype,\n      enc: enc,\n      config: config,\n      filter: filter || []\n    };\n\n    // type to bitcode\n    for (var e in defaults.enc) {\n      defaults.enc[e].type = consts.dataTypes[defaults.enc[e].type];\n    }\n\n    var specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.enc;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.enc = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(et, nodata, nofn) {\n    if (!this.has(et)) return null;\n\n    var f = (nodata ? '' : 'data.');\n\n    if (this._enc[et].aggr === 'count') {\n      return f + 'count';\n    } else if (!nofn && this._enc[et].bin) {\n      return f + 'bin_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].aggr) {\n      return f + this._enc[et].aggr + '_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].fn) {\n      return f + this._enc[et].fn + '_' + this._enc[et].name;\n    } else {\n      return f + this._enc[et].name;\n    }\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggr || this._enc[et].fn || (this._enc[et].bin && \"bin\");\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.band = function(et) {\n    return this._enc[et].band || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.band(encType).size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggr = function(et) {\n    return this._enc[et].aggr;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.legend = function(et) {\n    return this._enc[et].legend;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.fn = function(et) {\n    return this._enc[et].fn;\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isType = vlfield.isType.byCode;\n\n    // console.log('sort:', sort, 'support:', Encoding.toggleSort.support({enc:this._enc}, stats) , 'toggle:', this.config('toggleSort'))\n\n    if ((!sort || sort.length===0) &&\n        Encoding.toggleSort.support({enc:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === 'Q'\n      ) {\n      var qField = isType(enc.x, O) ? enc.y : enc.x;\n\n      if (isType(enc[et], O)) {\n        sort = [{\n          name: qField.name,\n          aggr: qField.aggr,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.length = function() {\n    return util.keys(this._enc).length;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.role = function(et) {\n    return this.has(et) ? vlfield.role(this._enc[et]) : null;\n  };\n\n  proto.text = function(prop) {\n    var text = this._enc[TEXT].text;\n    return prop ? text[prop] : text;\n  };\n\n  proto.font = function(prop) {\n    var font = this._enc[TEXT].font;\n    return prop ? font[prop] : font;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.enc(et);\n    return field && Encoding.isType(field, type);\n  };\n\n  Encoding.isType = function (fieldDef, type) {\n    // FIXME vlfield.isType\n    return (fieldDef.type & type) > 0;\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.enc(encType), true);\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.enc(encType), true);\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.enc(encType), true);\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec, stats) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.enc.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.enc(encType), stats, this.config('filterNull'), true);\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return this._data[name];\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  proto.toSpec = function(excludeConfig) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for (var e in enc) {\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.enc);\n  };\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split, true);\n\n    return new Encoding(marktype, enc, data, config, null, theme);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    var enc = util.duplicate(spec.enc || {});\n\n    //convert type from string to bitcode (e.g, O=1)\n    for (var e in enc) {\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, spec.data, spec.config, spec.filter, theme);\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.enc,\n      enc = util.duplicate(spec.enc);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.enc = enc;\n    return spec;\n  };\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === 'Q' ? 'O' :'Q';\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec, useTypeCode) {\n    if (!Encoding.toggleSort.support(spec, useTypeCode)) { return; }\n    var enc = spec.enc;\n    return enc.x.type === 'O' ? 'x' :  'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats, useTypeCode) {\n    var enc = spec.enc,\n      isType = vlfield.isType.get(useTypeCode);\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isType(enc.x, O) && vlfield.isMeasure(enc.y, useTypeCode)) ? 'x' :\n      ( isType(enc.y, O) && vlfield.isMeasure(enc.x, useTypeCode)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.enc);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].nulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {},\n    data = spec.data[1]; // currently data[0] is raw and data[1] is table\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggr) {\n      if (field.aggr === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggr + '|'+ field.name] = {\n          op: field.aggr,\n          field: 'data.'+ field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0 && !opt.preaggregatedData) {\n    if (!data.transform) data.transform = [];\n    data.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var type = name;\n  var isCol = name == COL, isRow = name == ROW;\n  var rowOffset = axisTitleOffset(encoding, layout, Y) + 20,\n    cellPadding = layout.cellPadding;\n\n\n  if (isCol) type = 'x';\n  if (isRow) type = 'y';\n\n  var def = {\n    type: type,\n    scale: name\n  };\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n    def.layer = (isRow || isCol) ? 'front' :  'back';\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      setter(def, ['properties', 'grid'], {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      setter(def, ['properties', 'grid'], {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: rowOffset\n        },\n        x2: {\n          offset: rowOffset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: \"mark.group.width\",\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else {\n      setter(def, ['properties', 'grid', 'stroke'], {\n        value: encoding.config('gridColor')\n      });\n    }\n  }\n\n  if (encoding.axis(name).title) {\n    def = axis_title(def, name, encoding, layout, opt);\n  }\n\n  if (isRow || isCol) {\n    setter(def, ['properties', 'ticks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'majorTicks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'axis'], {\n      opacity: {value: 0}\n    });\n  }\n\n  if (isCol) {\n    def.orient = 'top';\n  }\n\n  if (isRow) {\n    def.offset = rowOffset;\n  }\n\n  if (name == X) {\n    if (encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n      def.orient = 'top';\n    }\n\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      setter(def, ['properties','labels'], {\n        angle: {value: 270},\n        align: {value: 'right'},\n        baseline: {value: 'middle'}\n      });\n    } else { // Q\n      def.ticks = 5;\n    }\n  }\n\n  def = axis_labels(def, name, encoding, layout, opt);\n\n  return def;\n};\n\nfunction axis_title(def, name, encoding, layout, opt) {\n  var maxlength = null,\n    fieldTitle = encoding.fieldTitle(name);\n  if (name===X) {\n    maxlength = layout.cellWidth / encoding.config('characterWidth');\n  } else if (name === Y) {\n    maxlength = layout.cellHeight / encoding.config('characterWidth');\n  }\n\n  def.title = maxlength ? util.truncate(fieldTitle, maxlength) : fieldTitle;\n\n  if (name === ROW) {\n    setter(def, ['properties','title'], {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    });\n  }\n\n  def.titleOffset = axisTitleOffset(encoding, layout, name);\n  return def;\n}\n\nfunction axis_labels(def, name, encoding, layout, opt) {\n  var fn;\n  // add custom label for time type\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) && (time.hasScale(fn))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ fn);\n  }\n\n  var textTemplatePath = ['properties','labels','text','template'];\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q)) {\n    setter(def, textTemplatePath, \"{{data | number:'.3s'}}\");\n  } else if (encoding.isType(name, T) && !encoding.fn(name)) {\n    setter(def, textTemplatePath, \"{{data | time:'%Y-%m-%d'}}\");\n  } else if (encoding.isType(name, T) && encoding.fn(name) === 'year') {\n    setter(def, textTemplatePath, \"{{data | number:'d'}}\");\n  } else if (encoding.isType(name, O) && encoding.axis(name).maxLabelLength) {\n    setter(def, textTemplatePath, '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}');\n  }\n\n  return def;\n}\n\nfunction axisTitleOffset(encoding, layout, name) {\n  var value = encoding.axis(name).titleOffset;\n  if (value) {\n    return value;\n  }\n  switch (name) {\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = binning;\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n  var bins = {};\n\n  if (opt.preaggregatedData) {\n    return;\n  }\n\n  if (!spec.transform) spec.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      spec.transform.push({\n        type: 'bin',\n        field: 'data.' + field.name,\n        output: 'data.bin_' + field.name,\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n}\n","'use strict';\n\nvar globals = require('../globals');\n\nmodule.exports = compile;\n\nvar Encoding = require('../Encoding'),\n  axis = compile.axis = require('./axis'),\n  filter = compile.filter = require('./filter'),\n  legend = compile.legend = require('./legend'),\n  marks = compile.marks = require('./marks'),\n  scale = compile.scale = require('./scale');\n\ncompile.aggregate = require('./aggregate');\ncompile.bin = require('./bin');\ncompile.facet = require('./facet');\ncompile.group = require('./group');\ncompile.layout = require('./layout');\ncompile.sort = require('./sort');\ncompile.stack = require('./stack');\ncompile.style = require('./style');\ncompile.subfacet = require('./subfacet');\ncompile.template = require('./template');\ncompile.time = require('./time');\n\nfunction compile(spec, stats, theme) {\n  return compile.encoding(Encoding.fromSpec(spec, theme), stats);\n}\n\ncompile.shorthand = function (shorthand, stats, config, theme) {\n  return compile.encoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompile.encoding = function (encoding, stats) {\n  var layout = compile.layout(encoding, stats),\n    style = compile.style(encoding, stats),\n    spec = compile.template(encoding, layout, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  filter.addFilters(spec, encoding);\n  var sorting = compile.sort(spec, encoding, stats);\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  var preaggregatedData = !!encoding.data('vegaServer');\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  compile.bin(spec.data[1], encoding, {preaggregatedData: preaggregatedData});\n\n  var lineType = marks[encoding.marktype()].line;\n\n  if (!preaggregatedData) {\n    spec = compile.time(spec, encoding);\n  }\n\n  // handle subfacets\n  var aggResult = compile.aggregate(spec, encoding, {preaggregatedData: preaggregatedData}),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && compile.stack(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    compile.subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = compile.facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, style, sorting,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(spec, encoding);\n\n  return spec;\n};\n\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.field(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.field(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    style,\n    sorting,\n    {stack: stack, facet: true, stats: stats}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n","'use strict';\n\nvar globals = require('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(spec, encoding) {\n  var filters = encoding.filter(),\n    data = spec.data[0];  // apply filters to raw data before aggregation\n\n  if (!data.transform)\n    data.transform = [];\n\n  // add custom filters\n  for (var i in filters) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = 'd.data.' + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j in operands) {\n        condition += 'd.data.' + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    data.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(spec, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      spec.data[1].transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.field(encType) + '>0'\n      });\n    }\n  });\n};\n\n","'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  schema = require('../schema/schema'),\n  time = require('./time'),\n  vlfield = require('../field');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.band(X).padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.enc(COL).width :  encoding.config(\"singleWidth\");\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.band(Y).padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.enc(ROW).height :  encoding.config(\"singleHeight\");\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\nfunction getMaxLength(encoding, stats, et) {\n  // FIXME determine constant for Q and T in a nicer way\n  return encoding.isType(et, Q) ? 20 :\n    encoding.isType(et, T) ? 20 :\n    stats[encoding.fieldName(et)].max;\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (x) {\n    var maxLength;\n    if (encoding.isDimension(x) || encoding.isType(x, T)) {\n      maxLength =  getMaxLength(encoding, stats, x);\n    } else if (encoding.aggr(x) === 'count') {\n      //assign default value for count as it won't have stats\n      maxLength =  3;\n    } else if (encoding.isType(x, Q)) {\n      if (x===X) {\n        maxLength = 3;\n      } else { // Y\n        //assume that default formating is always shorter than 7\n        maxLength = Math.min(getMaxLength(encoding, stats, x), 7);\n      }\n    }\n    setter(layout,[x, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + 20);\n  });\n  return layout;\n}\n","'use strict';\n\nvar global = require('../globals'),\n  time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vegalite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props, fn;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) &&\n    time.hasScale(fn)) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ fn;\n  }\n\n  return def;\n};\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlscale = require('./scale');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.field(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, alpha: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: e.scale(X).type === 'log' ? 1 : 0};\n    }\n  } else if (e.has(X)) { // is ordinal\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    // TODO add single bar offset\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: e.scale(Y).type === 'log' ? 1 : 0};\n  } else if (e.has(Y)) { // is ordinal\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    // TODO add single bar offset\n    p.yc = {group: 'height'};\n  }\n\n  // width\n  if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.width = {\n        value: e.bandSize(X, layout.x.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // X is Quant or Time Scale\n    p.width = {value: 2};\n  }\n\n  // height\n  if (!e.has(Y) || e.isOrdinalScale(Y)) { // no Y or Y is ordinal\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // Y is Quant or Time Scale\n    p.height = {value: 2};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction line_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    } else if (e.value(ALPHA) !== undefined) {\n      p.opacity = {value: e.value(ALPHA)};\n    } else if (!e.has(COLOR)) {\n      p.opacity = {value: style.opacity};\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: e.font('size')};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: 'black'};\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else {\n    p.opacity = {value: style.opacity};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      p.text = {template: \"{{\" + e.field(TEXT) + \" | number:'.3s'}}\"};\n      p.align = {value: 'right'};\n    } else {\n      p.text = {field: e.field(TEXT)};\n    }\n  } else {\n    p.text = {value: 'Abc'};\n  }\n\n  p.font = {value: e.font('family')};\n  p.fontWeight = {value: e.font('weight')};\n  p.fontStyle = {value: e.font('style')};\n  p.baseline = {value: e.text('baseline')};\n\n  return p;\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  time = require('./time');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale_domain(name, encoding, sorting, opt)\n    };\n    if (s.type === 'ordinal' && !encoding.bin(name) && encoding.sort(name).length === 0) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, layout, style, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case O: return 'ordinal';\n    case T:\n      var fn = encoding.fn(name);\n      return (fn && time.scale.type(fn, name)) || 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nfunction scale_domain(name, encoding, sorting, opt) {\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encoding.fn(name), name);\n    if(range) return range;\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)], encoding.bin(name).maxbins);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name === Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: 'data.' + (opt.facet ? 'max_' : '') + 'sum_' + encoding.field(name, true)\n    } :\n    {data: sorting.getDataset(name), field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, layout, style, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name);\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name) || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      var range = encoding.scale(COLOR).range;\n      if (range === undefined) {\n        if (s.type === 'ordinal') {\n          // FIXME\n          range = style.colorRange;\n        } else {\n          range = ['#A9DB9F', '#0D5C21'];\n          s.zero = false;\n        }\n      }\n      s.range = range;\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.band(s.name).padding;\n      }\n  }\n}\n","'use strict';\n\nvar globals = require('../globals');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(spec, encoding, stats, opt) {\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggr,\n          field: 'data.' + d.name\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + 'data.' + (d.aggr==='count' ? 'count' : (d.aggr + '_' + d.name));\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: ['data.' + field.name],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      spec.data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    spec: spec,\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n","\"use strict\";\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{op: 'max', field: 'data.sum_' + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlfield = require('../field'),\n  Encoding = require('../Encoding');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n    colorRange: colorRange(encoding, stats)\n  };\n};\n\nfunction colorRange(encoding, stats){\n  if (encoding.has(COLOR) && encoding.isDimension(COLOR)) {\n    var cardinality = encoding.cardinality(COLOR, stats);\n    if (cardinality <= 10) {\n      return \"category10\";\n    } else {\n      return \"category20\";\n    }\n    // TODO can vega interpolate range for ordinal scale?\n  }\n  return null;\n}\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field, true))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n","'use strict';\n\nvar global = require('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.field(COLOR)});\n  }\n}\n","'use strict';\n\nvar globals = require('../globals');\n\nvar groupdef = require('./group').def,\n  vldata = require('../data');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) { //hack use stats\n\n  var data = {name: RAW, format: {type: encoding.data('formatType')}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = vldata.getUrl(encoding, stats);\n  if (dataUrl) data.url = dataUrl;\n\n  var preaggregatedData = !!encoding.data('vegaServer');\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (field.aggr === 'count') {\n        name = 'count';\n      } else if (preaggregatedData && field.bin) {\n        name = 'bin_' + field.name;\n      } else if (preaggregatedData && field.aggr) {\n        name = field.aggr + '_' + field.name;\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt) {\n  var timeFields = {}, timeFn = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.fn) {\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeFn[field.fn] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[1],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var fn in timeFn) {\n    time.scale(scales, fn, encoding);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var fn = field.fn;\n  switch (fn) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.distinct -\n        (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.fn, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\n/** append custom time scales for axis label */\ntime.scale = function(scales, fn, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength');\n  // TODO add option for shorter scale / custom range\n  switch (fn) {\n    case 'day':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 7),\n        range: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(\n          function(s) { return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case 'month':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 12),\n        range: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(\n            function(s) { return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n\ntime.isOrdinalFn = function(fn) {\n  switch (fn) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(fn, name) {\n  if (name === COLOR) {\n    return 'linear'; // this has order\n  }\n\n  return time.isOrdinalFn(fn) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(fn, name) {\n  var isColor = name === COLOR;\n  switch (fn) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(fn) {\n  switch (fn) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n\n","'use strict';\n\nvar globals = require('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT, DETAIL];\n\nconsts.dataTypes = {'O': O, 'Q': Q, 'T': T};\n\nconsts.dataTypeNames = ['O', 'Q', 'T'].reduce(function(r, x) {\n  r[consts.dataTypes[x]] = x;\n  return r;\n},{});\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n","'use strict';\n\nvar dl = require('datalib');\n\nvar vldata = module.exports = {},\n  vlfield = require('./field'),\n  util = require('./util');\n\nvldata.getUrl = function getDataUrl(encoding, stats) {\n  if (!encoding.data('vegaServer')) {\n    // don't use vega server\n    return encoding.data('url');\n  }\n\n  if (encoding.length() === 0) {\n    // no fields\n    return;\n  }\n\n  var fields = [];\n  encoding.forEach(function(field, encType) {\n    var obj = {\n      name: encoding.field(encType, true),\n      field: field.name\n    };\n    if (field.aggr) {\n      obj.aggr = field.aggr;\n    }\n    if (field.bin) {\n      obj.binSize = util.getbins(stats[field.name], encoding.bin(encType).maxbins).step;\n    }\n    fields.push(obj);\n  });\n\n  var query = {\n    table: encoding.data('vegaServer').table,\n    fields: fields\n  };\n\n  return encoding.data('vegaServer').url + '/query/?q=' + JSON.stringify(query);\n};\n\n/** Mapping from datalib's inferred type to vegalite's type */\nvldata.types = {\n  'boolean': 'O',\n  'number': 'Q',\n  'integer': 'Q',\n  'date': 'T',\n  'string': 'O'\n};\n\nvldata.getStats = function(data) {\n  var stats = {},\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    var stat = dl.profile(data, function(d) {\n      return d[k];\n    });\n\n    var sample = {};\n    while(Object.keys(sample).length < Math.min(stat.distinct, 10)) {\n      var value = data[Math.floor(Math.random() * data.length)][k];\n      sample[value] = true;\n    }\n    stat.sample = Object.keys(sample);\n\n    stats[k] = stat;\n  });\n\n  stats.count = data.length;\n  return stats;\n};\n","// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.alpha) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggr) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init, i = 0, k;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field, encType) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand, convertType) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field, convertType);\n    return m;\n  }, {});\n};","'use strict';\n\n// utility for field\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggr ? f.aggr + c.func : '') +\n    (f.fn ? f.fn + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type +\n    (consts.dataTypeNames[f.type] || f.type);\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand, convertType) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: convertType ? consts.dataTypes[split[1].trim()] : split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggr.enum) {\n    var a = schema.aggr.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggr = a;\n      break;\n    }\n  }\n\n  // check time fn\n  for (i in schema.timefns) {\n    var f = schema.timefns[i];\n    if (o.name && o.name.indexOf(f + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.fn = f;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar typeOrder = {\n  O: 0,\n  G: 1,\n  T: 2,\n  Q: 3\n};\n\nvlfield.order = {};\n\nvlfield.order.type = function(field) {\n  if (field.aggr==='count') return 4;\n  return typeOrder[field.type];\n};\n\nvlfield.order.typeThenName = function(field) {\n  return vlfield.order.type(field) + '_' + field.name.toLowerCase();\n};\n\nvlfield.order.original = function() {\n  return 0; // no swap will occur\n};\n\nvlfield.order.name = function(field) {\n  return field.name;\n};\n\nvlfield.order.typeThenCardinality = function(field, stats){\n  return stats[field.name].distinct;\n};\n\n// FIXME refactor\nvlfield.isType = function (fieldDef, type) {\n  return (fieldDef.type & type) > 0;\n};\n\nvlfield.isType.byCode = vlfield.isType;\n\nvlfield.isType.byName = function (field, type) {\n  return field.type === consts.dataTypeNames[type];\n};\n\n\nfunction getIsType(useTypeCode) {\n  return useTypeCode ? vlfield.isType.byCode : vlfield.isType.byName;\n}\n\nvlfield.isType.get = getIsType; //FIXME\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || field.bin ||\n    ( isType(field, T) && field.fn && time.isOrdinalFn(field.fn) );\n};\n\nfunction isDimension(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || !!field.bin ||\n    ( isType(field, T) && !!field.fn );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field, useTypeCode /*optional*/) {\n  return field && isDimension(field, useTypeCode);\n};\n\nvlfield.isMeasure = function(field, useTypeCode) {\n  return field && !isDimension(field, useTypeCode);\n};\n\nvlfield.role = function(field) {\n  return isDimension(field) ? 'dimension' : 'measure';\n};\n\nvlfield.count = function() {\n  return {name:'*', aggr: 'count', type:'Q', displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggr === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull, useTypeCode) {\n  // FIXME need to take filter into account\n\n  var stat = stats[field.name];\n  var isType = getIsType(useTypeCode),\n    type = useTypeCode ? consts.dataTypeNames[field.type] : field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stat, field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggr) {\n    return 1;\n  }\n\n  // remove null\n  return stat.distinct -\n    (stat.nulls > 0 && filterNull[type] ? 1 : 0);\n};\n","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n","// Package of defining Vegalite Specification's json schema\n\"use strict\";\n\nvar schema = module.exports = {},\n  util = require('../util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggr = {\n  type: 'string',\n  enum: ['avg', 'sum', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'sum', 'min', 'max', 'count'],\n    O: [],\n    T: ['avg', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: {'Q': true, 'O': true, 'T': true, '': true}\n};\nschema.band = {\n  type: 'object',\n  properties: {\n    size: {\n      type: 'integer',\n      minimum: 0\n    },\n    padding: {\n      type: 'integer',\n      minimum: 0,\n      default: 1\n    }\n  }\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.enc.properties[encType].supportedRole;\n};\n\nschema.timefns = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.fn = {\n  type: 'string',\n  enum: schema.timefns,\n  supportedTypes: {'T': true}\n};\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: 'string',\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: {'Q': true}\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2\n    }\n  },\n  supportedTypes: {'Q': true} // TODO: add 'O' after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O', 'Q', 'T']\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: {'T': true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O','Q', 'T'] // ordinal-only field supports Q when bin is applied and T when fn is applied.\n    },\n    fn: schema.fn,\n    bin: bin,\n    aggr: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: {'O': true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        title: {\n          type: 'boolean',\n          default: true,\n          description: 'A title for the axis.'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: {'O': true},\n        required: ['name', 'aggr'],\n        name: {\n          type: 'string'\n        },\n        aggr: {\n          type: 'string',\n          enum: ['avg', 'sum', 'min', 'max', 'count']\n        },\n        reverse: {\n          type: 'boolean',\n          default: false\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: schema.band\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    text: {\n      type: 'object',\n      properties: {\n        align: {\n          type: 'string',\n          default: 'left'\n        },\n        baseline: {\n          type: 'string',\n          default: 'middle'\n        },\n        margin: {\n          type: 'integer',\n          default: 4,\n          minimum: 0\n        }\n      }\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    }\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array']\n        }\n      }\n    }\n  }\n};\n\nvar alphaMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    grid: {\n      type: 'boolean',\n      default: true,\n      description: 'A flag indicate if gridlines should be created in addition to ticks.'\n    },\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using alpha / size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\nvar alpha = merge(clone(quantitativeField), alphaMixin, sortMixin);\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    vegaServer: {\n      type: 'object',\n      default: null,\n      properties: {\n        table: {\n          type: 'string',\n          default: undefined\n        },\n        url: {\n          type: 'string',\n          default: 'http://localhost:3001'\n        }\n      }\n    }\n  }\n};\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#eeeeee'\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: 'O'\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#aaaaaa'\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    }\n  }\n};\n\n/** @type Object Schema of a vegalite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for vegalite specification',\n  type: 'object',\n  required: ['marktype', 'enc', 'data', 'config'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    enc: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.enc.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n","'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}","'use strict';\n\nvar util = module.exports = require('datalib/src/util');\n\nutil.extend(util, require('datalib/src/generate'));\nutil.bin = require('datalib/src/bin');\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bin({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n"],"sourceRoot":"/source/"}