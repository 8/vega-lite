{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","src/vl","vegalite.js","src/Encoding.js","src/compile/aggregate.js","src/compile/axis.js","src/compile/bin.js","src/compile/compile.js","src/compile/facet.js","src/compile/filter.js","src/compile/group.js","src/compile/layout.js","src/compile/legend.js","src/compile/marks.js","src/compile/scale.js","src/compile/sort.js","src/compile/stack.js","src/compile/style.js","src/compile/subfacet.js","src/compile/template.js","src/compile/time.js","src/consts.js","src/data.js","src/enc.js","src/field.js","src/globals.js","src/schema/schema.js","src/schema/schemautil.js","src/util.js"],"names":["e","exports","module","define","amd","f","window","global","self","vl","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"util","consts","merge","version","Encoding","compile","data","field","enc","schema","toShorthand","shorthand","./Encoding","./compile/compile","./consts","./data","./enc","./field","./globals","./schema/schema","./util",2,"vlfield","vlenc","marktype","config","filter","theme","defaults","instantiate","spec","type","dataTypes","specExtended","this","_data","_marktype","_enc","_config","_filter","proto","prototype","is","m","has","encType","undefined","name","et","filterNull","fields","forEach","fieldList","fieldName","Q","containsType","T","O","push","operands","operator","concat","nodata","nofn","aggr","bin","fn","fieldTitle","isCount","count","displayName","toUpperCase","scale","axis","band","bandSize","useSmallBand","Y","ROW","X","COL","size","maxbins","MAXBINS_DEFAULT","legend","value","sort","stats","isType","byCode","toggleSort","support","qField","x","y","reverse","any","all","keys","map","reduce","init","role","text","prop","TEXT","font","fieldDef","isOrdinalScale","encoding","isDimension","isMeasure","isAggregate","alwaysNoOcclusion","isStack","color","cardinality","isRaw","toSpec","excludeConfig","duplicate","dataTypeNames","subtract","c","assign","delim","fromShorthand","split","shift","trim","specFromShorthand","fromSpec","transpose","oldenc","row","col","direction","useTypeCode","mode","get","toggleFilterNullO","numNulls","./compile/time",3,"aggregates","opt","dims","meas","detail","facets","op","vals","preaggregatedData","transform","groupby","details","aggregated","../globals","../util",4,"axis_title","def","layout","maxlength","cellWidth","cellHeight","title","truncate","setter","angle","align","baseline","dy","height","titleOffset","axisTitleOffset","axis_labels","time","hasScale","textTemplatePath","format","maxLabelLength","getter","names","props","defs","isCol","isRow","rowOffset","cellPadding","grid","layer","offset","stroke","x2","group","mult","opacity","orient","ticks","./time",5,"binning","output",6,"template","marks","vlsort","vlstyle","style","aggregate","facet","vlstack","stack","subfacet","mark","mdefs","mdef","addFilters","sorting","hasRow","hasCol","lineType","line","aggResult","hasDetails","from","by","legends","scales","properties","update","axes","filterLessThanZero","../Encoding","./aggregate","./axis","./bin","./facet","./filter","./group","./layout","./legend","./marks","./scale","./sort","./stack","./style","./subfacet","./template",7,"faceting","axesGrp","enter","facetKeys","cellAxes","fill","error","unshift","groupdef","width","apply","trans",8,"BINARY",">",">=","=","!=","<","<=","filters","condition","op1","op2","j","console","warn","test",9,"_name",10,"vllayout","box","hasX","hasY","xCardinality","yCardinality","padding","colCardinality","rowCardinality","maxLength","Math","min","../field","../schema/schema",11,"COLOR","SIZE","SHAPE","shape","labels",12,"bar_props","p","xc","y2","yc","ALPHA","point_props","strokeWidth","line_props","area_props","tick_props","filled_point_props","text_props","fontSize","fontWeight","fontStyle","bg","TABLE","bar","requiredEncoding","supportedEncoding","alpha","area","tick","circle","square","point",13,"scale_domain","range","domain","bins","getbins","start","stop","step","STACKED","getDataset","scale_range","bandWidth","zero","round","nice","max","colorRange","outerPadding","points",14,"addSortTransforms","datasetMapping","counter","sortBy","d","byClause","dataName","transforms","source","RAW",15,"stacking","dim","val","idx","isXMeasure","isYMeasure","stacked","y1","y0",16,"estimateOpacity","numPoints","numMultiples",17,"subfaceting","g",18,"table","dataUrl","vldata","getUrl","url","parse","../data",19,"timeFields","timeFn","tf","fieldFn","func","stat","yearstat","formula","expr","labelLength","substr","isOrdinalFn","isColor",20,"encodingTypes","DETAIL",21,"obj","binSize","query","JSON","stringify","getSchema","order","k","datum","Date","stablesort","typeThenName","getStats","column","minmax","numbers","dates","uniq","len","toString","skew","stdev","mean","median","sample","Object","floor","random",22,"encTypes","countRetinal","arr","indexOf","join","convertType","isArray","enctype",23,"getIsType","byName","shorthands","timefns","typeOrder","G","toLowerCase","original","typeThenCardinality",24,"INDEX",25,"enum","supportedEnums","supportedTypes","minimum","default","getSupportedRole","supportedRole","defaultTimeFn","scale_type","clone","typicalField","description","onlyOrdinalField","dimension","axisMixin","supportedMarktypes","sortMixin","items","required","bandMixin","legendMixin","textMixin","margin","weight","family","sizeMixin","colorMixin","alphaMixin","maximum","shapeMixin","detailMixin","rowMixin","colMixin","facetMixin","requiredNameType","multiRoleField","measure","quantitativeField","onlyQuantitativeField","formatType","vegaServer","log","viewport","gridColor","singleHeight","singleWidth","largeBandSize","smallBandSize","largeBandMaxCardinality","cellGridColor","cellBackgroundColor","textCellWidth","timeScaleLabelLength","characterWidth","$schema","./schemautil",26,"dest","src","hasOwnProperty","constructor","Array","schemautil","isEmpty","extend","instance","isObject","changes","ins","arguments",27,"util_bisectLeft","lo","hi","mid","cmp","vg_truncateOnWord","rev","cnt","tok","vg_truncate_word_re","w","slice","v","Infinity","find","list","pattern","isin","item","array","isNumber","isNaN","parseFloat","isFinite","values","nums","date","b","half","variance","avg","diffs","pow","keyFn","indices","sa","sb","sqrt","med","std","thisArg","NaN","precision","eps","maxb","base","div","mins","minstep","logb","level","ceil","span","nbins","steps","unit","noaugment","pos","word","ellipsis","l1","l2","msg"],"mappings":"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","file":"vegalite.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","'use strict';\n\nvar globals = require('./globals'),\n    util = require('./util'),\n    consts = require('./consts');\n\nvar vl = util.merge(consts, util);\n\nvl.version = \"0.6.2\";\n\nvl.Encoding = require('./Encoding');\nvl.compile = require('./compile/compile');\nvl.data = require('./data');\nvl.field = require('./field');\nvl.enc = require('./enc');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\n\nmodule.exports = vl;\n","!function(e){if(\"object\"==typeof exports&&\"undefined\"!=typeof module)module.exports=e();else if(\"function\"==typeof define&&define.amd)define([],e);else{var f;\"undefined\"!=typeof window?f=window:\"undefined\"!=typeof global?f=global:\"undefined\"!=typeof self&&(f=self),f.vl=e()}}(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nvar globals = require('./globals'),\n    util = require('./util'),\n    consts = require('./consts');\n\nvar vl = util.merge(consts, util);\n\nvl.version = \"0.6.2\";\n\nvl.Encoding = require('./Encoding');\nvl.compile = require('./compile/compile');\nvl.data = require('./data');\nvl.field = require('./field');\nvl.enc = require('./enc');\nvl.schema = require('./schema/schema');\nvl.toShorthand = vl.Encoding.shorthand;\n\n\nmodule.exports = vl;\n\n},{\"./Encoding\":2,\"./compile/compile\":6,\"./consts\":20,\"./data\":21,\"./enc\":22,\"./field\":23,\"./globals\":24,\"./schema/schema\":25,\"./util\":27}],2:[function(require,module,exports){\n'use strict';\n\nvar globals = require('./globals'),\n  consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema'),\n  time = require('./compile/time');\n\nvar Encoding = module.exports = (function() {\n\n  function Encoding(marktype, enc, data, config, filter, theme) {\n    var defaults = schema.instantiate();\n\n    var spec = {\n      data: data,\n      marktype: marktype,\n      enc: enc,\n      config: config,\n      filter: filter || []\n    };\n\n    // type to bitcode\n    for (var e in defaults.enc) {\n      defaults.enc[e].type = consts.dataTypes[defaults.enc[e].type];\n    }\n\n    var specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.enc;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.enc = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(et, nodata, nofn) {\n    if (!this.has(et)) return null;\n\n    var f = (nodata ? '' : 'data.');\n\n    if (this._enc[et].aggr === 'count') {\n      return f + 'count';\n    } else if (!nofn && this._enc[et].bin) {\n      return f + 'bin_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].aggr) {\n      return f + this._enc[et].aggr + '_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].fn) {\n      return f + this._enc[et].fn + '_' + this._enc[et].name;\n    } else {\n      return f + this._enc[et].name;\n    }\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggr || this._enc[et].fn || (this._enc[et].bin && \"bin\");\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.band = function(et) {\n    return this._enc[et].band || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.band(encType).size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggr = function(et) {\n    return this._enc[et].aggr;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.legend = function(et) {\n    return this._enc[et].legend;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.fn = function(et) {\n    return this._enc[et].fn;\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isType = vlfield.isType.byCode;\n\n    // console.log('sort:', sort, 'support:', Encoding.toggleSort.support({enc:this._enc}, stats) , 'toggle:', this.config('toggleSort'))\n\n    if ((!sort || sort.length===0) &&\n        Encoding.toggleSort.support({enc:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === 'Q'\n      ) {\n      var qField = isType(enc.x, O) ? enc.y : enc.x;\n\n      if (isType(enc[et], O)) {\n        sort = [{\n          name: qField.name,\n          aggr: qField.aggr,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.any = function(f) {\n    return util.any(this._enc, f);\n  };\n\n  proto.all = function(f) {\n    return util.all(this._enc, f);\n  };\n\n  proto.length = function() {\n    return util.keys(this._enc).length;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.role = function(et) {\n    return this.has(et) ? vlfield.role(this._enc[et]) : null;\n  };\n\n  proto.text = function(prop) {\n    var text = this._enc[TEXT].text;\n    return prop ? text[prop] : text;\n  };\n\n  proto.font = function(prop) {\n    var font = this._enc[TEXT].font;\n    return prop ? font[prop] : font;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.enc(et);\n    return field && Encoding.isType(field, type);\n  };\n\n  Encoding.isType = function (fieldDef, type) {\n    // FIXME vlfield.isType\n    return (fieldDef.type & type) > 0;\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.enc(encType), true);\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.enc(encType), true);\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.enc(encType), true);\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec, stats) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.enc.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.enc(encType), stats, this.config('filterNull'), true);\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return this._data[name];\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  proto.toSpec = function(excludeConfig) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for (var e in enc) {\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.enc);\n  };\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split, true);\n\n    return new Encoding(marktype, enc, data, config, null, theme);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    var enc = util.duplicate(spec.enc || {});\n\n    //convert type from string to bitcode (e.g, O=1)\n    for (var e in enc) {\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, spec.data, spec.config, spec.filter, theme);\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.enc,\n      enc = util.duplicate(spec.enc);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.enc = enc;\n    return spec;\n  };\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === 'Q' ? 'O' :'Q';\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec, useTypeCode) {\n    if (!Encoding.toggleSort.support(spec, useTypeCode)) { return; }\n    var enc = spec.enc;\n    return enc.x.type === 'O' ? 'x' :  'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats, useTypeCode) {\n    var enc = spec.enc,\n      isType = vlfield.isType.get(useTypeCode);\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isType(enc.x, O) && vlfield.isMeasure(enc.y, useTypeCode)) ? 'x' :\n      ( isType(enc.y, O) && vlfield.isMeasure(enc.x, useTypeCode)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.enc);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].numNulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n\n},{\"./compile/time\":19,\"./consts\":20,\"./enc\":22,\"./field\":23,\"./globals\":24,\"./schema/schema\":25,\"./util\":27}],3:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {},\n    data = spec.data[1]; // currently data[0] is raw and data[1] is table\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggr) {\n      if (field.aggr === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggr + '|'+ field.name] = {\n          op: field.aggr,\n          field: 'data.'+ field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0 && !opt.preaggregatedData) {\n    if (!data.transform) data.transform = [];\n    data.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n\n},{\"../globals\":24,\"../util\":27}],4:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var type = name;\n  var isCol = name == COL, isRow = name == ROW;\n  var rowOffset = axisTitleOffset(encoding, layout, Y) + 20,\n    cellPadding = layout.cellPadding;\n\n\n  if (isCol) type = 'x';\n  if (isRow) type = 'y';\n\n  var def = {\n    type: type,\n    scale: name\n  };\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n    def.layer = (isRow || isCol) ? 'front' :  'back';\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      setter(def, ['properties', 'grid'], {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      setter(def, ['properties', 'grid'], {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: rowOffset\n        },\n        x2: {\n          offset: rowOffset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: \"mark.group.width\",\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else {\n      setter(def, ['properties', 'grid', 'stroke'], {\n        value: encoding.config('gridColor')\n      });\n    }\n  }\n\n  if (encoding.axis(name).title) {\n    def = axis_title(def, name, encoding, layout, opt);\n  }\n\n  if (isRow || isCol) {\n    setter(def, ['properties', 'ticks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'majorTicks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'axis'], {\n      opacity: {value: 0}\n    });\n  }\n\n  if (isCol) {\n    def.orient = 'top';\n  }\n\n  if (isRow) {\n    def.offset = rowOffset;\n  }\n\n  if (name == X) {\n    if (encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n      def.orient = 'top';\n    }\n\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      setter(def, ['properties','labels'], {\n        angle: {value: 270},\n        align: {value: 'right'},\n        baseline: {value: 'middle'}\n      });\n    } else { // Q\n      def.ticks = 5;\n    }\n  }\n\n  def = axis_labels(def, name, encoding, layout, opt);\n\n  return def;\n};\n\nfunction axis_title(def, name, encoding, layout, opt) {\n  var maxlength = null,\n    fieldTitle = encoding.fieldTitle(name);\n  if (name===X) {\n    maxlength = layout.cellWidth / encoding.config('characterWidth');\n  } else if (name === Y) {\n    maxlength = layout.cellHeight / encoding.config('characterWidth');\n  }\n\n  def.title = maxlength ? util.truncate(fieldTitle, maxlength) : fieldTitle;\n\n  if (name === ROW) {\n    setter(def, ['properties','title'], {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    });\n  }\n\n  def.titleOffset = axisTitleOffset(encoding, layout, name);\n  return def;\n}\n\nfunction axis_labels(def, name, encoding, layout, opt) {\n  var fn;\n  // add custom label for time type\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) && (time.hasScale(fn))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ fn);\n  }\n\n  var textTemplatePath = ['properties','labels','text','template'];\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q)) {\n    setter(def, textTemplatePath, \"{{data | number:'.3s'}}\");\n  } else if (encoding.isType(name, T) && !encoding.fn(name)) {\n    setter(def, textTemplatePath, \"{{data | time:'%Y-%m-%d'}}\");\n  } else if (encoding.isType(name, T) && encoding.fn(name) === 'year') {\n    setter(def, textTemplatePath, \"{{data | number:'d'}}\");\n  } else if (encoding.isType(name, O) && encoding.axis(name).maxLabelLength) {\n    setter(def, textTemplatePath, '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}');\n  }\n\n  return def;\n}\n\nfunction axisTitleOffset(encoding, layout, name) {\n  var value = encoding.axis(name).titleOffset;\n  if (value) {\n    return value;\n  }\n  switch (name) {\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n}\n\n},{\"../globals\":24,\"../util\":27,\"./time\":19}],5:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = binning;\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n  var bins = {};\n\n  if (opt.preaggregatedData) {\n    return;\n  }\n\n  if (!spec.transform) spec.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      spec.transform.push({\n        type: 'bin',\n        field: 'data.' + field.name,\n        output: 'data.bin_' + field.name,\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n}\n\n},{\"../globals\":24,\"../util\":27}],6:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = compile;\n\nvar Encoding = require('../Encoding'),\n  template = compile.template = require('./template'),\n  axis = compile.axis = require('./axis'),\n  filter = compile.filter = require('./filter'),\n  legend = compile.legend = require('./legend'),\n  marks = compile.marks = require('./marks'),\n  scale = compile.scale = require('./scale'),\n  vlsort = compile.sort = require('./sort'),\n  vlstyle = compile.style = require('./style'),\n  time = compile.time = require('./time'),\n  aggregate = compile.aggregate = require('./aggregate'),\n  bin = compile.bin = require('./bin'),\n  facet = compile.facet = require('./facet'),\n  vlstack = compile.stack = require('./stack'),\n  subfacet = compile.subfacet = require('./subfacet');\n\ncompile.layout = require('./layout');\ncompile.group = require('./group');\n\nfunction compile(spec, stats, theme) {\n  return compile.encoding(Encoding.fromSpec(spec, theme), stats);\n}\n\ncompile.shorthand = function (shorthand, stats, config, theme) {\n  return compile.encoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompile.encoding = function (encoding, stats) {\n  var layout = compile.layout(encoding, stats),\n    style = vlstyle(encoding, stats),\n    spec = template(encoding, layout, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  filter.addFilters(spec, encoding);\n  var sorting = vlsort(spec, encoding, stats);\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  var preaggregatedData = !!encoding.data('vegaServer');\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  bin(spec.data[1], encoding, {preaggregatedData: preaggregatedData});\n\n  var lineType = marks[encoding.marktype()].line;\n\n  if (!preaggregatedData) {\n    spec = time(spec, encoding);\n  }\n\n  // handle subfacets\n  var aggResult = aggregate(spec, encoding, {preaggregatedData: preaggregatedData}),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && vlstack(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, style, sorting,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(spec, encoding);\n\n  return spec;\n};\n\n\n},{\"../Encoding\":2,\"../globals\":24,\"../util\":27,\"./aggregate\":3,\"./axis\":4,\"./bin\":5,\"./facet\":7,\"./filter\":8,\"./group\":9,\"./layout\":10,\"./legend\":11,\"./marks\":12,\"./scale\":13,\"./sort\":14,\"./stack\":15,\"./style\":16,\"./subfacet\":17,\"./template\":18,\"./time\":19}],7:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.field(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.field(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    style,\n    sorting,\n    {stack: stack, facet: true, stats: stats}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n\n},{\"../globals\":24,\"../util\":27,\"./axis\":4,\"./group\":9,\"./scale\":13}],8:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(spec, encoding) {\n  var filters = encoding.filter(),\n    data = spec.data[0];  // apply filters to raw data before aggregation\n\n  if (!data.transform)\n    data.transform = [];\n\n  // add custom filters\n  for (var i in filters) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = 'd.data.' + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j in operands) {\n        condition += 'd.data.' + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    data.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(spec, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      spec.data[1].transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.field(encType) + '>0'\n      });\n    }\n  });\n};\n\n\n},{\"../globals\":24}],9:[function(require,module,exports){\n'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  schema = require('../schema/schema'),\n  time = require('./time'),\n  vlfield = require('../field');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.band(X).padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.enc(COL).width :  encoding.config(\"singleWidth\");\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.band(Y).padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.enc(ROW).height :  encoding.config(\"singleHeight\");\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (x) {\n    var maxLength;\n    if (encoding.isDimension(x) || encoding.isType(x, T)) {\n      maxLength = stats[encoding.fieldName(x)].maxlength;\n    } else if (encoding.aggr(x) === 'count') {\n      //assign default value for count as it won't have stats\n      maxLength =  3;\n    } else if (encoding.isType(x, Q)) {\n      if (x===X) {\n        maxLength = 3;\n      } else { // Y\n        //assume that default formating is always shorter than 7\n        maxLength = Math.min(stats[encoding.fieldName(x)].maxlength, 7);\n      }\n    }\n    setter(layout,[x, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + 20);\n  });\n  return layout;\n}\n\n},{\"../field\":23,\"../globals\":24,\"../schema/schema\":25,\"../util\":27,\"./time\":19}],11:[function(require,module,exports){\n'use strict';\n\nvar global = require('../globals'),\n  time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vegalite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props, fn;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) &&\n    time.hasScale(fn)) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ fn;\n  }\n\n  return def;\n};\n\n},{\"../globals\":24,\"./time\":19}],12:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlscale = require('./scale');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.field(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, alpha: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: e.scale(X).type === 'log' ? 1 : 0};\n    }\n  } else if (e.has(X)) { // is ordinal\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    // TODO add single bar offset\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: e.scale(Y).type === 'log' ? 1 : 0};\n  } else if (e.has(Y)) { // is ordinal\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    // TODO add single bar offset\n    p.yc = {group: 'height'};\n  }\n\n  // width\n  if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.width = {\n        value: e.bandSize(X, layout.x.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // X is Quant or Time Scale\n    p.width = {value: 2};\n  }\n\n  // height\n  if (!e.has(Y) || e.isOrdinalScale(Y)) { // no Y or Y is ordinal\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // Y is Quant or Time Scale\n    p.height = {value: 2};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction line_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    } else if (e.value(ALPHA) !== undefined) {\n      p.opacity = {value: e.value(ALPHA)};\n    } else if (!e.has(COLOR)) {\n      p.opacity = {value: style.opacity};\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: e.font('size')};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: 'black'};\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else {\n    p.opacity = {value: style.opacity};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      p.text = {template: \"{{\" + e.field(TEXT) + \" | number:'.3s'}}\"};\n      p.align = {value: 'right'};\n    } else {\n      p.text = {field: e.field(TEXT)};\n    }\n  } else {\n    p.text = {value: 'Abc'};\n  }\n\n  p.font = {value: e.font('family')};\n  p.fontWeight = {value: e.font('weight')};\n  p.fontStyle = {value: e.font('style')};\n  p.baseline = {value: e.text('baseline')};\n\n  return p;\n}\n\n},{\"../globals\":24,\"../util\":27,\"./scale\":13}],13:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  time = require('./time');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale_domain(name, encoding, sorting, opt)\n    };\n    if (s.type === 'ordinal' && !encoding.bin(name) && encoding.sort(name).length === 0) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, layout, style, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case O: return 'ordinal';\n    case T:\n      var fn = encoding.fn(name);\n      return (fn && time.scale.type(fn, name)) || 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nfunction scale_domain(name, encoding, sorting, opt) {\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encoding.fn(name), name);\n    if(range) return range;\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)], encoding.bin(name).maxbins);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name === Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: 'data.' + (opt.facet ? 'max_' : '') + 'sum_' + encoding.field(name, true)\n    } :\n    {data: sorting.getDataset(name), field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, layout, style, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name);\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name) || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      var range = encoding.scale(COLOR).range;\n      if (range === undefined) {\n        if (s.type === 'ordinal') {\n          // FIXME\n          range = style.colorRange;\n        } else {\n          range = ['#A9DB9F', '#0D5C21'];\n          s.zero = false;\n        }\n      }\n      s.range = range;\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.band(s.name).padding;\n      }\n  }\n}\n\n},{\"../globals\":24,\"../util\":27,\"./time\":19}],14:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(spec, encoding, stats, opt) {\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggr,\n          field: 'data.' + d.name\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + 'data.' + (d.aggr==='count' ? 'count' : (d.aggr + '_' + d.name));\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: ['data.' + field.name],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      spec.data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    spec: spec,\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n\n},{\"../globals\":24}],15:[function(require,module,exports){\n\"use strict\";\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{op: 'max', field: 'data.sum_' + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n\n},{\"../globals\":24,\"../util\":27,\"./marks\":12}],16:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlfield = require('../field'),\n  Encoding = require('../Encoding');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n    colorRange: colorRange(encoding, stats)\n  };\n};\n\nfunction colorRange(encoding, stats){\n  if (encoding.has(COLOR) && encoding.isDimension(COLOR)) {\n    var cardinality = encoding.cardinality(COLOR, stats);\n    if (cardinality <= 10) {\n      return \"category10\";\n    } else {\n      return \"category20\";\n    }\n    // TODO can vega interpolate range for ordinal scale?\n  }\n  return null;\n}\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field, true))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n\n},{\"../Encoding\":2,\"../field\":23,\"../globals\":24,\"../util\":27}],17:[function(require,module,exports){\n'use strict';\n\nvar global = require('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.field(COLOR)});\n  }\n}\n\n},{\"../globals\":24,\"./group\":9}],18:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals');\n\nvar groupdef = require('./group').def,\n  vldata = require('../data');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) { //hack use stats\n\n  var data = {name: RAW, format: {type: encoding.data('formatType')}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = vldata.getUrl(encoding, stats);\n  if (dataUrl) data.url = dataUrl;\n\n  var preaggregatedData = !!encoding.data('vegaServer');\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (field.aggr === 'count') {\n        name = 'count';\n      } else if (preaggregatedData && field.bin) {\n        name = 'bin_' + field.name;\n      } else if (preaggregatedData && field.aggr) {\n        name = field.aggr + '_' + field.name;\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n\n},{\"../data\":21,\"../globals\":24,\"./group\":9}],19:[function(require,module,exports){\n'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt) {\n  var timeFields = {}, timeFn = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.fn) {\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeFn[field.fn] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[1],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var fn in timeFn) {\n    time.scale(scales, fn, encoding);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var fn = field.fn;\n  switch (fn) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.cardinality -\n        (stat.numNulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.fn, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\n/** append custom time scales for axis label */\ntime.scale = function(scales, fn, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength');\n  // TODO add option for shorter scale / custom range\n  switch (fn) {\n    case 'day':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 7),\n        range: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(\n          function(s) { return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case 'month':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 12),\n        range: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(\n            function(s) { return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n\ntime.isOrdinalFn = function(fn) {\n  switch (fn) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(fn, name) {\n  if (name === COLOR) {\n    return 'linear'; // this has order\n  }\n\n  return time.isOrdinalFn(fn) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(fn, name) {\n  var isColor = name === COLOR;\n  switch (fn) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(fn) {\n  switch (fn) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n\n\n},{\"../globals\":24,\"../util\":27}],20:[function(require,module,exports){\n'use strict';\n\nvar globals = require('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT, DETAIL];\n\nconsts.dataTypes = {'O': O, 'Q': Q, 'T': T};\n\nconsts.dataTypeNames = ['O', 'Q', 'T'].reduce(function(r, x) {\n  r[consts.dataTypes[x]] = x;\n  return r;\n},{});\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n\n},{\"./globals\":24}],21:[function(require,module,exports){\n'use strict';\n\n// TODO: rename getDataUrl to vl.data.getUrl() ?\n\nvar util = require('./util');\n\nvar vldata = module.exports = {},\n  vlfield = require('./field');\n\nvldata.getUrl = function getDataUrl(encoding, stats) {\n  if (!encoding.data('vegaServer')) {\n    // don't use vega server\n    return encoding.data('url');\n  }\n\n  if (encoding.length() === 0) {\n    // no fields\n    return;\n  }\n\n  var fields = [];\n  encoding.forEach(function(field, encType) {\n    var obj = {\n      name: encoding.field(encType, true),\n      field: field.name\n    };\n    if (field.aggr) {\n      obj.aggr = field.aggr;\n    }\n    if (field.bin) {\n      obj.binSize = util.getbins(stats[field.name], encoding.bin(encType).maxbins).step;\n    }\n    fields.push(obj);\n  });\n\n  var query = {\n    table: encoding.data('vegaServer').table,\n    fields: fields\n  };\n\n  return encoding.data('vegaServer').url + '/query/?q=' + JSON.stringify(query);\n};\n\n/**\n * @param  {Object} data data in JSON/javascript object format\n * @return Array of {name: __name__, type: \"number|text|time|location\"}\n */\nvldata.getSchema = function(data, order) {\n  var schema = [],\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    // find non-null data\n    var i = 0, datum = data[i][k];\n    while (datum === '' || datum === null || datum === undefined) {\n      datum = data[++i][k];\n      if (i >= data.length) {\n        datum = '';\n        break;\n      }\n    }\n\n    datum = util.parse(datum);\n    var type = (typeof datum === 'number') ? 'Q':\n      (datum instanceof Date) ? 'T' : 'O';\n\n    schema.push({name: k, type: type});\n  });\n\n  schema = util.stablesort(schema, order || vlfield.order.typeThenName, vlfield.order.name);\n\n  return schema;\n};\n\nvldata.getStats = function(data) { // hack\n  var stats = {},\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    var column = data.map(function(d) {return d[k];});\n\n    // Hack\n    var val = util.parse(data[0][k]);\n    var type = (typeof val === 'number') ? 'Q':\n      (val instanceof Date) ? 'T' : 'O';\n\n    var stat = {};\n    if (typeof val === 'number') {\n      stat = util.minmax(util.numbers(column));\n    } else if (val instanceof Date) {\n      stat = util.minmax(util.dates(column));\n    } else {\n      stat = util.minmax(column);\n    }\n\n    stat.cardinality = util.uniq(data, k);\n    stat.count = data.length;\n\n    stat.maxlength = data.reduce(function(max,row) {\n      if (row[k] === null) {\n        return max;\n      }\n      var len = row[k].toString().length;\n      return len > max ? len : max;\n    }, 0);\n\n    stat.numNulls = data.reduce(function(count, row) {\n      return row[k] === null ? count + 1 : count;\n    }, 0);\n\n    var numbers = util.numbers(column);\n\n    if (numbers.length > 0) {\n      stat.skew = util.skew(numbers);\n      stat.stdev = util.stdev(numbers);\n      stat.mean = util.mean(numbers);\n      stat.median = util.median(numbers);\n    }\n\n    var sample = {};\n    while(Object.keys(sample).length < Math.min(stat.cardinality, 10)) {\n      var value = data[Math.floor(Math.random() * data.length)][k];\n      sample[value] = true;\n    }\n    stat.sample = Object.keys(sample);\n\n    stats[k] = stat;\n  });\n  stats.count = data.length;\n  return stats;\n};\n\n},{\"./field\":23,\"./util\":27}],22:[function(require,module,exports){\n// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.alpha) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggr) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init, i = 0, k;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field, encType) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand, convertType) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field, convertType);\n    return m;\n  }, {});\n};\n},{\"./compile/time\":19,\"./consts\":20,\"./field\":23,\"./schema/schema\":25,\"./util\":27}],23:[function(require,module,exports){\n'use strict';\n\n// utility for field\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggr ? f.aggr + c.func : '') +\n    (f.fn ? f.fn + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type +\n    (consts.dataTypeNames[f.type] || f.type);\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand, convertType) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: convertType ? consts.dataTypes[split[1].trim()] : split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggr.enum) {\n    var a = schema.aggr.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggr = a;\n      break;\n    }\n  }\n\n  // check time fn\n  for (i in schema.timefns) {\n    var f = schema.timefns[i];\n    if (o.name && o.name.indexOf(f + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.fn = f;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar typeOrder = {\n  O: 0,\n  G: 1,\n  T: 2,\n  Q: 3\n};\n\nvlfield.order = {};\n\nvlfield.order.type = function(field) {\n  if (field.aggr==='count') return 4;\n  return typeOrder[field.type];\n};\n\nvlfield.order.typeThenName = function(field) {\n  return vlfield.order.type(field) + '_' + field.name.toLowerCase();\n};\n\nvlfield.order.original = function() {\n  return 0; // no swap will occur\n};\n\nvlfield.order.name = function(field) {\n  return field.name;\n};\n\nvlfield.order.typeThenCardinality = function(field, stats){\n  return stats[field.name].cardinality;\n};\n\n// FIXME refactor\nvlfield.isType = function (fieldDef, type) {\n  return (fieldDef.type & type) > 0;\n};\n\nvlfield.isType.byCode = vlfield.isType;\n\nvlfield.isType.byName = function (field, type) {\n  return field.type === consts.dataTypeNames[type];\n};\n\n\nfunction getIsType(useTypeCode) {\n  return useTypeCode ? vlfield.isType.byCode : vlfield.isType.byName;\n}\n\nvlfield.isType.get = getIsType; //FIXME\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || field.bin ||\n    ( isType(field, T) && field.fn && time.isOrdinalFn(field.fn) );\n};\n\nfunction isDimension(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || !!field.bin ||\n    ( isType(field, T) && !!field.fn );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field, useTypeCode /*optional*/) {\n  return field && isDimension(field, useTypeCode);\n};\n\nvlfield.isMeasure = function(field, useTypeCode) {\n  return field && !isDimension(field, useTypeCode);\n};\n\nvlfield.role = function(field) {\n  return isDimension(field) ? 'dimension' : 'measure';\n};\n\nvlfield.count = function() {\n  return {name:'*', aggr: 'count', type:'Q', displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggr === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull, useTypeCode) {\n  // FIXME need to take filter into account\n  var isType = getIsType(useTypeCode),\n    type = useTypeCode ? consts.dataTypeNames[field.type] : field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stats[field.name], field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggr) {\n    return 1;\n  }\n\n  // remove null\n  var stat = stats[field.name];\n  return stat.cardinality -\n    (stat.numNulls > 0 && filterNull[type] ? 1 : 0);\n};\n\n},{\"./compile/time\":19,\"./consts\":20,\"./schema/schema\":25,\"./util\":27}],24:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],25:[function(require,module,exports){\n// Package of defining Vegalite Specification's json schema\n\"use strict\";\n\nvar schema = module.exports = {},\n  util = require('../util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggr = {\n  type: 'string',\n  enum: ['avg', 'sum', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'sum', 'min', 'max', 'count'],\n    O: [],\n    T: ['avg', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: {'Q': true, 'O': true, 'T': true, '': true}\n};\nschema.band = {\n  type: 'object',\n  properties: {\n    size: {\n      type: 'integer',\n      minimum: 0\n    },\n    padding: {\n      type: 'integer',\n      minimum: 0,\n      default: 1\n    }\n  }\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.enc.properties[encType].supportedRole;\n};\n\nschema.timefns = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.fn = {\n  type: 'string',\n  enum: schema.timefns,\n  supportedTypes: {'T': true}\n};\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: 'string',\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: {'Q': true}\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2\n    }\n  },\n  supportedTypes: {'Q': true} // TODO: add 'O' after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O', 'Q', 'T']\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: {'T': true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O','Q', 'T'] // ordinal-only field supports Q when bin is applied and T when fn is applied.\n    },\n    fn: schema.fn,\n    bin: bin,\n    aggr: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: {'O': true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        title: {\n          type: 'boolean',\n          default: true,\n          description: 'A title for the axis.'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: {'O': true},\n        required: ['name', 'aggr'],\n        name: {\n          type: 'string'\n        },\n        aggr: {\n          type: 'string',\n          enum: ['avg', 'sum', 'min', 'max', 'count']\n        },\n        reverse: {\n          type: 'boolean',\n          default: false\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: schema.band\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    text: {\n      type: 'object',\n      properties: {\n        align: {\n          type: 'string',\n          default: 'left'\n        },\n        baseline: {\n          type: 'string',\n          default: 'middle'\n        },\n        margin: {\n          type: 'integer',\n          default: 4,\n          minimum: 0\n        }\n      }\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    }\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array']\n        }\n      }\n    }\n  }\n};\n\nvar alphaMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    grid: {\n      type: 'boolean',\n      default: true,\n      description: 'A flag indicate if gridlines should be created in addition to ticks.'\n    },\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using alpha / size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\nvar alpha = merge(clone(quantitativeField), alphaMixin, sortMixin);\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    vegaServer: {\n      type: 'object',\n      default: null,\n      properties: {\n        table: {\n          type: 'string',\n          default: undefined\n        },\n        url: {\n          type: 'string',\n          default: 'http://localhost:3001'\n        }\n      }\n    }\n  }\n};\n\nconsole.log(schema.util.instantiate(data));\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#eeeeee'\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: 'O'\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#aaaaaa'\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    }\n  }\n};\n\n/** @type Object Schema of a vegalite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for vegalite specification',\n  type: 'object',\n  required: ['marktype', 'enc', 'data', 'config'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    enc: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.enc.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n\n},{\"../util\":27,\"./schemautil\":26}],26:[function(require,module,exports){\n'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}\n},{\"../util\":27}],27:[function(require,module,exports){\n'use strict';\n\nvar util = module.exports = {};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.vals = function(obj) {\n  var v = [], x;\n  for (x in obj) v.push(obj[x]);\n  return v;\n};\n\nutil.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\nutil.find = function(list, pattern) {\n  var l = list.filter(function(x) {\n    return x[pattern.name] === pattern.value;\n  });\n  return l.length && l[0] || null;\n};\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.uniq = function(data, field) {\n  var map = {}, count = 0, i, k;\n  for (i = 0; i < data.length; ++i) {\n    k = data[i][field];\n    if (!map[k]) {\n      map[k] = 1;\n      count += 1;\n    }\n  }\n  return count;\n};\n\nvar isNumber = function(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\n// try parsing to number\nutil.numbers = function(values) {\n  var nums = [];\n  for (var i = 0; i < values.length; i++) {\n    if (isNumber(values[i])) {\n      nums.push(+values[i]);\n    }\n  }\n  return nums;\n};\n\n// try to parse as date\nutil.dates = function(values) {\n  var dates = [];\n  for (var i = 0; i < values.length; i++) {\n    var date = Date.parse(values[i]);\n    if (!isNaN(date)) {\n      dates.push(new Date(date));\n    }\n  }\n  return dates;\n};\n\nutil.median = function(values) {\n  values.sort(function(a, b) {return a - b;});\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\nutil.mean = function(values) {\n  return values.reduce(function(v, r) {return v + r;}, 0) / values.length;\n};\n\nutil.variance = function(values) {\n  var avg = util.mean(values);\n  var diffs = [];\n  for (var i = 0; i < values.length; i++) {\n    diffs.push(Math.pow((values[i] - avg), 2));\n  }\n  return util.mean(diffs);\n};\n\nutil.stablesort = function(array, sortBy, keyFn) {\n  var indices = {};\n\n  array.forEach(function(v, i) {\n    indices[keyFn(v)] = i;\n  });\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n      sb = sortBy(b);\n\n    return sa<sb ? -1 : sa>sb ? 1 : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n  return array;\n};\n\nutil.stdev = function(values) {\n  return Math.sqrt(util.variance(values));\n};\n\nutil.skew = function(values) {\n  var avg = util.mean(values),\n    med = util.median(values),\n    std = util.stdev(values);\n  return 1.0 * (avg - med) / std;\n};\n\n// parses a string to date or number\nutil.parse = function(value) {\n  if (isNumber(value)) {\n    return +value;\n  }\n\n  var date = Date.parse(value);\n  if (!isNaN(date)) {\n    return (new Date(date));\n  }\n  return value;\n};\n\nutil.minmax = function(data) {\n  var stats = {min: +Infinity, max: -Infinity};\n  for (var i = 0; i < data.length; ++i) {\n    var v = data[i];\n    if (v !== null) {\n      if (v > stats.max || stats.max === -Infinity) stats.max = v;\n      if (v < stats.min || stats.min === +Infinity) stats.min = v;\n    }\n  }\n  return stats;\n};\n\nutil.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nutil.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nutil.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nutil.array = function(x) {\n  return x ? (util.isArray(x) ? x : [x]) : [];\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\n\nutil.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nvar merge = function(dest, src) {\n  return util.keys(src).reduce(function(c, k) {\n    c[k] = src[k];\n    return c;\n  }, dest);\n};\n\nutil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bins({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n\nutil.bins = function(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 1024,\n      base = opt.base || 10,\n      div = opt.div || [5, 2],\n      mins = opt.minstep || 0,\n      logb = Math.log(base),\n      level = Math.ceil(Math.log(maxb) / logb),\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step = Math.max(mins, Math.pow(base, Math.round(Math.log(span) / logb) - level)),\n      nbins = Math.ceil(span / step),\n      precision, v, i, eps;\n\n  if (opt.step) {\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n        opt.steps.length - 1,\n        util_bisectLeft(opt.steps, span / maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // increase step size if too many bins\n    do {\n      step *= base;\n      nbins = Math.ceil(span / step);\n    } while (nbins > maxb);\n\n    // decrease step size if allowed\n    for (i = 0; i < div.length; ++i) {\n      v = step / div[i];\n      if (v >= mins && span / v <= maxb) {\n        step = v;\n        nbins = Math.ceil(span / step);\n      }\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = (min<0 ? -1 : 1) * Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop: max,\n    step: step,\n    unit: precision\n  };\n};\n\nfunction util_bisectLeft(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis || \"...\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? vg_truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? vg_truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis +\n        (word ? vg_truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? vg_truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction vg_truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(vg_truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar vg_truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n\n},{}]},{},[1])(1)\n});\n//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJzcmMvdmwiLCJzcmMvRW5jb2RpbmcuanMiLCJzcmMvY29tcGlsZS9hZ2dyZWdhdGUuanMiLCJzcmMvY29tcGlsZS9heGlzLmpzIiwic3JjL2NvbXBpbGUvYmluLmpzIiwic3JjL2NvbXBpbGUvY29tcGlsZS5qcyIsInNyYy9jb21waWxlL2ZhY2V0LmpzIiwic3JjL2NvbXBpbGUvZmlsdGVyLmpzIiwic3JjL2NvbXBpbGUvZ3JvdXAuanMiLCJzcmMvY29tcGlsZS9sYXlvdXQuanMiLCJzcmMvY29tcGlsZS9sZWdlbmQuanMiLCJzcmMvY29tcGlsZS9tYXJrcy5qcyIsInNyYy9jb21waWxlL3NjYWxlLmpzIiwic3JjL2NvbXBpbGUvc29ydC5qcyIsInNyYy9jb21waWxlL3N0YWNrLmpzIiwic3JjL2NvbXBpbGUvc3R5bGUuanMiLCJzcmMvY29tcGlsZS9zdWJmYWNldC5qcyIsInNyYy9jb21waWxlL3RlbXBsYXRlLmpzIiwic3JjL2NvbXBpbGUvdGltZS5qcyIsInNyYy9jb25zdHMuanMiLCJzcmMvZGF0YS5qcyIsInNyYy9lbmMuanMiLCJzcmMvZmllbGQuanMiLCJzcmMvZ2xvYmFscy5qcyIsInNyYy9zY2hlbWEvc2NoZW1hLmpzIiwic3JjL3NjaGVtYS9zY2hlbWF1dGlsLmpzIiwic3JjL3V0aWwuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNySEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6SkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN2TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5bUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0RkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4vZ2xvYmFscycpLFxuICAgIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgICBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpO1xuXG52YXIgdmwgPSB1dGlsLm1lcmdlKGNvbnN0cywgdXRpbCk7XG5cbnZsLnZlcnNpb24gPSBcIjAuNi4yXCI7XG5cbnZsLkVuY29kaW5nID0gcmVxdWlyZSgnLi9FbmNvZGluZycpO1xudmwuY29tcGlsZSA9IHJlcXVpcmUoJy4vY29tcGlsZS9jb21waWxlJyk7XG52bC5kYXRhID0gcmVxdWlyZSgnLi9kYXRhJyk7XG52bC5maWVsZCA9IHJlcXVpcmUoJy4vZmllbGQnKTtcbnZsLmVuYyA9IHJlcXVpcmUoJy4vZW5jJyk7XG52bC5zY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKTtcbnZsLnRvU2hvcnRoYW5kID0gdmwuRW5jb2Rpbmcuc2hvcnRoYW5kO1xuXG5cbm1vZHVsZS5leHBvcnRzID0gdmw7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi9nbG9iYWxzJyksXG4gIGNvbnN0cyA9IHJlcXVpcmUoJy4vY29uc3RzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuL3V0aWwnKSxcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4vZmllbGQnKSxcbiAgdmxlbmMgPSByZXF1aXJlKCcuL2VuYycpLFxuICBzY2hlbWEgPSByZXF1aXJlKCcuL3NjaGVtYS9zY2hlbWEnKSxcbiAgdGltZSA9IHJlcXVpcmUoJy4vY29tcGlsZS90aW1lJyk7XG5cbnZhciBFbmNvZGluZyA9IG1vZHVsZS5leHBvcnRzID0gKGZ1bmN0aW9uKCkge1xuXG4gIGZ1bmN0aW9uIEVuY29kaW5nKG1hcmt0eXBlLCBlbmMsIGRhdGEsIGNvbmZpZywgZmlsdGVyLCB0aGVtZSkge1xuICAgIHZhciBkZWZhdWx0cyA9IHNjaGVtYS5pbnN0YW50aWF0ZSgpO1xuXG4gICAgdmFyIHNwZWMgPSB7XG4gICAgICBkYXRhOiBkYXRhLFxuICAgICAgbWFya3R5cGU6IG1hcmt0eXBlLFxuICAgICAgZW5jOiBlbmMsXG4gICAgICBjb25maWc6IGNvbmZpZyxcbiAgICAgIGZpbHRlcjogZmlsdGVyIHx8IFtdXG4gICAgfTtcblxuICAgIC8vIHR5cGUgdG8gYml0Y29kZVxuICAgIGZvciAodmFyIGUgaW4gZGVmYXVsdHMuZW5jKSB7XG4gICAgICBkZWZhdWx0cy5lbmNbZV0udHlwZSA9IGNvbnN0cy5kYXRhVHlwZXNbZGVmYXVsdHMuZW5jW2VdLnR5cGVdO1xuICAgIH1cblxuICAgIHZhciBzcGVjRXh0ZW5kZWQgPSBzY2hlbWEudXRpbC5tZXJnZShkZWZhdWx0cywgdGhlbWUgfHwge30sIHNwZWMpIDtcblxuICAgIHRoaXMuX2RhdGEgPSBzcGVjRXh0ZW5kZWQuZGF0YTtcbiAgICB0aGlzLl9tYXJrdHlwZSA9IHNwZWNFeHRlbmRlZC5tYXJrdHlwZTtcbiAgICB0aGlzLl9lbmMgPSBzcGVjRXh0ZW5kZWQuZW5jO1xuICAgIHRoaXMuX2NvbmZpZyA9IHNwZWNFeHRlbmRlZC5jb25maWc7XG4gICAgdGhpcy5fZmlsdGVyID0gc3BlY0V4dGVuZGVkLmZpbHRlcjtcbiAgfVxuXG4gIHZhciBwcm90byA9IEVuY29kaW5nLnByb3RvdHlwZTtcblxuICBwcm90by5tYXJrdHlwZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl9tYXJrdHlwZTtcbiAgfTtcblxuICBwcm90by5pcyA9IGZ1bmN0aW9uKG0pIHtcbiAgICByZXR1cm4gdGhpcy5fbWFya3R5cGUgPT09IG07XG4gIH07XG5cbiAgcHJvdG8uaGFzID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIC8vIGVxdWl2YWxlbnQgdG8gY2FsbGluZyB2bGVuYy5oYXModGhpcy5fZW5jLCBlbmNUeXBlKVxuICAgIHJldHVybiB0aGlzLl9lbmNbZW5jVHlwZV0ubmFtZSAhPT0gdW5kZWZpbmVkO1xuICB9O1xuXG4gIHByb3RvLmVuYyA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF07XG4gIH07XG5cbiAgcHJvdG8uZmlsdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGZpbHRlck51bGwgPSBbXSxcbiAgICAgIGZpZWxkcyA9IHRoaXMuZmllbGRzKCksXG4gICAgICBzZWxmID0gdGhpcztcblxuICAgIHV0aWwuZm9yRWFjaChmaWVsZHMsIGZ1bmN0aW9uKGZpZWxkTGlzdCwgZmllbGROYW1lKSB7XG4gICAgICBpZiAoZmllbGROYW1lID09PSAnKicpIHJldHVybjsgLy9jb3VudFxuXG4gICAgICBpZiAoKHNlbGYuY29uZmlnKCdmaWx0ZXJOdWxsJykuUSAmJiBmaWVsZExpc3QuY29udGFpbnNUeXBlW1FdKSB8fFxuICAgICAgICAgIChzZWxmLmNvbmZpZygnZmlsdGVyTnVsbCcpLlQgJiYgZmllbGRMaXN0LmNvbnRhaW5zVHlwZVtUXSkgfHxcbiAgICAgICAgICAoc2VsZi5jb25maWcoJ2ZpbHRlck51bGwnKS5PICYmIGZpZWxkTGlzdC5jb250YWluc1R5cGVbT10pKSB7XG4gICAgICAgIGZpbHRlck51bGwucHVzaCh7XG4gICAgICAgICAgb3BlcmFuZHM6IFtmaWVsZE5hbWVdLFxuICAgICAgICAgIG9wZXJhdG9yOiAnbm90TnVsbCdcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmlsdGVyTnVsbC5jb25jYXQodGhpcy5fZmlsdGVyKTtcbiAgfTtcblxuICAvLyBnZXQgXCJmaWVsZFwiIHByb3BlcnR5IGZvciB2ZWdhXG4gIHByb3RvLmZpZWxkID0gZnVuY3Rpb24oZXQsIG5vZGF0YSwgbm9mbikge1xuICAgIGlmICghdGhpcy5oYXMoZXQpKSByZXR1cm4gbnVsbDtcblxuICAgIHZhciBmID0gKG5vZGF0YSA/ICcnIDogJ2RhdGEuJyk7XG5cbiAgICBpZiAodGhpcy5fZW5jW2V0XS5hZ2dyID09PSAnY291bnQnKSB7XG4gICAgICByZXR1cm4gZiArICdjb3VudCc7XG4gICAgfSBlbHNlIGlmICghbm9mbiAmJiB0aGlzLl9lbmNbZXRdLmJpbikge1xuICAgICAgcmV0dXJuIGYgKyAnYmluXycgKyB0aGlzLl9lbmNbZXRdLm5hbWU7XG4gICAgfSBlbHNlIGlmICghbm9mbiAmJiB0aGlzLl9lbmNbZXRdLmFnZ3IpIHtcbiAgICAgIHJldHVybiBmICsgdGhpcy5fZW5jW2V0XS5hZ2dyICsgJ18nICsgdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH0gZWxzZSBpZiAoIW5vZm4gJiYgdGhpcy5fZW5jW2V0XS5mbikge1xuICAgICAgcmV0dXJuIGYgKyB0aGlzLl9lbmNbZXRdLmZuICsgJ18nICsgdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZiArIHRoaXMuX2VuY1tldF0ubmFtZTtcbiAgICB9XG4gIH07XG5cbiAgcHJvdG8uZmllbGROYW1lID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICB9O1xuXG4gIC8qXG4gICAqIHJldHVybiBrZXktdmFsdWUgcGFpcnMgb2YgZmllbGQgbmFtZSBhbmQgbGlzdCBvZiBmaWVsZHMgb2YgdGhhdCBmaWVsZCBuYW1lXG4gICAqL1xuICBwcm90by5maWVsZHMgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmxlbmMuZmllbGRzKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgcHJvdG8uZmllbGRUaXRsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgaWYgKHZsZmllbGQuaXNDb3VudCh0aGlzLl9lbmNbZXRdKSkge1xuICAgICAgcmV0dXJuIHZsZmllbGQuY291bnQuZGlzcGxheU5hbWU7XG4gICAgfVxuICAgIHZhciBmbiA9IHRoaXMuX2VuY1tldF0uYWdnciB8fCB0aGlzLl9lbmNbZXRdLmZuIHx8ICh0aGlzLl9lbmNbZXRdLmJpbiAmJiBcImJpblwiKTtcbiAgICBpZiAoZm4pIHtcbiAgICAgIHJldHVybiBmbi50b1VwcGVyQ2FzZSgpICsgJygnICsgdGhpcy5fZW5jW2V0XS5uYW1lICsgJyknO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5uYW1lO1xuICAgIH1cbiAgfTtcblxuICBwcm90by5zY2FsZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uc2NhbGUgfHwge307XG4gIH07XG5cbiAgcHJvdG8uYXhpcyA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYXhpcyB8fCB7fTtcbiAgfTtcblxuICBwcm90by5iYW5kID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5fZW5jW2V0XS5iYW5kIHx8IHt9O1xuICB9O1xuXG4gIHByb3RvLmJhbmRTaXplID0gZnVuY3Rpb24oZW5jVHlwZSwgdXNlU21hbGxCYW5kKSB7XG4gICAgdXNlU21hbGxCYW5kID0gdXNlU21hbGxCYW5kIHx8XG4gICAgICAvL2lzQmFuZEluU21hbGxNdWx0aXBsZXNcbiAgICAgIChlbmNUeXBlID09PSBZICYmIHRoaXMuaGFzKFJPVykgJiYgdGhpcy5oYXMoWSkpIHx8XG4gICAgICAoZW5jVHlwZSA9PT0gWCAmJiB0aGlzLmhhcyhDT0wpICYmIHRoaXMuaGFzKFgpKTtcblxuICAgIC8vIGlmIGJhbmQuc2l6ZSBpcyBleHBsaWNpdGx5IHNwZWNpZmllZCwgZm9sbG93IHRoZSBzcGVjaWZpY2F0aW9uLCBvdGhlcndpc2UgZHJhdyB2YWx1ZSBmcm9tIGNvbmZpZy5cbiAgICByZXR1cm4gdGhpcy5iYW5kKGVuY1R5cGUpLnNpemUgfHxcbiAgICAgIHRoaXMuY29uZmlnKHVzZVNtYWxsQmFuZCA/ICdzbWFsbEJhbmRTaXplJyA6ICdsYXJnZUJhbmRTaXplJyk7XG4gIH07XG5cbiAgcHJvdG8uYWdnciA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0uYWdncjtcbiAgfTtcblxuICAvLyByZXR1cm5zIGZhbHNlIGlmIGJpbm5pbmcgaXMgZGlzYWJsZWQsIG90aGVyd2lzZSBhbiBvYmplY3Qgd2l0aCBiaW5uaW5nIHByb3BlcnRpZXNcbiAgcHJvdG8uYmluID0gZnVuY3Rpb24oZXQpIHtcbiAgICB2YXIgYmluID0gdGhpcy5fZW5jW2V0XS5iaW47XG4gICAgaWYgKGJpbiA9PT0ge30pXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGJpbiA9PT0gdHJ1ZSlcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG1heGJpbnM6IHNjaGVtYS5NQVhCSU5TX0RFRkFVTFRcbiAgICAgIH07XG4gICAgcmV0dXJuIGJpbjtcbiAgfTtcblxuICBwcm90by5sZWdlbmQgPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLmxlZ2VuZDtcbiAgfTtcblxuICBwcm90by52YWx1ZSA9IGZ1bmN0aW9uKGV0KSB7XG4gICAgcmV0dXJuIHRoaXMuX2VuY1tldF0udmFsdWU7XG4gIH07XG5cbiAgcHJvdG8uZm4gPSBmdW5jdGlvbihldCkge1xuICAgIHJldHVybiB0aGlzLl9lbmNbZXRdLmZuO1xuICB9O1xuXG4gIHByb3RvLnNvcnQgPSBmdW5jdGlvbihldCwgc3RhdHMpIHtcbiAgICB2YXIgc29ydCA9IHRoaXMuX2VuY1tldF0uc29ydCxcbiAgICAgIGVuYyA9IHRoaXMuX2VuYyxcbiAgICAgIGlzVHlwZSA9IHZsZmllbGQuaXNUeXBlLmJ5Q29kZTtcblxuICAgIC8vIGNvbnNvbGUubG9nKCdzb3J0OicsIHNvcnQsICdzdXBwb3J0OicsIEVuY29kaW5nLnRvZ2dsZVNvcnQuc3VwcG9ydCh7ZW5jOnRoaXMuX2VuY30sIHN0YXRzKSAsICd0b2dnbGU6JywgdGhpcy5jb25maWcoJ3RvZ2dsZVNvcnQnKSlcblxuICAgIGlmICgoIXNvcnQgfHwgc29ydC5sZW5ndGg9PT0wKSAmJlxuICAgICAgICBFbmNvZGluZy50b2dnbGVTb3J0LnN1cHBvcnQoe2VuYzp0aGlzLl9lbmN9LCBzdGF0cywgdHJ1ZSkgJiYgLy9IQUNLXG4gICAgICAgIHRoaXMuY29uZmlnKCd0b2dnbGVTb3J0JykgPT09ICdRJ1xuICAgICAgKSB7XG4gICAgICB2YXIgcUZpZWxkID0gaXNUeXBlKGVuYy54LCBPKSA/IGVuYy55IDogZW5jLng7XG5cbiAgICAgIGlmIChpc1R5cGUoZW5jW2V0XSwgTykpIHtcbiAgICAgICAgc29ydCA9IFt7XG4gICAgICAgICAgbmFtZTogcUZpZWxkLm5hbWUsXG4gICAgICAgICAgYWdncjogcUZpZWxkLmFnZ3IsXG4gICAgICAgICAgdHlwZTogcUZpZWxkLnR5cGUsXG4gICAgICAgICAgcmV2ZXJzZTogdHJ1ZVxuICAgICAgICB9XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gc29ydDtcbiAgfTtcblxuICBwcm90by5hbnkgPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHV0aWwuYW55KHRoaXMuX2VuYywgZik7XG4gIH07XG5cbiAgcHJvdG8uYWxsID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB1dGlsLmFsbCh0aGlzLl9lbmMsIGYpO1xuICB9O1xuXG4gIHByb3RvLmxlbmd0aCA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB1dGlsLmtleXModGhpcy5fZW5jKS5sZW5ndGg7XG4gIH07XG5cbiAgcHJvdG8ubWFwID0gZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB2bGVuYy5tYXAodGhpcy5fZW5jLCBmKTtcbiAgfTtcblxuICBwcm90by5yZWR1Y2UgPSBmdW5jdGlvbihmLCBpbml0KSB7XG4gICAgcmV0dXJuIHZsZW5jLnJlZHVjZSh0aGlzLl9lbmMsIGYsIGluaXQpO1xuICB9O1xuXG4gIHByb3RvLmZvckVhY2ggPSBmdW5jdGlvbihmKSB7XG4gICAgcmV0dXJuIHZsZW5jLmZvckVhY2godGhpcy5fZW5jLCBmKTtcbiAgfTtcblxuICBwcm90by50eXBlID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoZXQpID8gdGhpcy5fZW5jW2V0XS50eXBlIDogbnVsbDtcbiAgfTtcblxuICBwcm90by5yb2xlID0gZnVuY3Rpb24oZXQpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoZXQpID8gdmxmaWVsZC5yb2xlKHRoaXMuX2VuY1tldF0pIDogbnVsbDtcbiAgfTtcblxuICBwcm90by50ZXh0ID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHZhciB0ZXh0ID0gdGhpcy5fZW5jW1RFWFRdLnRleHQ7XG4gICAgcmV0dXJuIHByb3AgPyB0ZXh0W3Byb3BdIDogdGV4dDtcbiAgfTtcblxuICBwcm90by5mb250ID0gZnVuY3Rpb24ocHJvcCkge1xuICAgIHZhciBmb250ID0gdGhpcy5fZW5jW1RFWFRdLmZvbnQ7XG4gICAgcmV0dXJuIHByb3AgPyBmb250W3Byb3BdIDogZm9udDtcbiAgfTtcblxuICBwcm90by5pc1R5cGUgPSBmdW5jdGlvbihldCwgdHlwZSkge1xuICAgIHZhciBmaWVsZCA9IHRoaXMuZW5jKGV0KTtcbiAgICByZXR1cm4gZmllbGQgJiYgRW5jb2RpbmcuaXNUeXBlKGZpZWxkLCB0eXBlKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc1R5cGUgPSBmdW5jdGlvbiAoZmllbGREZWYsIHR5cGUpIHtcbiAgICAvLyBGSVhNRSB2bGZpZWxkLmlzVHlwZVxuICAgIHJldHVybiAoZmllbGREZWYudHlwZSAmIHR5cGUpID4gMDtcbiAgfTtcblxuICBFbmNvZGluZy5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGVuY29kaW5nLCBlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHZsZmllbGQuaXNPcmRpbmFsU2NhbGUoZW5jb2RpbmcuZW5jKGVuY1R5cGUpLCB0cnVlKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc0RpbWVuc2lvbiA9IGZ1bmN0aW9uKGVuY29kaW5nLCBlbmNUeXBlKSB7XG4gICAgcmV0dXJuIHZsZmllbGQuaXNEaW1lbnNpb24oZW5jb2RpbmcuZW5jKGVuY1R5cGUpLCB0cnVlKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc01lYXN1cmUgPSBmdW5jdGlvbihlbmNvZGluZywgZW5jVHlwZSkge1xuICAgIHJldHVybiB2bGZpZWxkLmlzTWVhc3VyZShlbmNvZGluZy5lbmMoZW5jVHlwZSksIHRydWUpO1xuICB9O1xuXG4gIHByb3RvLmlzT3JkaW5hbFNjYWxlID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhlbmNUeXBlKSAmJiBFbmNvZGluZy5pc09yZGluYWxTY2FsZSh0aGlzLCBlbmNUeXBlKTtcbiAgfTtcblxuICBwcm90by5pc0RpbWVuc2lvbiA9IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICByZXR1cm4gdGhpcy5oYXMoZW5jVHlwZSkgJiYgRW5jb2RpbmcuaXNEaW1lbnNpb24odGhpcywgZW5jVHlwZSk7XG4gIH07XG5cbiAgcHJvdG8uaXNNZWFzdXJlID0gZnVuY3Rpb24oZW5jVHlwZSkge1xuICAgIHJldHVybiB0aGlzLmhhcyhlbmNUeXBlKSAmJiBFbmNvZGluZy5pc01lYXN1cmUodGhpcywgZW5jVHlwZSk7XG4gIH07XG5cbiAgcHJvdG8uaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdmxlbmMuaXNBZ2dyZWdhdGUodGhpcy5fZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc0FnZ3JlZ2F0ZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICByZXR1cm4gdmxlbmMuaXNBZ2dyZWdhdGUoc3BlYy5lbmMpO1xuICB9O1xuXG4gIEVuY29kaW5nLmFsd2F5c05vT2NjbHVzaW9uID0gZnVuY3Rpb24oc3BlYywgc3RhdHMpIHtcbiAgICAvLyBGSVhNRSByYXcgT3hRIHdpdGggIyBvZiByb3dzID0gIyBvZiBPXG4gICAgcmV0dXJuIHZsZW5jLmlzQWdncmVnYXRlKHNwZWMuZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5pc1N0YWNrID0gZnVuY3Rpb24oc3BlYykge1xuICAgIC8vIEZJWE1FIHVwZGF0ZSB0aGlzIG9uY2Ugd2UgaGF2ZSBjb250cm9sIGZvciBzdGFjayAuLi5cbiAgICByZXR1cm4gKHNwZWMubWFya3R5cGUgPT09ICdiYXInIHx8IHNwZWMubWFya3R5cGUgPT09ICdhcmVhJykgJiZcbiAgICAgIHNwZWMuZW5jLmNvbG9yO1xuICB9O1xuXG4gIHByb3RvLmlzU3RhY2sgPSBmdW5jdGlvbigpIHtcbiAgICAvLyBGSVhNRSB1cGRhdGUgdGhpcyBvbmNlIHdlIGhhdmUgY29udHJvbCBmb3Igc3RhY2sgLi4uXG4gICAgcmV0dXJuICh0aGlzLmlzKCdiYXInKSB8fCB0aGlzLmlzKCdhcmVhJykpICYmIHRoaXMuaGFzKCdjb2xvcicpO1xuICB9O1xuXG4gIHByb3RvLmNhcmRpbmFsaXR5ID0gZnVuY3Rpb24oZW5jVHlwZSwgc3RhdHMpIHtcbiAgICByZXR1cm4gdmxmaWVsZC5jYXJkaW5hbGl0eSh0aGlzLmVuYyhlbmNUeXBlKSwgc3RhdHMsIHRoaXMuY29uZmlnKCdmaWx0ZXJOdWxsJyksIHRydWUpO1xuICB9O1xuXG4gIHByb3RvLmlzUmF3ID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICF0aGlzLmlzQWdncmVnYXRlKCk7XG4gIH07XG5cbiAgcHJvdG8uZGF0YSA9IGZ1bmN0aW9uKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy5fZGF0YVtuYW1lXTtcbiAgfTtcblxuICBwcm90by5jb25maWcgPSBmdW5jdGlvbihuYW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbmZpZ1tuYW1lXTtcbiAgfTtcblxuICBwcm90by50b1NwZWMgPSBmdW5jdGlvbihleGNsdWRlQ29uZmlnKSB7XG4gICAgdmFyIGVuYyA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2VuYyksXG4gICAgICBzcGVjO1xuXG4gICAgLy8gY29udmVydCB0eXBlJ3MgYml0Y29kZSB0byB0eXBlIG5hbWVcbiAgICBmb3IgKHZhciBlIGluIGVuYykge1xuICAgICAgZW5jW2VdLnR5cGUgPSBjb25zdHMuZGF0YVR5cGVOYW1lc1tlbmNbZV0udHlwZV07XG4gICAgfVxuXG4gICAgc3BlYyA9IHtcbiAgICAgIG1hcmt0eXBlOiB0aGlzLl9tYXJrdHlwZSxcbiAgICAgIGVuYzogZW5jLFxuICAgICAgZmlsdGVyOiB0aGlzLl9maWx0ZXJcbiAgICB9O1xuXG4gICAgaWYgKCFleGNsdWRlQ29uZmlnKSB7XG4gICAgICBzcGVjLmNvbmZpZyA9IHV0aWwuZHVwbGljYXRlKHRoaXMuX2NvbmZpZyk7XG4gICAgfVxuXG4gICAgLy8gcmVtb3ZlIGRlZmF1bHRzXG4gICAgdmFyIGRlZmF1bHRzID0gc2NoZW1hLmluc3RhbnRpYXRlKCk7XG4gICAgcmV0dXJuIHNjaGVtYS51dGlsLnN1YnRyYWN0KHNwZWMsIGRlZmF1bHRzKTtcbiAgfTtcblxuICBwcm90by50b1Nob3J0aGFuZCA9IGZ1bmN0aW9uKCkge1xuICAgIHZhciBjID0gY29uc3RzLnNob3J0aGFuZDtcbiAgICByZXR1cm4gJ21hcmsnICsgYy5hc3NpZ24gKyB0aGlzLl9tYXJrdHlwZSArXG4gICAgICBjLmRlbGltICsgdmxlbmMuc2hvcnRoYW5kKHRoaXMuX2VuYyk7XG4gIH07XG5cbiAgRW5jb2Rpbmcuc2hvcnRoYW5kID0gZnVuY3Rpb24gKHNwZWMpIHtcbiAgICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQ7XG4gICAgcmV0dXJuICdtYXJrJyArIGMuYXNzaWduICsgc3BlYy5tYXJrdHlwZSArXG4gICAgICBjLmRlbGltICsgdmxlbmMuc2hvcnRoYW5kKHNwZWMuZW5jKTtcbiAgfTtcblxuICBFbmNvZGluZy5mcm9tU2hvcnRoYW5kID0gZnVuY3Rpb24oc2hvcnRoYW5kLCBkYXRhLCBjb25maWcsIHRoZW1lKSB7XG4gICAgdmFyIGMgPSBjb25zdHMuc2hvcnRoYW5kLFxuICAgICAgICBzcGxpdCA9IHNob3J0aGFuZC5zcGxpdChjLmRlbGltKSxcbiAgICAgICAgbWFya3R5cGUgPSBzcGxpdC5zaGlmdCgpLnNwbGl0KGMuYXNzaWduKVsxXS50cmltKCksXG4gICAgICAgIGVuYyA9IHZsZW5jLmZyb21TaG9ydGhhbmQoc3BsaXQsIHRydWUpO1xuXG4gICAgcmV0dXJuIG5ldyBFbmNvZGluZyhtYXJrdHlwZSwgZW5jLCBkYXRhLCBjb25maWcsIG51bGwsIHRoZW1lKTtcbiAgfTtcblxuICBFbmNvZGluZy5zcGVjRnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCwgZGF0YSwgY29uZmlnLCBleGNsdWRlQ29uZmlnKSB7XG4gICAgcmV0dXJuIEVuY29kaW5nLmZyb21TaG9ydGhhbmQoc2hvcnRoYW5kLCBkYXRhLCBjb25maWcpLnRvU3BlYyhleGNsdWRlQ29uZmlnKTtcbiAgfTtcblxuICBFbmNvZGluZy5mcm9tU3BlYyA9IGZ1bmN0aW9uKHNwZWMsIHRoZW1lKSB7XG4gICAgdmFyIGVuYyA9IHV0aWwuZHVwbGljYXRlKHNwZWMuZW5jIHx8IHt9KTtcblxuICAgIC8vY29udmVydCB0eXBlIGZyb20gc3RyaW5nIHRvIGJpdGNvZGUgKGUuZywgTz0xKVxuICAgIGZvciAodmFyIGUgaW4gZW5jKSB7XG4gICAgICBlbmNbZV0udHlwZSA9IGNvbnN0cy5kYXRhVHlwZXNbZW5jW2VdLnR5cGVdO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgRW5jb2Rpbmcoc3BlYy5tYXJrdHlwZSwgZW5jLCBzcGVjLmRhdGEsIHNwZWMuY29uZmlnLCBzcGVjLmZpbHRlciwgdGhlbWUpO1xuICB9O1xuXG4gIEVuY29kaW5nLnRyYW5zcG9zZSA9IGZ1bmN0aW9uKHNwZWMpIHtcbiAgICB2YXIgb2xkZW5jID0gc3BlYy5lbmMsXG4gICAgICBlbmMgPSB1dGlsLmR1cGxpY2F0ZShzcGVjLmVuYyk7XG4gICAgZW5jLnggPSBvbGRlbmMueTtcbiAgICBlbmMueSA9IG9sZGVuYy54O1xuICAgIGVuYy5yb3cgPSBvbGRlbmMuY29sO1xuICAgIGVuYy5jb2wgPSBvbGRlbmMucm93O1xuICAgIHNwZWMuZW5jID0gZW5jO1xuICAgIHJldHVybiBzcGVjO1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZVNvcnQgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgc3BlYy5jb25maWcgPSBzcGVjLmNvbmZpZyB8fCB7fTtcbiAgICBzcGVjLmNvbmZpZy50b2dnbGVTb3J0ID0gc3BlYy5jb25maWcudG9nZ2xlU29ydCA9PT0gJ1EnID8gJ08nIDonUSc7XG4gICAgcmV0dXJuIHNwZWM7XG4gIH07XG5cblxuICBFbmNvZGluZy50b2dnbGVTb3J0LmRpcmVjdGlvbiA9IGZ1bmN0aW9uKHNwZWMsIHVzZVR5cGVDb2RlKSB7XG4gICAgaWYgKCFFbmNvZGluZy50b2dnbGVTb3J0LnN1cHBvcnQoc3BlYywgdXNlVHlwZUNvZGUpKSB7IHJldHVybjsgfVxuICAgIHZhciBlbmMgPSBzcGVjLmVuYztcbiAgICByZXR1cm4gZW5jLngudHlwZSA9PT0gJ08nID8gJ3gnIDogICd5JztcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVTb3J0Lm1vZGUgPSBmdW5jdGlvbihzcGVjKSB7XG4gICAgcmV0dXJuIHNwZWMuY29uZmlnLnRvZ2dsZVNvcnQ7XG4gIH07XG5cbiAgRW5jb2RpbmcudG9nZ2xlU29ydC5zdXBwb3J0ID0gZnVuY3Rpb24oc3BlYywgc3RhdHMsIHVzZVR5cGVDb2RlKSB7XG4gICAgdmFyIGVuYyA9IHNwZWMuZW5jLFxuICAgICAgaXNUeXBlID0gdmxmaWVsZC5pc1R5cGUuZ2V0KHVzZVR5cGVDb2RlKTtcblxuICAgIGlmICh2bGVuYy5oYXMoZW5jLCBST1cpIHx8IHZsZW5jLmhhcyhlbmMsIENPTCkgfHxcbiAgICAgICF2bGVuYy5oYXMoZW5jLCBYKSB8fCAhdmxlbmMuaGFzKGVuYywgWSkgfHxcbiAgICAgICFFbmNvZGluZy5hbHdheXNOb09jY2x1c2lvbihzcGVjLCBzdGF0cykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gKCBpc1R5cGUoZW5jLngsIE8pICYmIHZsZmllbGQuaXNNZWFzdXJlKGVuYy55LCB1c2VUeXBlQ29kZSkpID8gJ3gnIDpcbiAgICAgICggaXNUeXBlKGVuYy55LCBPKSAmJiB2bGZpZWxkLmlzTWVhc3VyZShlbmMueCwgdXNlVHlwZUNvZGUpKSA/ICd5JyA6IGZhbHNlO1xuICB9O1xuXG4gIEVuY29kaW5nLnRvZ2dsZUZpbHRlck51bGxPID0gZnVuY3Rpb24oc3BlYykge1xuICAgIHNwZWMuY29uZmlnID0gc3BlYy5jb25maWcgfHwge307XG4gICAgc3BlYy5jb25maWcuZmlsdGVyTnVsbCA9IHNwZWMuY29uZmlnLmZpbHRlck51bGwgfHwgeyAvL0ZJWE1FXG4gICAgICBUOiB0cnVlLFxuICAgICAgUTogdHJ1ZVxuICAgIH07XG4gICAgc3BlYy5jb25maWcuZmlsdGVyTnVsbC5PID0gIXNwZWMuY29uZmlnLmZpbHRlck51bGwuTztcbiAgICByZXR1cm4gc3BlYztcbiAgfTtcblxuICBFbmNvZGluZy50b2dnbGVGaWx0ZXJOdWxsTy5zdXBwb3J0ID0gZnVuY3Rpb24oc3BlYywgc3RhdHMpIHtcbiAgICB2YXIgZmllbGRzID0gdmxlbmMuZmllbGRzKHNwZWMuZW5jKTtcbiAgICBmb3IgKHZhciBmaWVsZE5hbWUgaW4gZmllbGRzKSB7XG4gICAgICB2YXIgZmllbGRMaXN0ID0gZmllbGRzW2ZpZWxkTmFtZV07XG4gICAgICBpZiAoZmllbGRMaXN0LmNvbnRhaW5zVHlwZS5PICYmIGZpZWxkTmFtZSBpbiBzdGF0cyAmJiBzdGF0c1tmaWVsZE5hbWVdLm51bU51bGxzID4gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIHJldHVybiBFbmNvZGluZztcbn0pKCk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFnZ3JlZ2F0ZXM7XG5cbmZ1bmN0aW9uIGFnZ3JlZ2F0ZXMoc3BlYywgZW5jb2RpbmcsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG5cbiAgdmFyIGRpbXMgPSB7fSwgbWVhcyA9IHt9LCBkZXRhaWwgPSB7fSwgZmFjZXRzID0ge30sXG4gICAgZGF0YSA9IHNwZWMuZGF0YVsxXTsgLy8gY3VycmVudGx5IGRhdGFbMF0gaXMgcmF3IGFuZCBkYXRhWzFdIGlzIHRhYmxlXG5cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIGlmIChmaWVsZC5hZ2dyKSB7XG4gICAgICBpZiAoZmllbGQuYWdnciA9PT0gJ2NvdW50Jykge1xuICAgICAgICBtZWFzLmNvdW50ID0ge29wOiAnY291bnQnLCBmaWVsZDogJyonfTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgbWVhc1tmaWVsZC5hZ2dyICsgJ3wnKyBmaWVsZC5uYW1lXSA9IHtcbiAgICAgICAgICBvcDogZmllbGQuYWdncixcbiAgICAgICAgICBmaWVsZDogJ2RhdGEuJysgZmllbGQubmFtZVxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaW1zW2ZpZWxkLm5hbWVdID0gZW5jb2RpbmcuZmllbGQoZW5jVHlwZSk7XG4gICAgICBpZiAoZW5jVHlwZSA9PSBST1cgfHwgZW5jVHlwZSA9PSBDT0wpIHtcbiAgICAgICAgZmFjZXRzW2ZpZWxkLm5hbWVdID0gZGltc1tmaWVsZC5uYW1lXTtcbiAgICAgIH1lbHNlIGlmIChlbmNUeXBlICE9PSBYICYmIGVuY1R5cGUgIT09IFkpIHtcbiAgICAgICAgZGV0YWlsW2ZpZWxkLm5hbWVdID0gZGltc1tmaWVsZC5uYW1lXTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuICBkaW1zID0gdXRpbC52YWxzKGRpbXMpO1xuICBtZWFzID0gdXRpbC52YWxzKG1lYXMpO1xuXG4gIGlmIChtZWFzLmxlbmd0aCA+IDAgJiYgIW9wdC5wcmVhZ2dyZWdhdGVkRGF0YSkge1xuICAgIGlmICghZGF0YS50cmFuc2Zvcm0pIGRhdGEudHJhbnNmb3JtID0gW107XG4gICAgZGF0YS50cmFuc2Zvcm0ucHVzaCh7XG4gICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgIGdyb3VwYnk6IGRpbXMsXG4gICAgICBmaWVsZHM6IG1lYXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGRldGFpbHM6IHV0aWwudmFscyhkZXRhaWwpLFxuICAgIGRpbXM6IGRpbXMsXG4gICAgZmFjZXRzOiB1dGlsLnZhbHMoZmFjZXRzKSxcbiAgICBhZ2dyZWdhdGVkOiBtZWFzLmxlbmd0aCA+IDBcbiAgfTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHNldHRlciA9IHV0aWwuc2V0dGVyLFxuICBnZXR0ZXIgPSB1dGlsLmdldHRlcixcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG52YXIgYXhpcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmF4aXMubmFtZXMgPSBmdW5jdGlvbihwcm9wcykge1xuICByZXR1cm4gdXRpbC5rZXlzKHV0aWwua2V5cyhwcm9wcykucmVkdWNlKGZ1bmN0aW9uKGEsIHgpIHtcbiAgICB2YXIgcyA9IHByb3BzW3hdLnNjYWxlO1xuICAgIGlmIChzID09PSBYIHx8IHMgPT09IFkpIGFbcHJvcHNbeF0uc2NhbGVdID0gMTtcbiAgICByZXR1cm4gYTtcbiAgfSwge30pKTtcbn07XG5cbmF4aXMuZGVmcyA9IGZ1bmN0aW9uKG5hbWVzLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgb3B0KSB7XG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoZnVuY3Rpb24oYSwgbmFtZSkge1xuICAgIGEucHVzaChheGlzLmRlZihuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cywgb3B0KSk7XG4gICAgcmV0dXJuIGE7XG4gIH0sIFtdKTtcbn07XG5cbmF4aXMuZGVmID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMsIG9wdCkge1xuICB2YXIgdHlwZSA9IG5hbWU7XG4gIHZhciBpc0NvbCA9IG5hbWUgPT0gQ09MLCBpc1JvdyA9IG5hbWUgPT0gUk9XO1xuICB2YXIgcm93T2Zmc2V0ID0gYXhpc1RpdGxlT2Zmc2V0KGVuY29kaW5nLCBsYXlvdXQsIFkpICsgMjAsXG4gICAgY2VsbFBhZGRpbmcgPSBsYXlvdXQuY2VsbFBhZGRpbmc7XG5cblxuICBpZiAoaXNDb2wpIHR5cGUgPSAneCc7XG4gIGlmIChpc1JvdykgdHlwZSA9ICd5JztcblxuICB2YXIgZGVmID0ge1xuICAgIHR5cGU6IHR5cGUsXG4gICAgc2NhbGU6IG5hbWVcbiAgfTtcblxuICBpZiAoZW5jb2RpbmcuYXhpcyhuYW1lKS5ncmlkKSB7XG4gICAgZGVmLmdyaWQgPSB0cnVlO1xuICAgIGRlZi5sYXllciA9IChpc1JvdyB8fCBpc0NvbCkgPyAnZnJvbnQnIDogICdiYWNrJztcblxuICAgIGlmIChpc0NvbCkge1xuICAgICAgLy8gc2V0IGdyaWQgcHJvcGVydHkgLS0gcHV0IHRoZSBsaW5lcyBvbiB0aGUgcmlnaHQgdGhlIGNlbGxcbiAgICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICdncmlkJ10sIHtcbiAgICAgICAgeDoge1xuICAgICAgICAgIG9mZnNldDogbGF5b3V0LmNlbGxXaWR0aCAqICgxKyBjZWxsUGFkZGluZy8yLjApLFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIHNjYWxlOiAnY29sJ1xuICAgICAgICB9LFxuICAgICAgICB5OiB7XG4gICAgICAgICAgdmFsdWU6IC1sYXlvdXQuY2VsbEhlaWdodCAqIChjZWxsUGFkZGluZy8yKSxcbiAgICAgICAgfSxcbiAgICAgICAgc3Ryb2tlOiB7IHZhbHVlOiBlbmNvZGluZy5jb25maWcoJ2NlbGxHcmlkQ29sb3InKSB9XG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGlzUm93KSB7XG4gICAgICAvLyBzZXQgZ3JpZCBwcm9wZXJ0eSAtLSBwdXQgdGhlIGxpbmVzIG9uIHRoZSB0b3BcbiAgICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICdncmlkJ10sIHtcbiAgICAgICAgeToge1xuICAgICAgICAgIG9mZnNldDogLWxheW91dC5jZWxsSGVpZ2h0ICogKGNlbGxQYWRkaW5nLzIpLFxuICAgICAgICAgIC8vIGRlZmF1bHQgdmFsdWUocykgLS0gdmVnYSBkb2Vzbid0IGRvIHJlY3Vyc2l2ZSBtZXJnZVxuICAgICAgICAgIHNjYWxlOiAncm93J1xuICAgICAgICB9LFxuICAgICAgICB4OiB7XG4gICAgICAgICAgdmFsdWU6IHJvd09mZnNldFxuICAgICAgICB9LFxuICAgICAgICB4Mjoge1xuICAgICAgICAgIG9mZnNldDogcm93T2Zmc2V0ICsgKGxheW91dC5jZWxsV2lkdGggKiAwLjA1KSxcbiAgICAgICAgICAvLyBkZWZhdWx0IHZhbHVlKHMpIC0tIHZlZ2EgZG9lc24ndCBkbyByZWN1cnNpdmUgbWVyZ2VcbiAgICAgICAgICBncm91cDogXCJtYXJrLmdyb3VwLndpZHRoXCIsXG4gICAgICAgICAgbXVsdDogMVxuICAgICAgICB9LFxuICAgICAgICBzdHJva2U6IHsgdmFsdWU6IGVuY29kaW5nLmNvbmZpZygnY2VsbEdyaWRDb2xvcicpIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBzZXR0ZXIoZGVmLCBbJ3Byb3BlcnRpZXMnLCAnZ3JpZCcsICdzdHJva2UnXSwge1xuICAgICAgICB2YWx1ZTogZW5jb2RpbmcuY29uZmlnKCdncmlkQ29sb3InKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVuY29kaW5nLmF4aXMobmFtZSkudGl0bGUpIHtcbiAgICBkZWYgPSBheGlzX3RpdGxlKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCwgb3B0KTtcbiAgfVxuXG4gIGlmIChpc1JvdyB8fCBpc0NvbCkge1xuICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICd0aWNrcyddLCB7XG4gICAgICBvcGFjaXR5OiB7dmFsdWU6IDB9XG4gICAgfSk7XG4gICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywgJ21ham9yVGlja3MnXSwge1xuICAgICAgb3BhY2l0eToge3ZhbHVlOiAwfVxuICAgIH0pO1xuICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsICdheGlzJ10sIHtcbiAgICAgIG9wYWNpdHk6IHt2YWx1ZTogMH1cbiAgICB9KTtcbiAgfVxuXG4gIGlmIChpc0NvbCkge1xuICAgIGRlZi5vcmllbnQgPSAndG9wJztcbiAgfVxuXG4gIGlmIChpc1Jvdykge1xuICAgIGRlZi5vZmZzZXQgPSByb3dPZmZzZXQ7XG4gIH1cblxuICBpZiAobmFtZSA9PSBYKSB7XG4gICAgaWYgKGVuY29kaW5nLmhhcyhZKSAmJiBlbmNvZGluZy5pc09yZGluYWxTY2FsZShZKSAmJiBlbmNvZGluZy5jYXJkaW5hbGl0eShZLCBzdGF0cykgPiAzMCkge1xuICAgICAgZGVmLm9yaWVudCA9ICd0b3AnO1xuICAgIH1cblxuICAgIGlmIChlbmNvZGluZy5pc0RpbWVuc2lvbihYKSB8fCBlbmNvZGluZy5pc1R5cGUoWCwgVCkpIHtcbiAgICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ2xhYmVscyddLCB7XG4gICAgICAgIGFuZ2xlOiB7dmFsdWU6IDI3MH0sXG4gICAgICAgIGFsaWduOiB7dmFsdWU6ICdyaWdodCd9LFxuICAgICAgICBiYXNlbGluZToge3ZhbHVlOiAnbWlkZGxlJ31cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7IC8vIFFcbiAgICAgIGRlZi50aWNrcyA9IDU7XG4gICAgfVxuICB9XG5cbiAgZGVmID0gYXhpc19sYWJlbHMoZGVmLCBuYW1lLCBlbmNvZGluZywgbGF5b3V0LCBvcHQpO1xuXG4gIHJldHVybiBkZWY7XG59O1xuXG5mdW5jdGlvbiBheGlzX3RpdGxlKGRlZiwgbmFtZSwgZW5jb2RpbmcsIGxheW91dCwgb3B0KSB7XG4gIHZhciBtYXhsZW5ndGggPSBudWxsLFxuICAgIGZpZWxkVGl0bGUgPSBlbmNvZGluZy5maWVsZFRpdGxlKG5hbWUpO1xuICBpZiAobmFtZT09PVgpIHtcbiAgICBtYXhsZW5ndGggPSBsYXlvdXQuY2VsbFdpZHRoIC8gZW5jb2RpbmcuY29uZmlnKCdjaGFyYWN0ZXJXaWR0aCcpO1xuICB9IGVsc2UgaWYgKG5hbWUgPT09IFkpIHtcbiAgICBtYXhsZW5ndGggPSBsYXlvdXQuY2VsbEhlaWdodCAvIGVuY29kaW5nLmNvbmZpZygnY2hhcmFjdGVyV2lkdGgnKTtcbiAgfVxuXG4gIGRlZi50aXRsZSA9IG1heGxlbmd0aCA/IHV0aWwudHJ1bmNhdGUoZmllbGRUaXRsZSwgbWF4bGVuZ3RoKSA6IGZpZWxkVGl0bGU7XG5cbiAgaWYgKG5hbWUgPT09IFJPVykge1xuICAgIHNldHRlcihkZWYsIFsncHJvcGVydGllcycsJ3RpdGxlJ10sIHtcbiAgICAgIGFuZ2xlOiB7dmFsdWU6IDB9LFxuICAgICAgYWxpZ246IHt2YWx1ZTogJ3JpZ2h0J30sXG4gICAgICBiYXNlbGluZToge3ZhbHVlOiAnbWlkZGxlJ30sXG4gICAgICBkeToge3ZhbHVlOiAoLWxheW91dC5oZWlnaHQvMikgLTIwfVxuICAgIH0pO1xuICB9XG5cbiAgZGVmLnRpdGxlT2Zmc2V0ID0gYXhpc1RpdGxlT2Zmc2V0KGVuY29kaW5nLCBsYXlvdXQsIG5hbWUpO1xuICByZXR1cm4gZGVmO1xufVxuXG5mdW5jdGlvbiBheGlzX2xhYmVscyhkZWYsIG5hbWUsIGVuY29kaW5nLCBsYXlvdXQsIG9wdCkge1xuICB2YXIgZm47XG4gIC8vIGFkZCBjdXN0b20gbGFiZWwgZm9yIHRpbWUgdHlwZVxuICBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIFQpICYmIChmbiA9IGVuY29kaW5nLmZuKG5hbWUpKSAmJiAodGltZS5oYXNTY2FsZShmbikpKSB7XG4gICAgc2V0dGVyKGRlZiwgWydwcm9wZXJ0aWVzJywnbGFiZWxzJywndGV4dCcsJ3NjYWxlJ10sICd0aW1lLScrIGZuKTtcbiAgfVxuXG4gIHZhciB0ZXh0VGVtcGxhdGVQYXRoID0gWydwcm9wZXJ0aWVzJywnbGFiZWxzJywndGV4dCcsJ3RlbXBsYXRlJ107XG4gIGlmIChlbmNvZGluZy5heGlzKG5hbWUpLmZvcm1hdCkge1xuICAgIGRlZi5mb3JtYXQgPSBlbmNvZGluZy5heGlzKG5hbWUpLmZvcm1hdDtcbiAgfSBlbHNlIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgUSkpIHtcbiAgICBzZXR0ZXIoZGVmLCB0ZXh0VGVtcGxhdGVQYXRoLCBcInt7ZGF0YSB8IG51bWJlcjonLjNzJ319XCIpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSAmJiAhZW5jb2RpbmcuZm4obmFtZSkpIHtcbiAgICBzZXR0ZXIoZGVmLCB0ZXh0VGVtcGxhdGVQYXRoLCBcInt7ZGF0YSB8IHRpbWU6JyVZLSVtLSVkJ319XCIpO1xuICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZShuYW1lLCBUKSAmJiBlbmNvZGluZy5mbihuYW1lKSA9PT0gJ3llYXInKSB7XG4gICAgc2V0dGVyKGRlZiwgdGV4dFRlbXBsYXRlUGF0aCwgXCJ7e2RhdGEgfCBudW1iZXI6J2QnfX1cIik7XG4gIH0gZWxzZSBpZiAoZW5jb2RpbmcuaXNUeXBlKG5hbWUsIE8pICYmIGVuY29kaW5nLmF4aXMobmFtZSkubWF4TGFiZWxMZW5ndGgpIHtcbiAgICBzZXR0ZXIoZGVmLCB0ZXh0VGVtcGxhdGVQYXRoLCAne3tkYXRhIHwgdHJ1bmNhdGU6JyArIGVuY29kaW5nLmF4aXMobmFtZSkubWF4TGFiZWxMZW5ndGggKyAnfX0nKTtcbiAgfVxuXG4gIHJldHVybiBkZWY7XG59XG5cbmZ1bmN0aW9uIGF4aXNUaXRsZU9mZnNldChlbmNvZGluZywgbGF5b3V0LCBuYW1lKSB7XG4gIHZhciB2YWx1ZSA9IGVuY29kaW5nLmF4aXMobmFtZSkudGl0bGVPZmZzZXQ7XG4gIGlmICh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlIFJPVzogcmV0dXJuIDA7XG4gICAgY2FzZSBDT0w6IHJldHVybiAzNTtcbiAgfVxuICByZXR1cm4gZ2V0dGVyKGxheW91dCwgW25hbWUsICdheGlzVGl0bGVPZmZzZXQnXSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGJpbm5pbmc7XG5cbmZ1bmN0aW9uIGJpbm5pbmcoc3BlYywgZW5jb2RpbmcsIG9wdCkge1xuICBvcHQgPSBvcHQgfHwge307XG4gIHZhciBiaW5zID0ge307XG5cbiAgaWYgKG9wdC5wcmVhZ2dyZWdhdGVkRGF0YSkge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIGlmICghc3BlYy50cmFuc2Zvcm0pIHNwZWMudHJhbnNmb3JtID0gW107XG5cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIGlmIChlbmNvZGluZy5iaW4oZW5jVHlwZSkpIHtcbiAgICAgIHNwZWMudHJhbnNmb3JtLnB1c2goe1xuICAgICAgICB0eXBlOiAnYmluJyxcbiAgICAgICAgZmllbGQ6ICdkYXRhLicgKyBmaWVsZC5uYW1lLFxuICAgICAgICBvdXRwdXQ6ICdkYXRhLmJpbl8nICsgZmllbGQubmFtZSxcbiAgICAgICAgbWF4YmluczogZW5jb2RpbmcuYmluKGVuY1R5cGUpLm1heGJpbnNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbXBpbGU7XG5cbnZhciBFbmNvZGluZyA9IHJlcXVpcmUoJy4uL0VuY29kaW5nJyksXG4gIHRlbXBsYXRlID0gY29tcGlsZS50ZW1wbGF0ZSA9IHJlcXVpcmUoJy4vdGVtcGxhdGUnKSxcbiAgYXhpcyA9IGNvbXBpbGUuYXhpcyA9IHJlcXVpcmUoJy4vYXhpcycpLFxuICBmaWx0ZXIgPSBjb21waWxlLmZpbHRlciA9IHJlcXVpcmUoJy4vZmlsdGVyJyksXG4gIGxlZ2VuZCA9IGNvbXBpbGUubGVnZW5kID0gcmVxdWlyZSgnLi9sZWdlbmQnKSxcbiAgbWFya3MgPSBjb21waWxlLm1hcmtzID0gcmVxdWlyZSgnLi9tYXJrcycpLFxuICBzY2FsZSA9IGNvbXBpbGUuc2NhbGUgPSByZXF1aXJlKCcuL3NjYWxlJyksXG4gIHZsc29ydCA9IGNvbXBpbGUuc29ydCA9IHJlcXVpcmUoJy4vc29ydCcpLFxuICB2bHN0eWxlID0gY29tcGlsZS5zdHlsZSA9IHJlcXVpcmUoJy4vc3R5bGUnKSxcbiAgdGltZSA9IGNvbXBpbGUudGltZSA9IHJlcXVpcmUoJy4vdGltZScpLFxuICBhZ2dyZWdhdGUgPSBjb21waWxlLmFnZ3JlZ2F0ZSA9IHJlcXVpcmUoJy4vYWdncmVnYXRlJyksXG4gIGJpbiA9IGNvbXBpbGUuYmluID0gcmVxdWlyZSgnLi9iaW4nKSxcbiAgZmFjZXQgPSBjb21waWxlLmZhY2V0ID0gcmVxdWlyZSgnLi9mYWNldCcpLFxuICB2bHN0YWNrID0gY29tcGlsZS5zdGFjayA9IHJlcXVpcmUoJy4vc3RhY2snKSxcbiAgc3ViZmFjZXQgPSBjb21waWxlLnN1YmZhY2V0ID0gcmVxdWlyZSgnLi9zdWJmYWNldCcpO1xuXG5jb21waWxlLmxheW91dCA9IHJlcXVpcmUoJy4vbGF5b3V0Jyk7XG5jb21waWxlLmdyb3VwID0gcmVxdWlyZSgnLi9ncm91cCcpO1xuXG5mdW5jdGlvbiBjb21waWxlKHNwZWMsIHN0YXRzLCB0aGVtZSkge1xuICByZXR1cm4gY29tcGlsZS5lbmNvZGluZyhFbmNvZGluZy5mcm9tU3BlYyhzcGVjLCB0aGVtZSksIHN0YXRzKTtcbn1cblxuY29tcGlsZS5zaG9ydGhhbmQgPSBmdW5jdGlvbiAoc2hvcnRoYW5kLCBzdGF0cywgY29uZmlnLCB0aGVtZSkge1xuICByZXR1cm4gY29tcGlsZS5lbmNvZGluZyhFbmNvZGluZy5mcm9tU2hvcnRoYW5kKHNob3J0aGFuZCwgY29uZmlnLCB0aGVtZSksIHN0YXRzKTtcbn07XG5cbmNvbXBpbGUuZW5jb2RpbmcgPSBmdW5jdGlvbiAoZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBsYXlvdXQgPSBjb21waWxlLmxheW91dChlbmNvZGluZywgc3RhdHMpLFxuICAgIHN0eWxlID0gdmxzdHlsZShlbmNvZGluZywgc3RhdHMpLFxuICAgIHNwZWMgPSB0ZW1wbGF0ZShlbmNvZGluZywgbGF5b3V0LCBzdGF0cyksXG4gICAgZ3JvdXAgPSBzcGVjLm1hcmtzWzBdLFxuICAgIG1hcmsgPSBtYXJrc1tlbmNvZGluZy5tYXJrdHlwZSgpXSxcbiAgICBtZGVmcyA9IG1hcmtzLmRlZihtYXJrLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSksXG4gICAgbWRlZiA9IG1kZWZzWzBdOyAgLy8gVE9ETzogcmVtb3ZlIHRoaXMgZGlydHkgaGFjayBieSByZWZhY3RvcmluZyB0aGUgd2hvbGUgZmxvd1xuXG4gIGZpbHRlci5hZGRGaWx0ZXJzKHNwZWMsIGVuY29kaW5nKTtcbiAgdmFyIHNvcnRpbmcgPSB2bHNvcnQoc3BlYywgZW5jb2RpbmcsIHN0YXRzKTtcblxuICB2YXIgaGFzUm93ID0gZW5jb2RpbmcuaGFzKFJPVyksIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpO1xuXG4gIHZhciBwcmVhZ2dyZWdhdGVkRGF0YSA9ICEhZW5jb2RpbmcuZGF0YSgndmVnYVNlcnZlcicpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbWRlZnMubGVuZ3RoOyBpKyspIHtcbiAgICBncm91cC5tYXJrcy5wdXNoKG1kZWZzW2ldKTtcbiAgfVxuXG4gIGJpbihzcGVjLmRhdGFbMV0sIGVuY29kaW5nLCB7cHJlYWdncmVnYXRlZERhdGE6IHByZWFnZ3JlZ2F0ZWREYXRhfSk7XG5cbiAgdmFyIGxpbmVUeXBlID0gbWFya3NbZW5jb2RpbmcubWFya3R5cGUoKV0ubGluZTtcblxuICBpZiAoIXByZWFnZ3JlZ2F0ZWREYXRhKSB7XG4gICAgc3BlYyA9IHRpbWUoc3BlYywgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gaGFuZGxlIHN1YmZhY2V0c1xuICB2YXIgYWdnUmVzdWx0ID0gYWdncmVnYXRlKHNwZWMsIGVuY29kaW5nLCB7cHJlYWdncmVnYXRlZERhdGE6IHByZWFnZ3JlZ2F0ZWREYXRhfSksXG4gICAgZGV0YWlscyA9IGFnZ1Jlc3VsdC5kZXRhaWxzLFxuICAgIGhhc0RldGFpbHMgPSBkZXRhaWxzICYmIGRldGFpbHMubGVuZ3RoID4gMCxcbiAgICBzdGFjayA9IGhhc0RldGFpbHMgJiYgdmxzdGFjayhzcGVjLCBlbmNvZGluZywgbWRlZiwgYWdnUmVzdWx0LmZhY2V0cyk7XG5cbiAgaWYgKGhhc0RldGFpbHMgJiYgKHN0YWNrIHx8IGxpbmVUeXBlKSkge1xuICAgIC8vc3ViZmFjZXQgdG8gZ3JvdXAgc3RhY2sgLyBsaW5lIHRvZ2V0aGVyIGluIG9uZSBncm91cFxuICAgIHN1YmZhY2V0KGdyb3VwLCBtZGVmLCBkZXRhaWxzLCBzdGFjaywgZW5jb2RpbmcpO1xuICB9XG5cbiAgLy8gYXV0by1zb3J0IGxpbmUvYXJlYSB2YWx1ZXNcbiAgLy9UT0RPKGthbml0dyk6IGhhdmUgc29tZSBjb25maWcgdG8gdHVybiBvZmYgYXV0by1zb3J0IGZvciBsaW5lIChmb3IgbGluZSBjaGFydCB0aGF0IGVuY29kZXMgdGVtcG9yYWwgaW5mb3JtYXRpb24pXG4gIGlmIChsaW5lVHlwZSkge1xuICAgIHZhciBmID0gKGVuY29kaW5nLmlzTWVhc3VyZShYKSAmJiBlbmNvZGluZy5pc0RpbWVuc2lvbihZKSkgPyBZIDogWDtcbiAgICBpZiAoIW1kZWYuZnJvbSkgbWRlZi5mcm9tID0ge307XG4gICAgLy8gVE9ETzogd2h5IC0gP1xuICAgIG1kZWYuZnJvbS50cmFuc2Zvcm0gPSBbe3R5cGU6ICdzb3J0JywgYnk6ICctJyArIGVuY29kaW5nLmZpZWxkKGYpfV07XG4gIH1cblxuICAvLyBTbWFsbCBNdWx0aXBsZXNcbiAgaWYgKGhhc1JvdyB8fCBoYXNDb2wpIHtcbiAgICBzcGVjID0gZmFjZXQoZ3JvdXAsIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBzb3J0aW5nLCBzcGVjLCBtZGVmLCBzdGFjaywgc3RhdHMpO1xuICAgIHNwZWMubGVnZW5kcyA9IGxlZ2VuZC5kZWZzKGVuY29kaW5nKTtcbiAgfSBlbHNlIHtcbiAgICBncm91cC5zY2FsZXMgPSBzY2FsZS5kZWZzKHNjYWxlLm5hbWVzKG1kZWYucHJvcGVydGllcy51cGRhdGUpLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc29ydGluZyxcbiAgICAgIHtzdGFjazogc3RhY2ssIHN0YXRzOiBzdGF0c30pO1xuICAgIGdyb3VwLmF4ZXMgPSBheGlzLmRlZnMoYXhpcy5uYW1lcyhtZGVmLnByb3BlcnRpZXMudXBkYXRlKSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpO1xuICAgIGdyb3VwLmxlZ2VuZHMgPSBsZWdlbmQuZGVmcyhlbmNvZGluZyk7XG4gIH1cblxuICBmaWx0ZXIuZmlsdGVyTGVzc1RoYW5aZXJvKHNwZWMsIGVuY29kaW5nKTtcblxuICByZXR1cm4gc3BlYztcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyk7XG5cbnZhciBheGlzID0gcmVxdWlyZSgnLi9heGlzJyksXG4gIGdyb3VwZGVmID0gcmVxdWlyZSgnLi9ncm91cCcpLmRlZixcbiAgc2NhbGUgPSByZXF1aXJlKCcuL3NjYWxlJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZmFjZXRpbmc7XG5cbmZ1bmN0aW9uIGZhY2V0aW5nKGdyb3VwLCBlbmNvZGluZywgbGF5b3V0LCBzdHlsZSwgc29ydGluZywgc3BlYywgbWRlZiwgc3RhY2ssIHN0YXRzKSB7XG4gIHZhciBlbnRlciA9IGdyb3VwLnByb3BlcnRpZXMuZW50ZXI7XG4gIHZhciBmYWNldEtleXMgPSBbXSwgY2VsbEF4ZXMgPSBbXSwgZnJvbSwgYXhlc0dycDtcblxuICB2YXIgaGFzUm93ID0gZW5jb2RpbmcuaGFzKFJPVyksIGhhc0NvbCA9IGVuY29kaW5nLmhhcyhDT0wpO1xuXG4gIGVudGVyLmZpbGwgPSB7dmFsdWU6IGVuY29kaW5nLmNvbmZpZygnY2VsbEJhY2tncm91bmRDb2xvcicpfTtcblxuICAvL21vdmUgXCJmcm9tXCIgdG8gY2VsbCBsZXZlbCBhbmQgYWRkIGZhY2V0IHRyYW5zZm9ybVxuICBncm91cC5mcm9tID0ge2RhdGE6IGdyb3VwLm1hcmtzWzBdLmZyb20uZGF0YX07XG5cbiAgLy8gSGFjaywgdGhpcyBuZWVkcyB0byBiZSByZWZhY3RvcmVkXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JvdXAubWFya3MubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgbWFyayA9IGdyb3VwLm1hcmtzW2ldO1xuICAgIGlmIChtYXJrLmZyb20udHJhbnNmb3JtKSB7XG4gICAgICBkZWxldGUgbWFyay5mcm9tLmRhdGE7IC8vbmVlZCB0byBrZWVwIHRyYW5zZm9ybSBmb3Igc3ViZmFjZXR0aW5nIGNhc2VcbiAgICB9IGVsc2Uge1xuICAgICAgZGVsZXRlIG1hcmsuZnJvbTtcbiAgICB9XG4gIH1cblxuICBpZiAoaGFzUm93KSB7XG4gICAgaWYgKCFlbmNvZGluZy5pc0RpbWVuc2lvbihST1cpKSB7XG4gICAgICB1dGlsLmVycm9yKCdSb3cgZW5jb2Rpbmcgc2hvdWxkIGJlIG9yZGluYWwuJyk7XG4gICAgfVxuICAgIGVudGVyLnkgPSB7c2NhbGU6IFJPVywgZmllbGQ6ICdrZXlzLicgKyBmYWNldEtleXMubGVuZ3RofTtcbiAgICBlbnRlci5oZWlnaHQgPSB7J3ZhbHVlJzogbGF5b3V0LmNlbGxIZWlnaHR9OyAvLyBIQUNLXG5cbiAgICBmYWNldEtleXMucHVzaChlbmNvZGluZy5maWVsZChST1cpKTtcblxuICAgIGlmIChoYXNDb2wpIHtcbiAgICAgIGZyb20gPSB1dGlsLmR1cGxpY2F0ZShncm91cC5mcm9tKTtcbiAgICAgIGZyb20udHJhbnNmb3JtID0gZnJvbS50cmFuc2Zvcm0gfHwgW107XG4gICAgICBmcm9tLnRyYW5zZm9ybS51bnNoaWZ0KHt0eXBlOiAnZmFjZXQnLCBrZXlzOiBbZW5jb2RpbmcuZmllbGQoQ09MKV19KTtcbiAgICB9XG5cbiAgICBheGVzR3JwID0gZ3JvdXBkZWYoJ3gtYXhlcycsIHtcbiAgICAgICAgYXhlczogZW5jb2RpbmcuaGFzKFgpID8gYXhpcy5kZWZzKFsneCddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykgOiB1bmRlZmluZWQsXG4gICAgICAgIHg6IGhhc0NvbCA/IHtzY2FsZTogQ09MLCBmaWVsZDogJ2tleXMuMCd9IDoge3ZhbHVlOiAwfSxcbiAgICAgICAgd2lkdGg6IGhhc0NvbCAmJiB7J3ZhbHVlJzogbGF5b3V0LmNlbGxXaWR0aH0sIC8vSEFDSz9cbiAgICAgICAgZnJvbTogZnJvbVxuICAgICAgfSk7XG5cbiAgICBzcGVjLm1hcmtzLnVuc2hpZnQoYXhlc0dycCk7IC8vIG5lZWQgdG8gcHJlcGVuZCBzbyBpdCBhcHBlYXJzIHVuZGVyIHRoZSBwbG90c1xuICAgIChzcGVjLmF4ZXMgPSBzcGVjLmF4ZXMgfHwgW10pO1xuICAgIHNwZWMuYXhlcy5wdXNoLmFwcGx5KHNwZWMuYXhlcywgYXhpcy5kZWZzKFsncm93J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gIH0gZWxzZSB7IC8vIGRvZXNuJ3QgaGF2ZSByb3dcbiAgICBpZiAoZW5jb2RpbmcuaGFzKFgpKSB7XG4gICAgICAvL2tlZXAgeCBheGlzIGluIHRoZSBjZWxsXG4gICAgICBjZWxsQXhlcy5wdXNoLmFwcGx5KGNlbGxBeGVzLCBheGlzLmRlZnMoWyd4J10sIGVuY29kaW5nLCBsYXlvdXQsIHN0YXRzKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGhhc0NvbCkge1xuICAgIGlmICghZW5jb2RpbmcuaXNEaW1lbnNpb24oQ09MKSkge1xuICAgICAgdXRpbC5lcnJvcignQ29sIGVuY29kaW5nIHNob3VsZCBiZSBvcmRpbmFsLicpO1xuICAgIH1cbiAgICBlbnRlci54ID0ge3NjYWxlOiBDT0wsIGZpZWxkOiAna2V5cy4nICsgZmFjZXRLZXlzLmxlbmd0aH07XG4gICAgZW50ZXIud2lkdGggPSB7J3ZhbHVlJzogbGF5b3V0LmNlbGxXaWR0aH07IC8vIEhBQ0tcblxuICAgIGZhY2V0S2V5cy5wdXNoKGVuY29kaW5nLmZpZWxkKENPTCkpO1xuXG4gICAgaWYgKGhhc1Jvdykge1xuICAgICAgZnJvbSA9IHV0aWwuZHVwbGljYXRlKGdyb3VwLmZyb20pO1xuICAgICAgZnJvbS50cmFuc2Zvcm0gPSBmcm9tLnRyYW5zZm9ybSB8fCBbXTtcbiAgICAgIGZyb20udHJhbnNmb3JtLnVuc2hpZnQoe3R5cGU6ICdmYWNldCcsIGtleXM6IFtlbmNvZGluZy5maWVsZChST1cpXX0pO1xuICAgIH1cblxuICAgIGF4ZXNHcnAgPSBncm91cGRlZigneS1heGVzJywge1xuICAgICAgYXhlczogZW5jb2RpbmcuaGFzKFkpID8gYXhpcy5kZWZzKFsneSddLCBlbmNvZGluZywgbGF5b3V0LCBzdGF0cykgOiB1bmRlZmluZWQsXG4gICAgICB5OiBoYXNSb3cgJiYge3NjYWxlOiBST1csIGZpZWxkOiAna2V5cy4wJ30sXG4gICAgICB4OiBoYXNSb3cgJiYge3ZhbHVlOiAwfSxcbiAgICAgIGhlaWdodDogaGFzUm93ICYmIHsndmFsdWUnOiBsYXlvdXQuY2VsbEhlaWdodH0sIC8vSEFDSz9cbiAgICAgIGZyb206IGZyb21cbiAgICB9KTtcblxuICAgIHNwZWMubWFya3MudW5zaGlmdChheGVzR3JwKTsgLy8gbmVlZCB0byBwcmVwZW5kIHNvIGl0IGFwcGVhcnMgdW5kZXIgdGhlIHBsb3RzXG4gICAgKHNwZWMuYXhlcyA9IHNwZWMuYXhlcyB8fCBbXSk7XG4gICAgc3BlYy5heGVzLnB1c2guYXBwbHkoc3BlYy5heGVzLCBheGlzLmRlZnMoWydjb2wnXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgfSBlbHNlIHsgLy8gZG9lc24ndCBoYXZlIGNvbFxuICAgIGlmIChlbmNvZGluZy5oYXMoWSkpIHtcbiAgICAgIGNlbGxBeGVzLnB1c2guYXBwbHkoY2VsbEF4ZXMsIGF4aXMuZGVmcyhbJ3knXSwgZW5jb2RpbmcsIGxheW91dCwgc3RhdHMpKTtcbiAgICB9XG4gIH1cblxuICAvLyBhc3N1bWluZyBlcXVhbCBjZWxsV2lkdGggaGVyZVxuICAvLyBUT0RPOiBzdXBwb3J0IGhldGVyb2dlbm91cyBjZWxsV2lkdGggKG1heWJlIGJ5IHVzaW5nIG11bHRpcGxlIHNjYWxlcz8pXG4gIHNwZWMuc2NhbGVzID0gKHNwZWMuc2NhbGVzIHx8IFtdKS5jb25jYXQoc2NhbGUuZGVmcyhcbiAgICBzY2FsZS5uYW1lcyhlbnRlcikuY29uY2F0KHNjYWxlLm5hbWVzKG1kZWYucHJvcGVydGllcy51cGRhdGUpKSxcbiAgICBlbmNvZGluZyxcbiAgICBsYXlvdXQsXG4gICAgc3R5bGUsXG4gICAgc29ydGluZyxcbiAgICB7c3RhY2s6IHN0YWNrLCBmYWNldDogdHJ1ZSwgc3RhdHM6IHN0YXRzfVxuICApKTsgLy8gcm93L2NvbCBzY2FsZXMgKyBjZWxsIHNjYWxlc1xuXG4gIGlmIChjZWxsQXhlcy5sZW5ndGggPiAwKSB7XG4gICAgZ3JvdXAuYXhlcyA9IGNlbGxBeGVzO1xuICB9XG5cbiAgLy8gYWRkIGZhY2V0IHRyYW5zZm9ybVxuICB2YXIgdHJhbnMgPSAoZ3JvdXAuZnJvbS50cmFuc2Zvcm0gfHwgKGdyb3VwLmZyb20udHJhbnNmb3JtID0gW10pKTtcbiAgdHJhbnMudW5zaGlmdCh7dHlwZTogJ2ZhY2V0Jywga2V5czogZmFjZXRLZXlzfSk7XG5cbiAgcmV0dXJuIHNwZWM7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgZmlsdGVyID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudmFyIEJJTkFSWSA9IHtcbiAgJz4nOiAgdHJ1ZSxcbiAgJz49JzogdHJ1ZSxcbiAgJz0nOiAgdHJ1ZSxcbiAgJyE9JzogdHJ1ZSxcbiAgJzwnOiAgdHJ1ZSxcbiAgJzw9JzogdHJ1ZVxufTtcblxuZmlsdGVyLmFkZEZpbHRlcnMgPSBmdW5jdGlvbihzcGVjLCBlbmNvZGluZykge1xuICB2YXIgZmlsdGVycyA9IGVuY29kaW5nLmZpbHRlcigpLFxuICAgIGRhdGEgPSBzcGVjLmRhdGFbMF07ICAvLyBhcHBseSBmaWx0ZXJzIHRvIHJhdyBkYXRhIGJlZm9yZSBhZ2dyZWdhdGlvblxuXG4gIGlmICghZGF0YS50cmFuc2Zvcm0pXG4gICAgZGF0YS50cmFuc2Zvcm0gPSBbXTtcblxuICAvLyBhZGQgY3VzdG9tIGZpbHRlcnNcbiAgZm9yICh2YXIgaSBpbiBmaWx0ZXJzKSB7XG4gICAgdmFyIGZpbHRlciA9IGZpbHRlcnNbaV07XG5cbiAgICB2YXIgY29uZGl0aW9uID0gJyc7XG4gICAgdmFyIG9wZXJhdG9yID0gZmlsdGVyLm9wZXJhdG9yO1xuICAgIHZhciBvcGVyYW5kcyA9IGZpbHRlci5vcGVyYW5kcztcblxuICAgIGlmIChCSU5BUllbb3BlcmF0b3JdKSB7XG4gICAgICAvLyBleHBlY3RzIGEgZmllbGQgYW5kIGEgdmFsdWVcbiAgICAgIGlmIChvcGVyYXRvciA9PT0gJz0nKSB7XG4gICAgICAgIG9wZXJhdG9yID0gJz09JztcbiAgICAgIH1cblxuICAgICAgdmFyIG9wMSA9IG9wZXJhbmRzWzBdO1xuICAgICAgdmFyIG9wMiA9IG9wZXJhbmRzWzFdO1xuICAgICAgY29uZGl0aW9uID0gJ2QuZGF0YS4nICsgb3AxICsgb3BlcmF0b3IgKyBvcDI7XG4gICAgfSBlbHNlIGlmIChvcGVyYXRvciA9PT0gJ25vdE51bGwnKSB7XG4gICAgICAvLyBleHBlY3RzIGEgbnVtYmVyIG9mIGZpZWxkc1xuICAgICAgZm9yICh2YXIgaiBpbiBvcGVyYW5kcykge1xuICAgICAgICBjb25kaXRpb24gKz0gJ2QuZGF0YS4nICsgb3BlcmFuZHNbal0gKyAnIT09bnVsbCc7XG4gICAgICAgIGlmIChqIDwgb3BlcmFuZHMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIGNvbmRpdGlvbiArPSAnICYmICc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS53YXJuKCdVbnN1cHBvcnRlZCBvcGVyYXRvcjogJywgb3BlcmF0b3IpO1xuICAgIH1cblxuICAgIGRhdGEudHJhbnNmb3JtLnB1c2goe1xuICAgICAgdHlwZTogJ2ZpbHRlcicsXG4gICAgICB0ZXN0OiBjb25kaXRpb25cbiAgICB9KTtcbiAgfVxufTtcblxuLy8gcmVtb3ZlIGxlc3MgdGhhbiAwIHZhbHVlcyBpZiB3ZSB1c2UgbG9nIGZ1bmN0aW9uXG5maWx0ZXIuZmlsdGVyTGVzc1RoYW5aZXJvID0gZnVuY3Rpb24oc3BlYywgZW5jb2RpbmcpIHtcbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIGlmIChlbmNvZGluZy5zY2FsZShlbmNUeXBlKS50eXBlID09PSAnbG9nJykge1xuICAgICAgc3BlYy5kYXRhWzFdLnRyYW5zZm9ybS5wdXNoKHtcbiAgICAgICAgdHlwZTogJ2ZpbHRlcicsXG4gICAgICAgIHRlc3Q6ICdkLicgKyBlbmNvZGluZy5maWVsZChlbmNUeXBlKSArICc+MCdcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59O1xuXG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWY6IGdyb3VwZGVmXG59O1xuXG5mdW5jdGlvbiBncm91cGRlZihuYW1lLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuICByZXR1cm4ge1xuICAgIF9uYW1lOiBuYW1lIHx8IHVuZGVmaW5lZCxcbiAgICB0eXBlOiAnZ3JvdXAnLFxuICAgIGZyb206IG9wdC5mcm9tLFxuICAgIHByb3BlcnRpZXM6IHtcbiAgICAgIGVudGVyOiB7XG4gICAgICAgIHg6IG9wdC54IHx8IHVuZGVmaW5lZCxcbiAgICAgICAgeTogb3B0LnkgfHwgdW5kZWZpbmVkLFxuICAgICAgICB3aWR0aDogb3B0LndpZHRoIHx8IHtncm91cDogJ3dpZHRoJ30sXG4gICAgICAgIGhlaWdodDogb3B0LmhlaWdodCB8fCB7Z3JvdXA6ICdoZWlnaHQnfVxuICAgICAgfVxuICAgIH0sXG4gICAgc2NhbGVzOiBvcHQuc2NhbGVzIHx8IHVuZGVmaW5lZCxcbiAgICBheGVzOiBvcHQuYXhlcyB8fCB1bmRlZmluZWQsXG4gICAgbWFya3M6IG9wdC5tYXJrcyB8fCBbXVxuICB9O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgc2V0dGVyID0gdXRpbC5zZXR0ZXIsXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4uL3NjaGVtYS9zY2hlbWEnKSxcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpLFxuICB2bGZpZWxkID0gcmVxdWlyZSgnLi4vZmllbGQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSB2bGxheW91dDtcblxuZnVuY3Rpb24gdmxsYXlvdXQoZW5jb2RpbmcsIHN0YXRzKSB7XG4gIHZhciBsYXlvdXQgPSBib3goZW5jb2RpbmcsIHN0YXRzKTtcbiAgbGF5b3V0ID0gb2Zmc2V0KGVuY29kaW5nLCBzdGF0cywgbGF5b3V0KTtcbiAgcmV0dXJuIGxheW91dDtcbn1cblxuLypcbiAgSEFDSyB0byBzZXQgY2hhcnQgc2l6ZVxuICBOT1RFOiB0aGlzIGZhaWxzIGZvciBwbG90cyBkcml2ZW4gYnkgZGVyaXZlZCB2YWx1ZXMgKGUuZy4sIGFnZ3JlZ2F0ZXMpXG4gIE9uZSBzb2x1dGlvbiBpcyB0byB1cGRhdGUgVmVnYSB0byBzdXBwb3J0IGF1dG8tc2l6aW5nXG4gIEluIHRoZSBtZWFudGltZSwgYXV0by1wYWRkaW5nIChtb3N0bHkpIGRvZXMgdGhlIHRyaWNrXG4gKi9cbmZ1bmN0aW9uIGJveChlbmNvZGluZywgc3RhdHMpIHtcbiAgdmFyIGhhc1JvdyA9IGVuY29kaW5nLmhhcyhST1cpLFxuICAgICAgaGFzQ29sID0gZW5jb2RpbmcuaGFzKENPTCksXG4gICAgICBoYXNYID0gZW5jb2RpbmcuaGFzKFgpLFxuICAgICAgaGFzWSA9IGVuY29kaW5nLmhhcyhZKSxcbiAgICAgIG1hcmt0eXBlID0gZW5jb2RpbmcubWFya3R5cGUoKTtcblxuICAvLyBGSVhNRS9IQUNLIHdlIG5lZWQgdG8gdGFrZSBmaWx0ZXIgaW50byBhY2NvdW50XG4gIHZhciB4Q2FyZGluYWxpdHkgPSBoYXNYICYmIGVuY29kaW5nLmlzRGltZW5zaW9uKFgpID8gZW5jb2RpbmcuY2FyZGluYWxpdHkoWCwgc3RhdHMpIDogMSxcbiAgICB5Q2FyZGluYWxpdHkgPSBoYXNZICYmIGVuY29kaW5nLmlzRGltZW5zaW9uKFkpID8gZW5jb2RpbmcuY2FyZGluYWxpdHkoWSwgc3RhdHMpIDogMTtcblxuICB2YXIgdXNlU21hbGxCYW5kID0geENhcmRpbmFsaXR5ID4gZW5jb2RpbmcuY29uZmlnKCdsYXJnZUJhbmRNYXhDYXJkaW5hbGl0eScpIHx8XG4gICAgeUNhcmRpbmFsaXR5ID4gZW5jb2RpbmcuY29uZmlnKCdsYXJnZUJhbmRNYXhDYXJkaW5hbGl0eScpO1xuXG4gIHZhciBjZWxsV2lkdGgsIGNlbGxIZWlnaHQsIGNlbGxQYWRkaW5nID0gZW5jb2RpbmcuY29uZmlnKCdjZWxsUGFkZGluZycpO1xuXG4gIC8vIHNldCBjZWxsV2lkdGhcbiAgaWYgKGhhc1gpIHtcbiAgICBpZiAoZW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUoWCkpIHtcbiAgICAgIC8vIGZvciBvcmRpbmFsLCBoYXNDb2wgb3Igbm90IGRvZXNuJ3QgbWF0dGVyIC0tIHdlIHNjYWxlIGJhc2VkIG9uIGNhcmRpbmFsaXR5XG4gICAgICBjZWxsV2lkdGggPSAoeENhcmRpbmFsaXR5ICsgZW5jb2RpbmcuYmFuZChYKS5wYWRkaW5nKSAqIGVuY29kaW5nLmJhbmRTaXplKFgsIHVzZVNtYWxsQmFuZCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNlbGxXaWR0aCA9IGhhc0NvbCB8fCBoYXNSb3cgPyBlbmNvZGluZy5lbmMoQ09MKS53aWR0aCA6ICBlbmNvZGluZy5jb25maWcoXCJzaW5nbGVXaWR0aFwiKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaWYgKG1hcmt0eXBlID09PSBURVhUKSB7XG4gICAgICBjZWxsV2lkdGggPSBlbmNvZGluZy5jb25maWcoJ3RleHRDZWxsV2lkdGgnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2VsbFdpZHRoID0gZW5jb2RpbmcuYmFuZFNpemUoWCk7XG4gICAgfVxuICB9XG5cbiAgLy8gc2V0IGNlbGxIZWlnaHRcbiAgaWYgKGhhc1kpIHtcbiAgICBpZiAoZW5jb2RpbmcuaXNPcmRpbmFsU2NhbGUoWSkpIHtcbiAgICAgIC8vIGZvciBvcmRpbmFsLCBoYXNDb2wgb3Igbm90IGRvZXNuJ3QgbWF0dGVyIC0tIHdlIHNjYWxlIGJhc2VkIG9uIGNhcmRpbmFsaXR5XG4gICAgICBjZWxsSGVpZ2h0ID0gKHlDYXJkaW5hbGl0eSArIGVuY29kaW5nLmJhbmQoWSkucGFkZGluZykgKiBlbmNvZGluZy5iYW5kU2l6ZShZLCB1c2VTbWFsbEJhbmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjZWxsSGVpZ2h0ID0gaGFzQ29sIHx8IGhhc1JvdyA/IGVuY29kaW5nLmVuYyhST1cpLmhlaWdodCA6ICBlbmNvZGluZy5jb25maWcoXCJzaW5nbGVIZWlnaHRcIik7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGNlbGxIZWlnaHQgPSBlbmNvZGluZy5iYW5kU2l6ZShZKTtcbiAgfVxuXG4gIC8vIENlbGwgYmFuZHMgdXNlIHJhbmdlQmFuZHMoKS4gVGhlcmUgYXJlIG4tMSBwYWRkaW5nLiAgT3V0ZXJwYWRkaW5nID0gMCBmb3IgY2VsbHNcblxuICB2YXIgd2lkdGggPSBjZWxsV2lkdGgsIGhlaWdodCA9IGNlbGxIZWlnaHQ7XG4gIGlmIChoYXNDb2wpIHtcbiAgICB2YXIgY29sQ2FyZGluYWxpdHkgPSBlbmNvZGluZy5jYXJkaW5hbGl0eShDT0wsIHN0YXRzKTtcbiAgICB3aWR0aCA9IGNlbGxXaWR0aCAqICgoMSArIGNlbGxQYWRkaW5nKSAqIChjb2xDYXJkaW5hbGl0eSAtIDEpICsgMSk7XG4gIH1cbiAgaWYgKGhhc1Jvdykge1xuICAgIHZhciByb3dDYXJkaW5hbGl0eSA9ICBlbmNvZGluZy5jYXJkaW5hbGl0eShST1csIHN0YXRzKTtcbiAgICBoZWlnaHQgPSBjZWxsSGVpZ2h0ICogKCgxICsgY2VsbFBhZGRpbmcpICogKHJvd0NhcmRpbmFsaXR5IC0gMSkgKyAxKTtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLy8gd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgd2hvbGUgY2VsbFxuICAgIGNlbGxXaWR0aDogY2VsbFdpZHRoLFxuICAgIGNlbGxIZWlnaHQ6IGNlbGxIZWlnaHQsXG4gICAgY2VsbFBhZGRpbmc6IGNlbGxQYWRkaW5nLFxuICAgIC8vIHdpZHRoIGFuZCBoZWlnaHQgb2YgdGhlIGNoYXJ0XG4gICAgd2lkdGg6IHdpZHRoLFxuICAgIGhlaWdodDogaGVpZ2h0LFxuICAgIC8vIGluZm9ybWF0aW9uIGFib3V0IHggYW5kIHksIHN1Y2ggYXMgYmFuZCBzaXplXG4gICAgeDoge3VzZVNtYWxsQmFuZDogdXNlU21hbGxCYW5kfSxcbiAgICB5OiB7dXNlU21hbGxCYW5kOiB1c2VTbWFsbEJhbmR9XG4gIH07XG59XG5cbmZ1bmN0aW9uIG9mZnNldChlbmNvZGluZywgc3RhdHMsIGxheW91dCkge1xuICBbWCwgWV0uZm9yRWFjaChmdW5jdGlvbiAoeCkge1xuICAgIHZhciBtYXhMZW5ndGg7XG4gICAgaWYgKGVuY29kaW5nLmlzRGltZW5zaW9uKHgpIHx8IGVuY29kaW5nLmlzVHlwZSh4LCBUKSkge1xuICAgICAgbWF4TGVuZ3RoID0gc3RhdHNbZW5jb2RpbmcuZmllbGROYW1lKHgpXS5tYXhsZW5ndGg7XG4gICAgfSBlbHNlIGlmIChlbmNvZGluZy5hZ2dyKHgpID09PSAnY291bnQnKSB7XG4gICAgICAvL2Fzc2lnbiBkZWZhdWx0IHZhbHVlIGZvciBjb3VudCBhcyBpdCB3b24ndCBoYXZlIHN0YXRzXG4gICAgICBtYXhMZW5ndGggPSAgMztcbiAgICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzVHlwZSh4LCBRKSkge1xuICAgICAgaWYgKHg9PT1YKSB7XG4gICAgICAgIG1heExlbmd0aCA9IDM7XG4gICAgICB9IGVsc2UgeyAvLyBZXG4gICAgICAgIC8vYXNzdW1lIHRoYXQgZGVmYXVsdCBmb3JtYXRpbmcgaXMgYWx3YXlzIHNob3J0ZXIgdGhhbiA3XG4gICAgICAgIG1heExlbmd0aCA9IE1hdGgubWluKHN0YXRzW2VuY29kaW5nLmZpZWxkTmFtZSh4KV0ubWF4bGVuZ3RoLCA3KTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0dGVyKGxheW91dCxbeCwgJ2F4aXNUaXRsZU9mZnNldCddLCBlbmNvZGluZy5jb25maWcoJ2NoYXJhY3RlcldpZHRoJykgKiAgbWF4TGVuZ3RoICsgMjApO1xuICB9KTtcbiAgcmV0dXJuIGxheW91dDtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbCA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdGltZSA9IHJlcXVpcmUoJy4vdGltZScpO1xuXG52YXIgbGVnZW5kID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxubGVnZW5kLmRlZnMgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgZGVmcyA9IFtdO1xuXG4gIC8vIFRPRE86IHN1cHBvcnQgYWxwaGFcblxuICBpZiAoZW5jb2RpbmcuaGFzKENPTE9SKSAmJiBlbmNvZGluZy5sZWdlbmQoQ09MT1IpKSB7XG4gICAgZGVmcy5wdXNoKGxlZ2VuZC5kZWYoQ09MT1IsIGVuY29kaW5nLCB7XG4gICAgICBmaWxsOiBDT0xPUixcbiAgICAgIG9yaWVudDogJ3JpZ2h0J1xuICAgIH0pKTtcbiAgfVxuXG4gIGlmIChlbmNvZGluZy5oYXMoU0laRSkgJiYgZW5jb2RpbmcubGVnZW5kKFNJWkUpKSB7XG4gICAgZGVmcy5wdXNoKGxlZ2VuZC5kZWYoU0laRSwgZW5jb2RpbmcsIHtcbiAgICAgIHNpemU6IFNJWkUsXG4gICAgICBvcmllbnQ6IGRlZnMubGVuZ3RoID09PSAxID8gJ2xlZnQnIDogJ3JpZ2h0J1xuICAgIH0pKTtcbiAgfVxuXG4gIGlmIChlbmNvZGluZy5oYXMoU0hBUEUpICYmIGVuY29kaW5nLmxlZ2VuZChTSEFQRSkpIHtcbiAgICBpZiAoZGVmcy5sZW5ndGggPT09IDIpIHtcbiAgICAgIC8vIFRPRE86IGZpeCB0aGlzXG4gICAgICBjb25zb2xlLmVycm9yKCdWZWdhbGl0ZSBjdXJyZW50bHkgb25seSBzdXBwb3J0cyB0d28gbGVnZW5kcycpO1xuICAgICAgcmV0dXJuIGRlZnM7XG4gICAgfVxuICAgIGRlZnMucHVzaChsZWdlbmQuZGVmKFNIQVBFLCBlbmNvZGluZywge1xuICAgICAgc2hhcGU6IFNIQVBFLFxuICAgICAgb3JpZW50OiBkZWZzLmxlbmd0aCA9PT0gMSA/ICdsZWZ0JyA6ICdyaWdodCdcbiAgICB9KSk7XG4gIH1cblxuICByZXR1cm4gZGVmcztcbn07XG5cbmxlZ2VuZC5kZWYgPSBmdW5jdGlvbihuYW1lLCBlbmNvZGluZywgcHJvcHMpIHtcbiAgdmFyIGRlZiA9IHByb3BzLCBmbjtcblxuICBkZWYudGl0bGUgPSBlbmNvZGluZy5maWVsZFRpdGxlKG5hbWUpO1xuXG4gIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkgJiYgKGZuID0gZW5jb2RpbmcuZm4obmFtZSkpICYmXG4gICAgdGltZS5oYXNTY2FsZShmbikpIHtcbiAgICB2YXIgcHJvcGVydGllcyA9IGRlZi5wcm9wZXJ0aWVzID0gZGVmLnByb3BlcnRpZXMgfHwge30sXG4gICAgICBsYWJlbHMgPSBwcm9wZXJ0aWVzLmxhYmVscyA9IHByb3BlcnRpZXMubGFiZWxzIHx8IHt9LFxuICAgICAgdGV4dCA9IGxhYmVscy50ZXh0ID0gbGFiZWxzLnRleHQgfHwge307XG5cbiAgICB0ZXh0LnNjYWxlID0gJ3RpbWUtJysgZm47XG4gIH1cblxuICByZXR1cm4gZGVmO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGdsb2JhbHMgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyksXG4gIHV0aWwgPSByZXF1aXJlKCcuLi91dGlsJyksXG4gIHZsc2NhbGUgPSByZXF1aXJlKCcuL3NjYWxlJyk7XG5cbnZhciBtYXJrcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbm1hcmtzLmRlZiA9IGZ1bmN0aW9uKG1hcmssIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlKSB7XG4gIHZhciBkZWZzID0gW107XG5cbiAgLy8gdG8gYWRkIGEgYmFja2dyb3VuZCB0byB0ZXh0LCB3ZSBuZWVkIHRvIGFkZCBpdCBiZWZvcmUgdGhlIHRleHRcbiAgaWYgKGVuY29kaW5nLm1hcmt0eXBlKCkgPT09IFRFWFQgJiYgZW5jb2RpbmcuaGFzKENPTE9SKSkge1xuICAgIHZhciBiZyA9IHtcbiAgICAgIHg6IHt2YWx1ZTogMH0sXG4gICAgICB5OiB7dmFsdWU6IDB9LFxuICAgICAgeDI6IHt2YWx1ZTogbGF5b3V0LmNlbGxXaWR0aH0sXG4gICAgICB5Mjoge3ZhbHVlOiBsYXlvdXQuY2VsbEhlaWdodH0sXG4gICAgICBmaWxsOiB7c2NhbGU6IENPTE9SLCBmaWVsZDogZW5jb2RpbmcuZmllbGQoQ09MT1IpfVxuICAgIH07XG4gICAgZGVmcy5wdXNoKHtcbiAgICAgIHR5cGU6ICdyZWN0JyxcbiAgICAgIGZyb206IHtkYXRhOiBUQUJMRX0sXG4gICAgICBwcm9wZXJ0aWVzOiB7ZW50ZXI6IGJnLCB1cGRhdGU6IGJnfVxuICAgIH0pO1xuICB9XG5cbiAgLy8gYWRkIHRoZSBtYXJrIGRlZiBmb3IgdGhlIG1haW4gdGhpbmdcbiAgdmFyIHAgPSBtYXJrLnByb3AoZW5jb2RpbmcsIGxheW91dCwgc3R5bGUpO1xuICBkZWZzLnB1c2goe1xuICAgIHR5cGU6IG1hcmsudHlwZSxcbiAgICBmcm9tOiB7ZGF0YTogVEFCTEV9LFxuICAgIHByb3BlcnRpZXM6IHtlbnRlcjogcCwgdXBkYXRlOiBwfVxuICB9KTtcblxuICByZXR1cm4gZGVmcztcbn07XG5cbm1hcmtzLmJhciA9IHtcbiAgdHlwZTogJ3JlY3QnLFxuICBzdGFjazogdHJ1ZSxcbiAgcHJvcDogYmFyX3Byb3BzLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3gnLCAneSddLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMSwgYWxwaGE6IDF9XG59O1xuXG5tYXJrcy5saW5lID0ge1xuICB0eXBlOiAnbGluZScsXG4gIGxpbmU6IHRydWUsXG4gIHByb3A6IGxpbmVfcHJvcHMsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFsneCcsICd5J10sXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIGNvbG9yOiAxLCBhbHBoYTogMSwgZGV0YWlsOjF9XG59O1xuXG5tYXJrcy5hcmVhID0ge1xuICB0eXBlOiAnYXJlYScsXG4gIHN0YWNrOiB0cnVlLFxuICBsaW5lOiB0cnVlLFxuICByZXF1aXJlZEVuY29kaW5nOiBbJ3gnLCAneSddLFxuICBwcm9wOiBhcmVhX3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBjb2xvcjogMSwgYWxwaGE6IDF9XG59O1xuXG5tYXJrcy50aWNrID0ge1xuICB0eXBlOiAncmVjdCcsXG4gIHByb3A6IHRpY2tfcHJvcHMsXG4gIHN1cHBvcnRlZEVuY29kaW5nOiB7cm93OiAxLCBjb2w6IDEsIHg6IDEsIHk6IDEsIGNvbG9yOiAxLCBhbHBoYTogMSwgZGV0YWlsOiAxfVxufTtcblxubWFya3MuY2lyY2xlID0ge1xuICB0eXBlOiAnc3ltYm9sJyxcbiAgcHJvcDogZmlsbGVkX3BvaW50X3Byb3BzKCdjaXJjbGUnKSxcbiAgc3VwcG9ydGVkRW5jb2Rpbmc6IHtyb3c6IDEsIGNvbDogMSwgeDogMSwgeTogMSwgc2l6ZTogMSwgY29sb3I6IDEsIGFscGhhOiAxLCBkZXRhaWw6IDF9XG59O1xuXG5tYXJrcy5zcXVhcmUgPSB7XG4gIHR5cGU6ICdzeW1ib2wnLFxuICBwcm9wOiBmaWxsZWRfcG9pbnRfcHJvcHMoJ3NxdWFyZScpLFxuICBzdXBwb3J0ZWRFbmNvZGluZzogbWFya3MuY2lyY2xlLnN1cHBvcnRlZEVuY29kaW5nXG59O1xuXG5tYXJrcy5wb2ludCA9IHtcbiAgdHlwZTogJ3N5bWJvbCcsXG4gIHByb3A6IHBvaW50X3Byb3BzLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCB4OiAxLCB5OiAxLCBzaXplOiAxLCBjb2xvcjogMSwgYWxwaGE6IDEsIHNoYXBlOiAxLCBkZXRhaWw6IDF9XG59O1xuXG5tYXJrcy50ZXh0ID0ge1xuICB0eXBlOiAndGV4dCcsXG4gIHByb3A6IHRleHRfcHJvcHMsXG4gIHJlcXVpcmVkRW5jb2Rpbmc6IFsndGV4dCddLFxuICBzdXBwb3J0ZWRFbmNvZGluZzoge3JvdzogMSwgY29sOiAxLCBzaXplOiAxLCBjb2xvcjogMSwgYWxwaGE6IDEsIHRleHQ6IDF9XG59O1xuXG5mdW5jdGlvbiBiYXJfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaXNNZWFzdXJlKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gICAgaWYgKGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICAgIHAueDIgPSB7c2NhbGU6IFgsIHZhbHVlOiBlLnNjYWxlKFgpLnR5cGUgPT09ICdsb2cnID8gMSA6IDB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChlLmhhcyhYKSkgeyAvLyBpcyBvcmRpbmFsXG4gICAgcC54YyA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2Uge1xuICAgIC8vIFRPRE8gYWRkIHNpbmdsZSBiYXIgb2Zmc2V0XG4gICAgcC54YyA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmlzTWVhc3VyZShZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICAgIHAueTIgPSB7c2NhbGU6IFksIHZhbHVlOiBlLnNjYWxlKFkpLnR5cGUgPT09ICdsb2cnID8gMSA6IDB9O1xuICB9IGVsc2UgaWYgKGUuaGFzKFkpKSB7IC8vIGlzIG9yZGluYWxcbiAgICBwLnljID0ge3NjYWxlOiBZLCBmaWVsZDogZS5maWVsZChZKX07XG4gIH0gZWxzZSB7XG4gICAgLy8gVE9ETyBhZGQgc2luZ2xlIGJhciBvZmZzZXRcbiAgICBwLnljID0ge2dyb3VwOiAnaGVpZ2h0J307XG4gIH1cblxuICAvLyB3aWR0aFxuICBpZiAoIWUuaGFzKFgpIHx8IGUuaXNPcmRpbmFsU2NhbGUoWCkpIHsgLy8gbm8gWCBvciBYIGlzIG9yZGluYWxcbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAud2lkdGggPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC53aWR0aCA9IHtcbiAgICAgICAgdmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSxcbiAgICAgICAgb2Zmc2V0OiAtMVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSB7IC8vIFggaXMgUXVhbnQgb3IgVGltZSBTY2FsZVxuICAgIHAud2lkdGggPSB7dmFsdWU6IDJ9O1xuICB9XG5cbiAgLy8gaGVpZ2h0XG4gIGlmICghZS5oYXMoWSkgfHwgZS5pc09yZGluYWxTY2FsZShZKSkgeyAvLyBubyBZIG9yIFkgaXMgb3JkaW5hbFxuICAgIGlmIChlLmhhcyhTSVpFKSkge1xuICAgICAgcC5oZWlnaHQgPSB7c2NhbGU6IFNJWkUsIGZpZWxkOiBlLmZpZWxkKFNJWkUpfTtcbiAgICB9IGVsc2Uge1xuICAgICAgcC5oZWlnaHQgPSB7XG4gICAgICAgIHZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCksXG4gICAgICAgIG9mZnNldDogLTFcbiAgICAgIH07XG4gICAgfVxuICB9IGVsc2UgeyAvLyBZIGlzIFF1YW50IG9yIFRpbWUgU2NhbGVcbiAgICBwLmhlaWdodCA9IHt2YWx1ZTogMn07XG4gIH1cblxuICAvLyBmaWxsXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2Uge1xuICAgIHAuZmlsbCA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIHBvaW50X3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogZS5iYW5kU2l6ZShZLCBsYXlvdXQueS51c2VTbWFsbEJhbmQpIC8gMn07XG4gIH1cblxuICAvLyBzaXplXG4gIGlmIChlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGQoU0laRSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhTSVpFKSkge1xuICAgIHAuc2l6ZSA9IHt2YWx1ZTogZS52YWx1ZShTSVpFKX07XG4gIH1cblxuICAvLyBzaGFwZVxuICBpZiAoZS5oYXMoU0hBUEUpKSB7XG4gICAgcC5zaGFwZSA9IHtzY2FsZTogU0hBUEUsIGZpZWxkOiBlLmZpZWxkKFNIQVBFKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFNIQVBFKSkge1xuICAgIHAuc2hhcGUgPSB7dmFsdWU6IGUudmFsdWUoU0hBUEUpfTtcbiAgfVxuXG4gIC8vIHN0cm9rZVxuICBpZiAoZS5oYXMoQ09MT1IpKSB7XG4gICAgcC5zdHJva2UgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHt2YWx1ZTogZS52YWx1ZShDT0xPUil9O1xuICB9XG5cbiAgLy8gYWxwaGFcbiAgaWYgKGUuaGFzKEFMUEhBKSkge1xuICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoZS52YWx1ZShBTFBIQSkgIT09IHVuZGVmaW5lZCkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogZS52YWx1ZShBTFBIQSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IHN0eWxlLm9wYWNpdHl9O1xuICB9XG5cbiAgcC5zdHJva2VXaWR0aCA9IHt2YWx1ZTogZS5jb25maWcoJ3N0cm9rZVdpZHRoJyl9O1xuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiBsaW5lX3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHtncm91cDogJ2hlaWdodCd9O1xuICB9XG5cbiAgLy8gc3Ryb2tlXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLnN0cm9rZSA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkKENPTE9SKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAuc3Ryb2tlID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfSBlbHNlIGlmIChlLnZhbHVlKEFMUEhBKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBlLnZhbHVlKEFMUEhBKX07XG4gIH1cblxuICBwLnN0cm9rZVdpZHRoID0ge3ZhbHVlOiBlLmNvbmZpZygnc3Ryb2tlV2lkdGgnKX07XG5cbiAgcmV0dXJuIHA7XG59XG5cbmZ1bmN0aW9uIGFyZWFfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaXNNZWFzdXJlKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gICAgaWYgKGUuaXNEaW1lbnNpb24oWSkpIHtcbiAgICAgIHAueDIgPSB7c2NhbGU6IFgsIHZhbHVlOiAwfTtcbiAgICAgIHAub3JpZW50ID0ge3ZhbHVlOiAnaG9yaXpvbnRhbCd9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICB9IGVsc2Uge1xuICAgIHAueCA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmlzTWVhc3VyZShZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICAgIHAueTIgPSB7c2NhbGU6IFksIHZhbHVlOiAwfTtcbiAgfSBlbHNlIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICB9IGVsc2Uge1xuICAgIHAueSA9IHtncm91cDogJ2hlaWdodCd9O1xuICB9XG5cbiAgLy8gc3Ryb2tlXG4gIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7c2NhbGU6IENPTE9SLCBmaWVsZDogZS5maWVsZChDT0xPUil9O1xuICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgfVxuXG4gIC8vIGFscGhhXG4gIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICBwLm9wYWNpdHkgPSB7c2NhbGU6IEFMUEhBLCBmaWVsZDogZS5maWVsZChBTFBIQSl9O1xuICB9IGVsc2UgaWYgKGUudmFsdWUoQUxQSEEpICE9PSB1bmRlZmluZWQpIHtcbiAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IGUudmFsdWUoQUxQSEEpfTtcbiAgfVxuXG4gIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiB0aWNrX3Byb3BzKGUsIGxheW91dCwgc3R5bGUpIHtcbiAgdmFyIHAgPSB7fTtcblxuICAvLyB4XG4gIGlmIChlLmhhcyhYKSkge1xuICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFgpKSB7XG4gICAgICBwLngub2Zmc2V0ID0gLWUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDM7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlLmhhcyhYKSkge1xuICAgIHAueCA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB5XG4gIGlmIChlLmhhcyhZKSkge1xuICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICAgIGlmIChlLmlzRGltZW5zaW9uKFkpKSB7XG4gICAgICBwLnkub2Zmc2V0ID0gLWUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDM7XG4gICAgfVxuICB9IGVsc2UgaWYgKCFlLmhhcyhZKSkge1xuICAgIHAueSA9IHt2YWx1ZTogMH07XG4gIH1cblxuICAvLyB3aWR0aFxuICBpZiAoIWUuaGFzKFgpIHx8IGUuaXNEaW1lbnNpb24oWCkpIHtcbiAgICBwLndpZHRoID0ge3ZhbHVlOiBlLmJhbmRTaXplKFgsIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAxLjV9O1xuICB9IGVsc2Uge1xuICAgIHAud2lkdGggPSB7dmFsdWU6IDF9O1xuICB9XG5cbiAgLy8gaGVpZ2h0XG4gIGlmICghZS5oYXMoWSkgfHwgZS5pc0RpbWVuc2lvbihZKSkge1xuICAgIHAuaGVpZ2h0ID0ge3ZhbHVlOiBlLmJhbmRTaXplKFksIGxheW91dC55LnVzZVNtYWxsQmFuZCkgLyAxLjV9O1xuICB9IGVsc2Uge1xuICAgIHAuaGVpZ2h0ID0ge3ZhbHVlOiAxfTtcbiAgfVxuXG4gIC8vIGZpbGxcbiAgaWYgKGUuaGFzKENPTE9SKSkge1xuICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkKENPTE9SKX07XG4gIH0gZWxzZSB7XG4gICAgcC5maWxsID0ge3ZhbHVlOiBlLnZhbHVlKENPTE9SKX07XG4gIH1cblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfSBlbHNlIGlmIChlLnZhbHVlKEFMUEhBKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBlLnZhbHVlKEFMUEhBKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKENPTE9SKSkge1xuICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogc3R5bGUub3BhY2l0eX07XG4gIH1cblxuICByZXR1cm4gcDtcbn1cblxuZnVuY3Rpb24gZmlsbGVkX3BvaW50X3Byb3BzKHNoYXBlKSB7XG4gIHJldHVybiBmdW5jdGlvbihlLCBsYXlvdXQsIHN0eWxlKSB7XG4gICAgdmFyIHAgPSB7fTtcblxuICAgIC8vIHhcbiAgICBpZiAoZS5oYXMoWCkpIHtcbiAgICAgIHAueCA9IHtzY2FsZTogWCwgZmllbGQ6IGUuZmllbGQoWCl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGUuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKSAvIDJ9O1xuICAgIH1cblxuICAgIC8vIHlcbiAgICBpZiAoZS5oYXMoWSkpIHtcbiAgICAgIHAueSA9IHtzY2FsZTogWSwgZmllbGQ6IGUuZmllbGQoWSl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFkpKSB7XG4gICAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICAgIH1cblxuICAgIC8vIHNpemVcbiAgICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICAgIHAuc2l6ZSA9IHtzY2FsZTogU0laRSwgZmllbGQ6IGUuZmllbGQoU0laRSl9O1xuICAgIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgICBwLnNpemUgPSB7dmFsdWU6IGUudmFsdWUoU0laRSl9O1xuICAgIH1cblxuICAgIC8vIHNoYXBlXG4gICAgcC5zaGFwZSA9IHt2YWx1ZTogc2hhcGV9O1xuXG4gICAgLy8gZmlsbFxuICAgIGlmIChlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAuZmlsbCA9IHtzY2FsZTogQ09MT1IsIGZpZWxkOiBlLmZpZWxkKENPTE9SKX07XG4gICAgfSBlbHNlIGlmICghZS5oYXMoQ09MT1IpKSB7XG4gICAgICBwLmZpbGwgPSB7dmFsdWU6IGUudmFsdWUoQ09MT1IpfTtcbiAgICB9XG5cbiAgICAvLyBhbHBoYVxuICAgIGlmIChlLmhhcyhBTFBIQSkpIHtcbiAgICAgIHAub3BhY2l0eSA9IHtzY2FsZTogQUxQSEEsIGZpZWxkOiBlLmZpZWxkKEFMUEhBKX07XG4gICAgfSBlbHNlIGlmIChlLnZhbHVlKEFMUEhBKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBwLm9wYWNpdHkgPSB7dmFsdWU6IGUudmFsdWUoQUxQSEEpfTtcbiAgICB9IGVsc2UgaWYgKCFlLmhhcyhDT0xPUikpIHtcbiAgICAgIHAub3BhY2l0eSA9IHt2YWx1ZTogc3R5bGUub3BhY2l0eX07XG4gICAgfVxuXG4gICAgcmV0dXJuIHA7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHRleHRfcHJvcHMoZSwgbGF5b3V0LCBzdHlsZSkge1xuICB2YXIgcCA9IHt9O1xuXG4gIC8vIHhcbiAgaWYgKGUuaGFzKFgpKSB7XG4gICAgcC54ID0ge3NjYWxlOiBYLCBmaWVsZDogZS5maWVsZChYKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFgpKSB7XG4gICAgaWYgKGUuaGFzKFRFWFQpICYmIGUuaXNUeXBlKFRFWFQsIFEpKSB7XG4gICAgICBwLnggPSB7dmFsdWU6IGxheW91dC5jZWxsV2lkdGgtNX07XG4gICAgfSBlbHNlIHtcbiAgICAgIHAueCA9IHt2YWx1ZTogZS5iYW5kU2l6ZShYLCBsYXlvdXQueC51c2VTbWFsbEJhbmQpIC8gMn07XG4gICAgfVxuICB9XG5cbiAgLy8geVxuICBpZiAoZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7c2NhbGU6IFksIGZpZWxkOiBlLmZpZWxkKFkpfTtcbiAgfSBlbHNlIGlmICghZS5oYXMoWSkpIHtcbiAgICBwLnkgPSB7dmFsdWU6IGUuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKSAvIDJ9O1xuICB9XG5cbiAgLy8gc2l6ZVxuICBpZiAoZS5oYXMoU0laRSkpIHtcbiAgICBwLmZvbnRTaXplID0ge3NjYWxlOiBTSVpFLCBmaWVsZDogZS5maWVsZChTSVpFKX07XG4gIH0gZWxzZSBpZiAoIWUuaGFzKFNJWkUpKSB7XG4gICAgcC5mb250U2l6ZSA9IHt2YWx1ZTogZS5mb250KCdzaXplJyl9O1xuICB9XG5cbiAgLy8gZmlsbFxuICAvLyBjb2xvciBzaG91bGQgYmUgc2V0IHRvIGJhY2tncm91bmRcbiAgcC5maWxsID0ge3ZhbHVlOiAnYmxhY2snfTtcblxuICAvLyBhbHBoYVxuICBpZiAoZS5oYXMoQUxQSEEpKSB7XG4gICAgcC5vcGFjaXR5ID0ge3NjYWxlOiBBTFBIQSwgZmllbGQ6IGUuZmllbGQoQUxQSEEpfTtcbiAgfSBlbHNlIGlmIChlLnZhbHVlKEFMUEhBKSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBlLnZhbHVlKEFMUEhBKX07XG4gIH0gZWxzZSB7XG4gICAgcC5vcGFjaXR5ID0ge3ZhbHVlOiBzdHlsZS5vcGFjaXR5fTtcbiAgfVxuXG4gIC8vIHRleHRcbiAgaWYgKGUuaGFzKFRFWFQpKSB7XG4gICAgaWYgKGUuaXNUeXBlKFRFWFQsIFEpKSB7XG4gICAgICBwLnRleHQgPSB7dGVtcGxhdGU6IFwie3tcIiArIGUuZmllbGQoVEVYVCkgKyBcIiB8IG51bWJlcjonLjNzJ319XCJ9O1xuICAgICAgcC5hbGlnbiA9IHt2YWx1ZTogJ3JpZ2h0J307XG4gICAgfSBlbHNlIHtcbiAgICAgIHAudGV4dCA9IHtmaWVsZDogZS5maWVsZChURVhUKX07XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHAudGV4dCA9IHt2YWx1ZTogJ0FiYyd9O1xuICB9XG5cbiAgcC5mb250ID0ge3ZhbHVlOiBlLmZvbnQoJ2ZhbWlseScpfTtcbiAgcC5mb250V2VpZ2h0ID0ge3ZhbHVlOiBlLmZvbnQoJ3dlaWdodCcpfTtcbiAgcC5mb250U3R5bGUgPSB7dmFsdWU6IGUuZm9udCgnc3R5bGUnKX07XG4gIHAuYmFzZWxpbmUgPSB7dmFsdWU6IGUudGV4dCgnYmFzZWxpbmUnKX07XG5cbiAgcmV0dXJuIHA7XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICB0aW1lID0gcmVxdWlyZSgnLi90aW1lJyk7XG5cbnZhciBzY2FsZSA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnNjYWxlLm5hbWVzID0gZnVuY3Rpb24ocHJvcHMpIHtcbiAgcmV0dXJuIHV0aWwua2V5cyh1dGlsLmtleXMocHJvcHMpLnJlZHVjZShmdW5jdGlvbihhLCB4KSB7XG4gICAgaWYgKHByb3BzW3hdICYmIHByb3BzW3hdLnNjYWxlKSBhW3Byb3BzW3hdLnNjYWxlXSA9IDE7XG4gICAgcmV0dXJuIGE7XG4gIH0sIHt9KSk7XG59O1xuXG5zY2FsZS5kZWZzID0gZnVuY3Rpb24obmFtZXMsIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBzb3J0aW5nLCBvcHQpIHtcbiAgb3B0ID0gb3B0IHx8IHt9O1xuXG4gIHJldHVybiBuYW1lcy5yZWR1Y2UoZnVuY3Rpb24oYSwgbmFtZSkge1xuICAgIHZhciBzID0ge1xuICAgICAgbmFtZTogbmFtZSxcbiAgICAgIHR5cGU6IHNjYWxlLnR5cGUobmFtZSwgZW5jb2RpbmcpLFxuICAgICAgZG9tYWluOiBzY2FsZV9kb21haW4obmFtZSwgZW5jb2RpbmcsIHNvcnRpbmcsIG9wdClcbiAgICB9O1xuICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJyAmJiAhZW5jb2RpbmcuYmluKG5hbWUpICYmIGVuY29kaW5nLnNvcnQobmFtZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICBzLnNvcnQgPSB0cnVlO1xuICAgIH1cblxuICAgIHNjYWxlX3JhbmdlKHMsIGVuY29kaW5nLCBsYXlvdXQsIHN0eWxlLCBvcHQpO1xuXG4gICAgcmV0dXJuIChhLnB1c2gocyksIGEpO1xuICB9LCBbXSk7XG59O1xuXG5zY2FsZS50eXBlID0gZnVuY3Rpb24obmFtZSwgZW5jb2RpbmcpIHtcblxuICBzd2l0Y2ggKGVuY29kaW5nLnR5cGUobmFtZSkpIHtcbiAgICBjYXNlIE86IHJldHVybiAnb3JkaW5hbCc7XG4gICAgY2FzZSBUOlxuICAgICAgdmFyIGZuID0gZW5jb2RpbmcuZm4obmFtZSk7XG4gICAgICByZXR1cm4gKGZuICYmIHRpbWUuc2NhbGUudHlwZShmbiwgbmFtZSkpIHx8ICd0aW1lJztcbiAgICBjYXNlIFE6XG4gICAgICBpZiAoZW5jb2RpbmcuYmluKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiBuYW1lID09PSBDT0xPUiA/ICdsaW5lYXInIDogJ29yZGluYWwnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVuY29kaW5nLnNjYWxlKG5hbWUpLnR5cGU7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHNjYWxlX2RvbWFpbihuYW1lLCBlbmNvZGluZywgc29ydGluZywgb3B0KSB7XG4gIGlmIChlbmNvZGluZy5pc1R5cGUobmFtZSwgVCkpIHtcbiAgICB2YXIgcmFuZ2UgPSB0aW1lLnNjYWxlLmRvbWFpbihlbmNvZGluZy5mbihuYW1lKSwgbmFtZSk7XG4gICAgaWYocmFuZ2UpIHJldHVybiByYW5nZTtcbiAgfVxuXG4gIGlmIChlbmNvZGluZy5iaW4obmFtZSkpIHtcbiAgICAvLyBUT0RPOiBhZGQgaW5jbHVkZUVtcHR5Q29uZmlnIGhlcmVcbiAgICBpZiAob3B0LnN0YXRzKSB7XG4gICAgICB2YXIgYmlucyA9IHV0aWwuZ2V0YmlucyhvcHQuc3RhdHNbZW5jb2RpbmcuZmllbGROYW1lKG5hbWUpXSwgZW5jb2RpbmcuYmluKG5hbWUpLm1heGJpbnMpO1xuICAgICAgdmFyIGRvbWFpbiA9IHV0aWwucmFuZ2UoYmlucy5zdGFydCwgYmlucy5zdG9wLCBiaW5zLnN0ZXApO1xuICAgICAgcmV0dXJuIG5hbWUgPT09IFkgPyBkb21haW4ucmV2ZXJzZSgpIDogZG9tYWluO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuYW1lID09IG9wdC5zdGFjayA/XG4gICAge1xuICAgICAgZGF0YTogU1RBQ0tFRCxcbiAgICAgIGZpZWxkOiAnZGF0YS4nICsgKG9wdC5mYWNldCA/ICdtYXhfJyA6ICcnKSArICdzdW1fJyArIGVuY29kaW5nLmZpZWxkKG5hbWUsIHRydWUpXG4gICAgfSA6XG4gICAge2RhdGE6IHNvcnRpbmcuZ2V0RGF0YXNldChuYW1lKSwgZmllbGQ6IGVuY29kaW5nLmZpZWxkKG5hbWUpfTtcbn1cblxuZnVuY3Rpb24gc2NhbGVfcmFuZ2UocywgZW5jb2RpbmcsIGxheW91dCwgc3R5bGUsIG9wdCkge1xuICB2YXIgc3BlYyA9IGVuY29kaW5nLnNjYWxlKHMubmFtZSk7XG4gIHN3aXRjaCAocy5uYW1lKSB7XG4gICAgY2FzZSBYOlxuICAgICAgaWYgKHMudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgIHMuYmFuZFdpZHRoID0gZW5jb2RpbmcuYmFuZFNpemUoWCwgbGF5b3V0LngudXNlU21hbGxCYW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMucmFuZ2UgPSBsYXlvdXQuY2VsbFdpZHRoID8gWzAsIGxheW91dC5jZWxsV2lkdGhdIDogJ3dpZHRoJztcblxuICAgICAgICBpZiAoZW5jb2RpbmcuaXNUeXBlKHMubmFtZSxUKSAmJiBlbmNvZGluZy5mbihzLm5hbWUpID09PSAneWVhcicpIHtcbiAgICAgICAgICBzLnplcm8gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzLnplcm8gPSBzcGVjLnplcm8gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBzcGVjLnplcm87XG4gICAgICAgIH1cblxuICAgICAgICBzLnJldmVyc2UgPSBzcGVjLnJldmVyc2U7XG4gICAgICB9XG4gICAgICBzLnJvdW5kID0gdHJ1ZTtcbiAgICAgIGlmIChzLnR5cGUgPT09ICd0aW1lJykge1xuICAgICAgICBzLm5pY2UgPSBlbmNvZGluZy5mbihzLm5hbWUpO1xuICAgICAgfWVsc2Uge1xuICAgICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgY2FzZSBZOlxuICAgICAgaWYgKHMudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgIHMuYmFuZFdpZHRoID0gZW5jb2RpbmcuYmFuZFNpemUoWSwgbGF5b3V0LnkudXNlU21hbGxCYW5kKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMucmFuZ2UgPSBsYXlvdXQuY2VsbEhlaWdodCA/IFtsYXlvdXQuY2VsbEhlaWdodCwgMF0gOiAnaGVpZ2h0JztcblxuICAgICAgICBpZiAoZW5jb2RpbmcuaXNUeXBlKHMubmFtZSxUKSAmJiBlbmNvZGluZy5mbihzLm5hbWUpID09PSAneWVhcicpIHtcbiAgICAgICAgICBzLnplcm8gPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzLnplcm8gPSBzcGVjLnplcm8gPT09IHVuZGVmaW5lZCA/IHRydWUgOiBzcGVjLnplcm87XG4gICAgICAgIH1cblxuICAgICAgICBzLnJldmVyc2UgPSBzcGVjLnJldmVyc2U7XG4gICAgICB9XG5cbiAgICAgIHMucm91bmQgPSB0cnVlO1xuXG4gICAgICBpZiAocy50eXBlID09PSAndGltZScpIHtcbiAgICAgICAgcy5uaWNlID0gZW5jb2RpbmcuZm4ocy5uYW1lKSB8fCBlbmNvZGluZy5jb25maWcoJ3RpbWVTY2FsZU5pY2UnKTtcbiAgICAgIH1lbHNlIHtcbiAgICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgUk9XOiAvLyBzdXBwb3J0IG9ubHkgb3JkaW5hbFxuICAgICAgcy5iYW5kV2lkdGggPSBsYXlvdXQuY2VsbEhlaWdodDtcbiAgICAgIHMucm91bmQgPSB0cnVlO1xuICAgICAgcy5uaWNlID0gdHJ1ZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQ09MOiAvLyBzdXBwb3J0IG9ubHkgb3JkaW5hbFxuICAgICAgcy5iYW5kV2lkdGggPSBsYXlvdXQuY2VsbFdpZHRoO1xuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBzLm5pY2UgPSB0cnVlO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBTSVpFOlxuICAgICAgaWYgKGVuY29kaW5nLmlzKCdiYXInKSkge1xuICAgICAgICAvLyBGSVhNRSB0aGlzIGlzIGRlZmluaXRlbHkgaW5jb3JyZWN0XG4gICAgICAgIC8vIGJ1dCBsZXQncyBmaXggaXQgbGF0ZXIgc2luY2UgYmFyIHNpemUgaXMgYSBiYWQgZW5jb2RpbmcgYW55d2F5XG4gICAgICAgIHMucmFuZ2UgPSBbMywgTWF0aC5tYXgoZW5jb2RpbmcuYmFuZFNpemUoWCksIGVuY29kaW5nLmJhbmRTaXplKFkpKV07XG4gICAgICB9IGVsc2UgaWYgKGVuY29kaW5nLmlzKFRFWFQpKSB7XG4gICAgICAgIHMucmFuZ2UgPSBbOCwgNDBdO1xuICAgICAgfSBlbHNlIHsgLy9wb2ludFxuICAgICAgICB2YXIgYmFuZFNpemUgPSBNYXRoLm1pbihlbmNvZGluZy5iYW5kU2l6ZShYKSwgZW5jb2RpbmcuYmFuZFNpemUoWSkpIC0gMTtcbiAgICAgICAgcy5yYW5nZSA9IFsxMCwgMC44ICogYmFuZFNpemUqYmFuZFNpemVdO1xuICAgICAgfVxuICAgICAgcy5yb3VuZCA9IHRydWU7XG4gICAgICBzLnplcm8gPSBmYWxzZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgU0hBUEU6XG4gICAgICBzLnJhbmdlID0gJ3NoYXBlcyc7XG4gICAgICBicmVhaztcbiAgICBjYXNlIENPTE9SOlxuICAgICAgdmFyIHJhbmdlID0gZW5jb2Rpbmcuc2NhbGUoQ09MT1IpLnJhbmdlO1xuICAgICAgaWYgKHJhbmdlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHMudHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgICAgLy8gRklYTUVcbiAgICAgICAgICByYW5nZSA9IHN0eWxlLmNvbG9yUmFuZ2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmFuZ2UgPSBbJyNBOURCOUYnLCAnIzBENUMyMSddO1xuICAgICAgICAgIHMuemVybyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzLnJhbmdlID0gcmFuZ2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlIEFMUEhBOlxuICAgICAgcy5yYW5nZSA9IFswLjIsIDEuMF07XG4gICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGVuY29kaW5nIG5hbWU6ICcrIHMubmFtZSk7XG4gIH1cblxuICBzd2l0Y2ggKHMubmFtZSkge1xuICAgIGNhc2UgUk9XOlxuICAgIGNhc2UgQ09MOlxuICAgICAgcy5wYWRkaW5nID0gZW5jb2RpbmcuY29uZmlnKCdjZWxsUGFkZGluZycpO1xuICAgICAgcy5vdXRlclBhZGRpbmcgPSAwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSBYOlxuICAgIGNhc2UgWTpcbiAgICAgIGlmIChzLnR5cGUgPT09ICdvcmRpbmFsJykgeyAvLyYmICFzLmJhbmRXaWR0aFxuICAgICAgICBzLnBvaW50cyA9IHRydWU7XG4gICAgICAgIHMucGFkZGluZyA9IGVuY29kaW5nLmJhbmQocy5uYW1lKS5wYWRkaW5nO1xuICAgICAgfVxuICB9XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFkZFNvcnRUcmFuc2Zvcm1zO1xuXG4vLyBhZGRzIG5ldyB0cmFuc2Zvcm1zIHRoYXQgcHJvZHVjZSBzb3J0ZWQgZmllbGRzXG5mdW5jdGlvbiBhZGRTb3J0VHJhbnNmb3JtcyhzcGVjLCBlbmNvZGluZywgc3RhdHMsIG9wdCkge1xuICB2YXIgZGF0YXNldE1hcHBpbmcgPSB7fTtcbiAgdmFyIGNvdW50ZXIgPSAwO1xuXG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgc29ydEJ5ID0gZW5jb2Rpbmcuc29ydChlbmNUeXBlLCBzdGF0cyk7XG4gICAgaWYgKHNvcnRCeS5sZW5ndGggPiAwKSB7XG4gICAgICB2YXIgZmllbGRzID0gc29ydEJ5Lm1hcChmdW5jdGlvbihkKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgb3A6IGQuYWdncixcbiAgICAgICAgICBmaWVsZDogJ2RhdGEuJyArIGQubmFtZVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBieUNsYXVzZSA9IHNvcnRCeS5tYXAoZnVuY3Rpb24oZCkge1xuICAgICAgICB2YXIgcmV2ZXJzZSA9IChkLnJldmVyc2UgPyAnLScgOiAnJyk7XG4gICAgICAgIHJldHVybiByZXZlcnNlICsgJ2RhdGEuJyArIChkLmFnZ3I9PT0nY291bnQnID8gJ2NvdW50JyA6IChkLmFnZ3IgKyAnXycgKyBkLm5hbWUpKTtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgZGF0YU5hbWUgPSAnc29ydGVkJyArIGNvdW50ZXIrKztcblxuICAgICAgdmFyIHRyYW5zZm9ybXMgPSBbXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnYWdncmVnYXRlJyxcbiAgICAgICAgICBncm91cGJ5OiBbJ2RhdGEuJyArIGZpZWxkLm5hbWVdLFxuICAgICAgICAgIGZpZWxkczogZmllbGRzXG4gICAgICAgIH0sXG4gICAgICAgIHtcbiAgICAgICAgICB0eXBlOiAnc29ydCcsXG4gICAgICAgICAgYnk6IGJ5Q2xhdXNlXG4gICAgICAgIH1cbiAgICAgIF07XG5cbiAgICAgIHNwZWMuZGF0YS5wdXNoKHtcbiAgICAgICAgbmFtZTogZGF0YU5hbWUsXG4gICAgICAgIHNvdXJjZTogUkFXLFxuICAgICAgICB0cmFuc2Zvcm06IHRyYW5zZm9ybXNcbiAgICAgIH0pO1xuXG4gICAgICBkYXRhc2V0TWFwcGluZ1tlbmNUeXBlXSA9IGRhdGFOYW1lO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICBzcGVjOiBzcGVjLFxuICAgIGdldERhdGFzZXQ6IGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICAgIHZhciBkYXRhID0gZGF0YXNldE1hcHBpbmdbZW5jVHlwZV07XG4gICAgICBpZiAoIWRhdGEpIHtcbiAgICAgICAgcmV0dXJuIFRBQkxFO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9O1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpLFxuICBtYXJrcyA9IHJlcXVpcmUoJy4vbWFya3MnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBzdGFja2luZztcblxuZnVuY3Rpb24gc3RhY2tpbmcoc3BlYywgZW5jb2RpbmcsIG1kZWYsIGZhY2V0cykge1xuICBpZiAoIW1hcmtzW2VuY29kaW5nLm1hcmt0eXBlKCldLnN0YWNrKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gVE9ETzogYWRkIHx8IGVuY29kaW5nLmhhcyhMT0QpIGhlcmUgb25jZSBMT0QgaXMgaW1wbGVtZW50ZWRcbiAgaWYgKCFlbmNvZGluZy5oYXMoQ09MT1IpKSByZXR1cm4gZmFsc2U7XG5cbiAgdmFyIGRpbT1udWxsLCB2YWw9bnVsbCwgaWR4ID1udWxsLFxuICAgIGlzWE1lYXN1cmUgPSBlbmNvZGluZy5pc01lYXN1cmUoWCksXG4gICAgaXNZTWVhc3VyZSA9IGVuY29kaW5nLmlzTWVhc3VyZShZKTtcblxuICBpZiAoaXNYTWVhc3VyZSAmJiAhaXNZTWVhc3VyZSkge1xuICAgIGRpbSA9IFk7XG4gICAgdmFsID0gWDtcbiAgICBpZHggPSAwO1xuICB9IGVsc2UgaWYgKGlzWU1lYXN1cmUgJiYgIWlzWE1lYXN1cmUpIHtcbiAgICBkaW0gPSBYO1xuICAgIHZhbCA9IFk7XG4gICAgaWR4ID0gMTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbnVsbDsgLy8gbm8gc3RhY2sgZW5jb2RpbmdcbiAgfVxuXG4gIC8vIGFkZCB0cmFuc2Zvcm0gdG8gY29tcHV0ZSBzdW1zIGZvciBzY2FsZVxuICB2YXIgc3RhY2tlZCA9IHtcbiAgICBuYW1lOiBTVEFDS0VELFxuICAgIHNvdXJjZTogVEFCTEUsXG4gICAgdHJhbnNmb3JtOiBbe1xuICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICBncm91cGJ5OiBbZW5jb2RpbmcuZmllbGQoZGltKV0uY29uY2F0KGZhY2V0cyksIC8vIGRpbSBhbmQgb3RoZXIgZmFjZXRzXG4gICAgICBmaWVsZHM6IFt7b3A6ICdzdW0nLCBmaWVsZDogZW5jb2RpbmcuZmllbGQodmFsKX1dIC8vIFRPRE8gY2hlY2sgaWYgZmllbGQgd2l0aCBhZ2dyIGlzIGNvcnJlY3Q/XG4gICAgfV1cbiAgfTtcblxuICBpZiAoZmFjZXRzICYmIGZhY2V0cy5sZW5ndGggPiAwKSB7XG4gICAgc3RhY2tlZC50cmFuc2Zvcm0ucHVzaCh7IC8vY2FsY3VsYXRlIG1heCBmb3IgZWFjaCBmYWNldFxuICAgICAgdHlwZTogJ2FnZ3JlZ2F0ZScsXG4gICAgICBncm91cGJ5OiBmYWNldHMsXG4gICAgICBmaWVsZHM6IFt7b3A6ICdtYXgnLCBmaWVsZDogJ2RhdGEuc3VtXycgKyBlbmNvZGluZy5maWVsZCh2YWwsIHRydWUpfV1cbiAgICB9KTtcbiAgfVxuXG4gIHNwZWMuZGF0YS5wdXNoKHN0YWNrZWQpO1xuXG4gIC8vIGFkZCBzdGFjayB0cmFuc2Zvcm0gdG8gbWFya1xuICBtZGVmLmZyb20udHJhbnNmb3JtID0gW3tcbiAgICB0eXBlOiAnc3RhY2snLFxuICAgIHBvaW50OiBlbmNvZGluZy5maWVsZChkaW0pLFxuICAgIGhlaWdodDogZW5jb2RpbmcuZmllbGQodmFsKSxcbiAgICBvdXRwdXQ6IHt5MTogdmFsLCB5MDogdmFsICsgJzInfVxuICB9XTtcblxuICAvLyBUT0RPOiBUaGlzIGlzIHN1cGVyIGhhY2staXNoIC0tIGNvbnNvbGlkYXRlIGludG8gbW9kdWxhciBtYXJrIHByb3BlcnRpZXM/XG4gIG1kZWYucHJvcGVydGllcy51cGRhdGVbdmFsXSA9IG1kZWYucHJvcGVydGllcy5lbnRlclt2YWxdID0ge3NjYWxlOiB2YWwsIGZpZWxkOiB2YWx9O1xuICBtZGVmLnByb3BlcnRpZXMudXBkYXRlW3ZhbCArICcyJ10gPSBtZGVmLnByb3BlcnRpZXMuZW50ZXJbdmFsICsgJzInXSA9IHtzY2FsZTogdmFsLCBmaWVsZDogdmFsICsgJzInfTtcblxuICByZXR1cm4gdmFsOyAvL3JldHVybiBzdGFjayBlbmNvZGluZ1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgdmxmaWVsZCA9IHJlcXVpcmUoJy4uL2ZpZWxkJyksXG4gIEVuY29kaW5nID0gcmVxdWlyZSgnLi4vRW5jb2RpbmcnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihlbmNvZGluZywgc3RhdHMpIHtcbiAgcmV0dXJuIHtcbiAgICBvcGFjaXR5OiBlc3RpbWF0ZU9wYWNpdHkoZW5jb2RpbmcsIHN0YXRzKSxcbiAgICBjb2xvclJhbmdlOiBjb2xvclJhbmdlKGVuY29kaW5nLCBzdGF0cylcbiAgfTtcbn07XG5cbmZ1bmN0aW9uIGNvbG9yUmFuZ2UoZW5jb2RpbmcsIHN0YXRzKXtcbiAgaWYgKGVuY29kaW5nLmhhcyhDT0xPUikgJiYgZW5jb2RpbmcuaXNEaW1lbnNpb24oQ09MT1IpKSB7XG4gICAgdmFyIGNhcmRpbmFsaXR5ID0gZW5jb2RpbmcuY2FyZGluYWxpdHkoQ09MT1IsIHN0YXRzKTtcbiAgICBpZiAoY2FyZGluYWxpdHkgPD0gMTApIHtcbiAgICAgIHJldHVybiBcImNhdGVnb3J5MTBcIjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIFwiY2F0ZWdvcnkyMFwiO1xuICAgIH1cbiAgICAvLyBUT0RPIGNhbiB2ZWdhIGludGVycG9sYXRlIHJhbmdlIGZvciBvcmRpbmFsIHNjYWxlP1xuICB9XG4gIHJldHVybiBudWxsO1xufVxuXG5mdW5jdGlvbiBlc3RpbWF0ZU9wYWNpdHkoZW5jb2Rpbmcsc3RhdHMpIHtcbiAgaWYgKCFzdGF0cykge1xuICAgIHJldHVybiAxO1xuICB9XG5cbiAgdmFyIG51bVBvaW50cyA9IDA7XG5cbiAgaWYgKGVuY29kaW5nLmlzQWdncmVnYXRlKCkpIHsgLy8gYWdncmVnYXRlIHBsb3RcbiAgICBudW1Qb2ludHMgPSAxO1xuXG4gICAgLy8gIGdldCBudW1iZXIgb2YgcG9pbnRzIGluIGVhY2ggXCJjZWxsXCJcbiAgICAvLyAgYnkgY2FsY3VsYXRpbmcgcHJvZHVjdCBvZiBjYXJkaW5hbGl0eVxuICAgIC8vICBmb3IgZWFjaCBub24gZmFjZXRpbmcgYW5kIG5vbi1vcmRpbmFsIFggLyBZIGZpZWxkc1xuICAgIC8vICBub3RlIHRoYXQgb3JkaW5hbCB4LHkgYXJlIG5vdCBpbmNsdWRlIHNpbmNlIHdlIGNhblxuICAgIC8vICBjb25zaWRlciB0aGF0IG9yZGluYWwgeCBhcmUgc3ViZGl2aWRpbmcgdGhlIGNlbGwgaW50byBzdWJjZWxscyBhbnl3YXlcbiAgICBlbmNvZGluZy5mb3JFYWNoKGZ1bmN0aW9uKGZpZWxkLCBlbmNUeXBlKSB7XG5cbiAgICAgIGlmIChlbmNUeXBlICE9PSBST1cgJiYgZW5jVHlwZSAhPT0gQ09MICYmXG4gICAgICAgICAgISgoZW5jVHlwZSA9PT0gWCB8fCBlbmNUeXBlID09PSBZKSAmJlxuICAgICAgICAgIHZsZmllbGQuaXNPcmRpbmFsU2NhbGUoZmllbGQsIHRydWUpKVxuICAgICAgICApIHtcbiAgICAgICAgbnVtUG9pbnRzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KGVuY1R5cGUsIHN0YXRzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICB9IGVsc2UgeyAvLyByYXcgcGxvdFxuICAgIG51bVBvaW50cyA9IHN0YXRzLmNvdW50O1xuXG4gICAgLy8gc21hbGwgbXVsdGlwbGVzIGRpdmlkZSBudW1iZXIgb2YgcG9pbnRzXG4gICAgdmFyIG51bU11bHRpcGxlcyA9IDE7XG4gICAgaWYgKGVuY29kaW5nLmhhcyhST1cpKSB7XG4gICAgICBudW1NdWx0aXBsZXMgKj0gZW5jb2RpbmcuY2FyZGluYWxpdHkoUk9XLCBzdGF0cyk7XG4gICAgfVxuICAgIGlmIChlbmNvZGluZy5oYXMoQ09MKSkge1xuICAgICAgbnVtTXVsdGlwbGVzICo9IGVuY29kaW5nLmNhcmRpbmFsaXR5KENPTCwgc3RhdHMpO1xuICAgIH1cbiAgICBudW1Qb2ludHMgLz0gbnVtTXVsdGlwbGVzO1xuICB9XG5cbiAgdmFyIG9wYWNpdHkgPSAwO1xuICBpZiAobnVtUG9pbnRzIDwgMjApIHtcbiAgICBvcGFjaXR5ID0gMTtcbiAgfSBlbHNlIGlmIChudW1Qb2ludHMgPCAyMDApIHtcbiAgICBvcGFjaXR5ID0gMC43O1xuICB9IGVsc2UgaWYgKG51bVBvaW50cyA8IDEwMDAgfHwgZW5jb2RpbmcuaXMoJ3RpY2snKSkge1xuICAgIG9wYWNpdHkgPSAwLjY7XG4gIH0gZWxzZSB7XG4gICAgb3BhY2l0eSA9IDAuMztcbiAgfVxuXG4gIHJldHVybiBvcGFjaXR5O1xufVxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWwgPSByZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciBncm91cGRlZiA9IHJlcXVpcmUoJy4vZ3JvdXAnKS5kZWY7XG5cbm1vZHVsZS5leHBvcnRzID0gc3ViZmFjZXRpbmc7XG5cbmZ1bmN0aW9uIHN1YmZhY2V0aW5nKGdyb3VwLCBtZGVmLCBkZXRhaWxzLCBzdGFjaywgZW5jb2RpbmcpIHtcbiAgdmFyIG0gPSBncm91cC5tYXJrcyxcbiAgICBnID0gZ3JvdXBkZWYoJ3N1YmZhY2V0Jywge21hcmtzOiBtfSk7XG5cbiAgZ3JvdXAubWFya3MgPSBbZ107XG4gIGcuZnJvbSA9IG1kZWYuZnJvbTtcbiAgZGVsZXRlIG1kZWYuZnJvbTtcblxuICAvL1RPRE8gdGVzdCBMT0QgLS0gd2Ugc2hvdWxkIHN1cHBvcnQgc3RhY2sgLyBsaW5lIHdpdGhvdXQgY29sb3IgKExPRCkgZmllbGRcbiAgdmFyIHRyYW5zID0gKGcuZnJvbS50cmFuc2Zvcm0gfHwgKGcuZnJvbS50cmFuc2Zvcm0gPSBbXSkpO1xuICB0cmFucy51bnNoaWZ0KHt0eXBlOiAnZmFjZXQnLCBrZXlzOiBkZXRhaWxzfSk7XG5cbiAgaWYgKHN0YWNrICYmIGVuY29kaW5nLmhhcyhDT0xPUikpIHtcbiAgICB0cmFucy51bnNoaWZ0KHt0eXBlOiAnc29ydCcsIGJ5OiBlbmNvZGluZy5maWVsZChDT0xPUil9KTtcbiAgfVxufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4uL2dsb2JhbHMnKTtcblxudmFyIGdyb3VwZGVmID0gcmVxdWlyZSgnLi9ncm91cCcpLmRlZixcbiAgdmxkYXRhID0gcmVxdWlyZSgnLi4vZGF0YScpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRlbXBsYXRlO1xuXG5mdW5jdGlvbiB0ZW1wbGF0ZShlbmNvZGluZywgbGF5b3V0LCBzdGF0cykgeyAvL2hhY2sgdXNlIHN0YXRzXG5cbiAgdmFyIGRhdGEgPSB7bmFtZTogUkFXLCBmb3JtYXQ6IHt0eXBlOiBlbmNvZGluZy5kYXRhKCdmb3JtYXRUeXBlJyl9fSxcbiAgICB0YWJsZSA9IHtuYW1lOiBUQUJMRSwgc291cmNlOiBSQVd9LFxuICAgIGRhdGFVcmwgPSB2bGRhdGEuZ2V0VXJsKGVuY29kaW5nLCBzdGF0cyk7XG4gIGlmIChkYXRhVXJsKSBkYXRhLnVybCA9IGRhdGFVcmw7XG5cbiAgdmFyIHByZWFnZ3JlZ2F0ZWREYXRhID0gISFlbmNvZGluZy5kYXRhKCd2ZWdhU2VydmVyJyk7XG5cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIHZhciBuYW1lO1xuICAgIGlmIChmaWVsZC50eXBlID09IFQpIHtcbiAgICAgIGRhdGEuZm9ybWF0LnBhcnNlID0gZGF0YS5mb3JtYXQucGFyc2UgfHwge307XG4gICAgICBkYXRhLmZvcm1hdC5wYXJzZVtmaWVsZC5uYW1lXSA9ICdkYXRlJztcbiAgICB9IGVsc2UgaWYgKGZpZWxkLnR5cGUgPT0gUSkge1xuICAgICAgZGF0YS5mb3JtYXQucGFyc2UgPSBkYXRhLmZvcm1hdC5wYXJzZSB8fCB7fTtcbiAgICAgIGlmIChmaWVsZC5hZ2dyID09PSAnY291bnQnKSB7XG4gICAgICAgIG5hbWUgPSAnY291bnQnO1xuICAgICAgfSBlbHNlIGlmIChwcmVhZ2dyZWdhdGVkRGF0YSAmJiBmaWVsZC5iaW4pIHtcbiAgICAgICAgbmFtZSA9ICdiaW5fJyArIGZpZWxkLm5hbWU7XG4gICAgICB9IGVsc2UgaWYgKHByZWFnZ3JlZ2F0ZWREYXRhICYmIGZpZWxkLmFnZ3IpIHtcbiAgICAgICAgbmFtZSA9IGZpZWxkLmFnZ3IgKyAnXycgKyBmaWVsZC5uYW1lO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmFtZSA9IGZpZWxkLm5hbWU7XG4gICAgICB9XG4gICAgICBkYXRhLmZvcm1hdC5wYXJzZVtuYW1lXSA9ICdudW1iZXInO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogbGF5b3V0LndpZHRoLFxuICAgIGhlaWdodDogbGF5b3V0LmhlaWdodCxcbiAgICBwYWRkaW5nOiAnYXV0bycsXG4gICAgZGF0YTogW2RhdGEsIHRhYmxlXSxcbiAgICBtYXJrczogW2dyb3VwZGVmKCdjZWxsJywge1xuICAgICAgd2lkdGg6IGxheW91dC5jZWxsV2lkdGggPyB7dmFsdWU6IGxheW91dC5jZWxsV2lkdGh9IDogdW5kZWZpbmVkLFxuICAgICAgaGVpZ2h0OiBsYXlvdXQuY2VsbEhlaWdodCA/IHt2YWx1ZTogbGF5b3V0LmNlbGxIZWlnaHR9IDogdW5kZWZpbmVkXG4gICAgfSldXG4gIH07XG59XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBnbG9iYWxzID0gcmVxdWlyZSgnLi4vZ2xvYmFscycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHRpbWU7XG5cbmZ1bmN0aW9uIHRpbWUoc3BlYywgZW5jb2RpbmcsIG9wdCkge1xuICB2YXIgdGltZUZpZWxkcyA9IHt9LCB0aW1lRm4gPSB7fTtcblxuICAvLyBmaW5kIHVuaXF1ZSBmb3JtdWxhIHRyYW5zZm9ybWF0aW9uIGFuZCBiaW4gZnVuY3Rpb25cbiAgZW5jb2RpbmcuZm9yRWFjaChmdW5jdGlvbihmaWVsZCwgZW5jVHlwZSkge1xuICAgIGlmIChmaWVsZC50eXBlID09PSBUICYmIGZpZWxkLmZuKSB7XG4gICAgICB0aW1lRmllbGRzW2VuY29kaW5nLmZpZWxkKGVuY1R5cGUpXSA9IHtcbiAgICAgICAgZmllbGQ6IGZpZWxkLFxuICAgICAgICBlbmNUeXBlOiBlbmNUeXBlXG4gICAgICB9O1xuICAgICAgdGltZUZuW2ZpZWxkLmZuXSA9IHRydWU7XG4gICAgfVxuICB9KTtcblxuICAvLyBhZGQgZm9ybXVsYSB0cmFuc2Zvcm1cbiAgdmFyIGRhdGEgPSBzcGVjLmRhdGFbMV0sXG4gICAgdHJhbnNmb3JtID0gZGF0YS50cmFuc2Zvcm0gPSBkYXRhLnRyYW5zZm9ybSB8fCBbXTtcblxuICBmb3IgKHZhciBmIGluIHRpbWVGaWVsZHMpIHtcbiAgICB2YXIgdGYgPSB0aW1lRmllbGRzW2ZdO1xuICAgIHRpbWUudHJhbnNmb3JtKHRyYW5zZm9ybSwgZW5jb2RpbmcsIHRmLmVuY1R5cGUsIHRmLmZpZWxkKTtcbiAgfVxuXG4gIC8vIGFkZCBzY2FsZXNcbiAgdmFyIHNjYWxlcyA9IHNwZWMuc2NhbGVzID0gc3BlYy5zY2FsZXMgfHwgW107XG4gIGZvciAodmFyIGZuIGluIHRpbWVGbikge1xuICAgIHRpbWUuc2NhbGUoc2NhbGVzLCBmbiwgZW5jb2RpbmcpO1xuICB9XG4gIHJldHVybiBzcGVjO1xufVxuXG50aW1lLmNhcmRpbmFsaXR5ID0gZnVuY3Rpb24oZmllbGQsIHN0YXRzLCBmaWx0ZXJOdWxsLCB0eXBlKSB7XG4gIHZhciBmbiA9IGZpZWxkLmZuO1xuICBzd2l0Y2ggKGZuKSB7XG4gICAgY2FzZSAnc2Vjb25kcyc6IHJldHVybiA2MDtcbiAgICBjYXNlICdtaW51dGVzJzogcmV0dXJuIDYwO1xuICAgIGNhc2UgJ2hvdXJzJzogcmV0dXJuIDI0O1xuICAgIGNhc2UgJ2RheSc6IHJldHVybiA3O1xuICAgIGNhc2UgJ2RhdGUnOiByZXR1cm4gMzE7XG4gICAgY2FzZSAnbW9udGgnOiByZXR1cm4gMTI7XG4gICAgY2FzZSAneWVhcic6XG4gICAgICB2YXIgc3RhdCA9IHN0YXRzW2ZpZWxkLm5hbWVdLFxuICAgICAgICB5ZWFyc3RhdCA9IHN0YXRzWyd5ZWFyXycrZmllbGQubmFtZV07XG5cbiAgICAgIGlmICgheWVhcnN0YXQpIHsgcmV0dXJuIG51bGw7IH1cblxuICAgICAgcmV0dXJuIHllYXJzdGF0LmNhcmRpbmFsaXR5IC1cbiAgICAgICAgKHN0YXQubnVtTnVsbHMgPiAwICYmIGZpbHRlck51bGxbdHlwZV0gPyAxIDogMCk7XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn07XG5cbmZ1bmN0aW9uIGZpZWxkRm4oZnVuYywgZmllbGQpIHtcbiAgcmV0dXJuICd1dGMnICsgZnVuYyArICcoZC5kYXRhLicrIGZpZWxkLm5hbWUgKycpJztcbn1cblxuLyoqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IGRhdGUgYmlubmluZyBmb3JtdWxhIG9mIHRoZSBnaXZlbiBmaWVsZFxuICovXG50aW1lLmZvcm11bGEgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gZmllbGRGbihmaWVsZC5mbiwgZmllbGQpO1xufTtcblxuLyoqIGFkZCBmb3JtdWxhIHRyYW5zZm9ybXMgdG8gZGF0YSAqL1xudGltZS50cmFuc2Zvcm0gPSBmdW5jdGlvbih0cmFuc2Zvcm0sIGVuY29kaW5nLCBlbmNUeXBlLCBmaWVsZCkge1xuICB0cmFuc2Zvcm0ucHVzaCh7XG4gICAgdHlwZTogJ2Zvcm11bGEnLFxuICAgIGZpZWxkOiBlbmNvZGluZy5maWVsZChlbmNUeXBlKSxcbiAgICBleHByOiB0aW1lLmZvcm11bGEoZmllbGQpXG4gIH0pO1xufTtcblxuLyoqIGFwcGVuZCBjdXN0b20gdGltZSBzY2FsZXMgZm9yIGF4aXMgbGFiZWwgKi9cbnRpbWUuc2NhbGUgPSBmdW5jdGlvbihzY2FsZXMsIGZuLCBlbmNvZGluZykge1xuICB2YXIgbGFiZWxMZW5ndGggPSBlbmNvZGluZy5jb25maWcoJ3RpbWVTY2FsZUxhYmVsTGVuZ3RoJyk7XG4gIC8vIFRPRE8gYWRkIG9wdGlvbiBmb3Igc2hvcnRlciBzY2FsZSAvIGN1c3RvbSByYW5nZVxuICBzd2l0Y2ggKGZuKSB7XG4gICAgY2FzZSAnZGF5JzpcbiAgICAgIHNjYWxlcy5wdXNoKHtcbiAgICAgICAgbmFtZTogJ3RpbWUtJytmbixcbiAgICAgICAgdHlwZTogJ29yZGluYWwnLFxuICAgICAgICBkb21haW46IHV0aWwucmFuZ2UoMCwgNyksXG4gICAgICAgIHJhbmdlOiBbJ01vbmRheScsICdUdWVzZGF5JywgJ1dlZG5lc2RheScsICdUaHVyc2RheScsICdGcmlkYXknLCAnU2F0dXJkYXknLCAnU3VuZGF5J10ubWFwKFxuICAgICAgICAgIGZ1bmN0aW9uKHMpIHsgcmV0dXJuIHMuc3Vic3RyKDAsIGxhYmVsTGVuZ3RoKTt9XG4gICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgc2NhbGVzLnB1c2goe1xuICAgICAgICBuYW1lOiAndGltZS0nK2ZuLFxuICAgICAgICB0eXBlOiAnb3JkaW5hbCcsXG4gICAgICAgIGRvbWFpbjogdXRpbC5yYW5nZSgwLCAxMiksXG4gICAgICAgIHJhbmdlOiBbJ0phbnVhcnknLCAnRmVicnVhcnknLCAnTWFyY2gnLCAnQXByaWwnLCAnTWF5JywgJ0p1bmUnLCAnSnVseScsICdBdWd1c3QnLCAnU2VwdGVtYmVyJywgJ09jdG9iZXInLCAnTm92ZW1iZXInLCAnRGVjZW1iZXInXS5tYXAoXG4gICAgICAgICAgICBmdW5jdGlvbihzKSB7IHJldHVybiBzLnN1YnN0cigwLCBsYWJlbExlbmd0aCk7fVxuICAgICAgICAgIClcbiAgICAgIH0pO1xuICAgICAgYnJlYWs7XG4gIH1cbn07XG5cbnRpbWUuaXNPcmRpbmFsRm4gPSBmdW5jdGlvbihmbikge1xuICBzd2l0Y2ggKGZuKSB7XG4gICAgY2FzZSAnc2Vjb25kcyc6XG4gICAgY2FzZSAnbWludXRlcyc6XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZGF0ZSc6XG4gICAgY2FzZSAnbW9udGgnOlxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudGltZS5zY2FsZS50eXBlID0gZnVuY3Rpb24oZm4sIG5hbWUpIHtcbiAgaWYgKG5hbWUgPT09IENPTE9SKSB7XG4gICAgcmV0dXJuICdsaW5lYXInOyAvLyB0aGlzIGhhcyBvcmRlclxuICB9XG5cbiAgcmV0dXJuIHRpbWUuaXNPcmRpbmFsRm4oZm4pIHx8IG5hbWUgPT09IENPTCB8fCBuYW1lID09PSBST1cgPyAnb3JkaW5hbCcgOiAnbGluZWFyJztcbn07XG5cbnRpbWUuc2NhbGUuZG9tYWluID0gZnVuY3Rpb24oZm4sIG5hbWUpIHtcbiAgdmFyIGlzQ29sb3IgPSBuYW1lID09PSBDT0xPUjtcbiAgc3dpdGNoIChmbikge1xuICAgIGNhc2UgJ3NlY29uZHMnOlxuICAgIGNhc2UgJ21pbnV0ZXMnOiByZXR1cm4gaXNDb2xvciA/IFswLDU5XSA6IHV0aWwucmFuZ2UoMCwgNjApO1xuICAgIGNhc2UgJ2hvdXJzJzogcmV0dXJuIGlzQ29sb3IgPyBbMCwyM10gOiB1dGlsLnJhbmdlKDAsIDI0KTtcbiAgICBjYXNlICdkYXknOiByZXR1cm4gaXNDb2xvciA/IFswLDZdIDogdXRpbC5yYW5nZSgwLCA3KTtcbiAgICBjYXNlICdkYXRlJzogcmV0dXJuIGlzQ29sb3IgPyBbMSwzMV0gOiB1dGlsLnJhbmdlKDEsIDMyKTtcbiAgICBjYXNlICdtb250aCc6IHJldHVybiBpc0NvbG9yID8gWzAsMTFdIDogdXRpbC5yYW5nZSgwLCAxMik7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59O1xuXG4vKiogd2hldGhlciBhIHBhcnRpY3VsYXIgdGltZSBmdW5jdGlvbiBoYXMgY3VzdG9tIHNjYWxlIGZvciBsYWJlbHMgaW1wbGVtZW50ZWQgaW4gdGltZS5zY2FsZSAqL1xudGltZS5oYXNTY2FsZSA9IGZ1bmN0aW9uKGZuKSB7XG4gIHN3aXRjaCAoZm4pIHtcbiAgICBjYXNlICdkYXknOlxuICAgIGNhc2UgJ21vbnRoJzpcbiAgICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHJldHVybiBmYWxzZTtcbn07XG5cblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZ2xvYmFscyA9IHJlcXVpcmUoJy4vZ2xvYmFscycpO1xuXG52YXIgY29uc3RzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuY29uc3RzLmVuY29kaW5nVHlwZXMgPSBbWCwgWSwgUk9XLCBDT0wsIFNJWkUsIFNIQVBFLCBDT0xPUiwgQUxQSEEsIFRFWFQsIERFVEFJTF07XG5cbmNvbnN0cy5kYXRhVHlwZXMgPSB7J08nOiBPLCAnUSc6IFEsICdUJzogVH07XG5cbmNvbnN0cy5kYXRhVHlwZU5hbWVzID0gWydPJywgJ1EnLCAnVCddLnJlZHVjZShmdW5jdGlvbihyLCB4KSB7XG4gIHJbY29uc3RzLmRhdGFUeXBlc1t4XV0gPSB4O1xuICByZXR1cm4gcjtcbn0se30pO1xuXG5jb25zdHMuc2hvcnRoYW5kID0ge1xuICBkZWxpbTogICd8JyxcbiAgYXNzaWduOiAnPScsXG4gIHR5cGU6ICAgJywnLFxuICBmdW5jOiAgICdfJ1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gVE9ETzogcmVuYW1lIGdldERhdGFVcmwgdG8gdmwuZGF0YS5nZXRVcmwoKSA/XG5cbnZhciB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyk7XG5cbnZhciB2bGRhdGEgPSBtb2R1bGUuZXhwb3J0cyA9IHt9LFxuICB2bGZpZWxkID0gcmVxdWlyZSgnLi9maWVsZCcpO1xuXG52bGRhdGEuZ2V0VXJsID0gZnVuY3Rpb24gZ2V0RGF0YVVybChlbmNvZGluZywgc3RhdHMpIHtcbiAgaWYgKCFlbmNvZGluZy5kYXRhKCd2ZWdhU2VydmVyJykpIHtcbiAgICAvLyBkb24ndCB1c2UgdmVnYSBzZXJ2ZXJcbiAgICByZXR1cm4gZW5jb2RpbmcuZGF0YSgndXJsJyk7XG4gIH1cblxuICBpZiAoZW5jb2RpbmcubGVuZ3RoKCkgPT09IDApIHtcbiAgICAvLyBubyBmaWVsZHNcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZmllbGRzID0gW107XG4gIGVuY29kaW5nLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgb2JqID0ge1xuICAgICAgbmFtZTogZW5jb2RpbmcuZmllbGQoZW5jVHlwZSwgdHJ1ZSksXG4gICAgICBmaWVsZDogZmllbGQubmFtZVxuICAgIH07XG4gICAgaWYgKGZpZWxkLmFnZ3IpIHtcbiAgICAgIG9iai5hZ2dyID0gZmllbGQuYWdncjtcbiAgICB9XG4gICAgaWYgKGZpZWxkLmJpbikge1xuICAgICAgb2JqLmJpblNpemUgPSB1dGlsLmdldGJpbnMoc3RhdHNbZmllbGQubmFtZV0sIGVuY29kaW5nLmJpbihlbmNUeXBlKS5tYXhiaW5zKS5zdGVwO1xuICAgIH1cbiAgICBmaWVsZHMucHVzaChvYmopO1xuICB9KTtcblxuICB2YXIgcXVlcnkgPSB7XG4gICAgdGFibGU6IGVuY29kaW5nLmRhdGEoJ3ZlZ2FTZXJ2ZXInKS50YWJsZSxcbiAgICBmaWVsZHM6IGZpZWxkc1xuICB9O1xuXG4gIHJldHVybiBlbmNvZGluZy5kYXRhKCd2ZWdhU2VydmVyJykudXJsICsgJy9xdWVyeS8/cT0nICsgSlNPTi5zdHJpbmdpZnkocXVlcnkpO1xufTtcblxuLyoqXG4gKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEgZGF0YSBpbiBKU09OL2phdmFzY3JpcHQgb2JqZWN0IGZvcm1hdFxuICogQHJldHVybiBBcnJheSBvZiB7bmFtZTogX19uYW1lX18sIHR5cGU6IFwibnVtYmVyfHRleHR8dGltZXxsb2NhdGlvblwifVxuICovXG52bGRhdGEuZ2V0U2NoZW1hID0gZnVuY3Rpb24oZGF0YSwgb3JkZXIpIHtcbiAgdmFyIHNjaGVtYSA9IFtdLFxuICAgIGZpZWxkcyA9IHV0aWwua2V5cyhkYXRhWzBdKTtcblxuICBmaWVsZHMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgLy8gZmluZCBub24tbnVsbCBkYXRhXG4gICAgdmFyIGkgPSAwLCBkYXR1bSA9IGRhdGFbaV1ba107XG4gICAgd2hpbGUgKGRhdHVtID09PSAnJyB8fCBkYXR1bSA9PT0gbnVsbCB8fCBkYXR1bSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBkYXR1bSA9IGRhdGFbKytpXVtrXTtcbiAgICAgIGlmIChpID49IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgIGRhdHVtID0gJyc7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGRhdHVtID0gdXRpbC5wYXJzZShkYXR1bSk7XG4gICAgdmFyIHR5cGUgPSAodHlwZW9mIGRhdHVtID09PSAnbnVtYmVyJykgPyAnUSc6XG4gICAgICAoZGF0dW0gaW5zdGFuY2VvZiBEYXRlKSA/ICdUJyA6ICdPJztcblxuICAgIHNjaGVtYS5wdXNoKHtuYW1lOiBrLCB0eXBlOiB0eXBlfSk7XG4gIH0pO1xuXG4gIHNjaGVtYSA9IHV0aWwuc3RhYmxlc29ydChzY2hlbWEsIG9yZGVyIHx8IHZsZmllbGQub3JkZXIudHlwZVRoZW5OYW1lLCB2bGZpZWxkLm9yZGVyLm5hbWUpO1xuXG4gIHJldHVybiBzY2hlbWE7XG59O1xuXG52bGRhdGEuZ2V0U3RhdHMgPSBmdW5jdGlvbihkYXRhKSB7IC8vIGhhY2tcbiAgdmFyIHN0YXRzID0ge30sXG4gICAgZmllbGRzID0gdXRpbC5rZXlzKGRhdGFbMF0pO1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICB2YXIgY29sdW1uID0gZGF0YS5tYXAoZnVuY3Rpb24oZCkge3JldHVybiBkW2tdO30pO1xuXG4gICAgLy8gSGFja1xuICAgIHZhciB2YWwgPSB1dGlsLnBhcnNlKGRhdGFbMF1ba10pO1xuICAgIHZhciB0eXBlID0gKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSA/ICdRJzpcbiAgICAgICh2YWwgaW5zdGFuY2VvZiBEYXRlKSA/ICdUJyA6ICdPJztcblxuICAgIHZhciBzdGF0ID0ge307XG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgICBzdGF0ID0gdXRpbC5taW5tYXgodXRpbC5udW1iZXJzKGNvbHVtbikpO1xuICAgIH0gZWxzZSBpZiAodmFsIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgICAgc3RhdCA9IHV0aWwubWlubWF4KHV0aWwuZGF0ZXMoY29sdW1uKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXQgPSB1dGlsLm1pbm1heChjb2x1bW4pO1xuICAgIH1cblxuICAgIHN0YXQuY2FyZGluYWxpdHkgPSB1dGlsLnVuaXEoZGF0YSwgayk7XG4gICAgc3RhdC5jb3VudCA9IGRhdGEubGVuZ3RoO1xuXG4gICAgc3RhdC5tYXhsZW5ndGggPSBkYXRhLnJlZHVjZShmdW5jdGlvbihtYXgscm93KSB7XG4gICAgICBpZiAocm93W2tdID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBtYXg7XG4gICAgICB9XG4gICAgICB2YXIgbGVuID0gcm93W2tdLnRvU3RyaW5nKCkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbiA+IG1heCA/IGxlbiA6IG1heDtcbiAgICB9LCAwKTtcblxuICAgIHN0YXQubnVtTnVsbHMgPSBkYXRhLnJlZHVjZShmdW5jdGlvbihjb3VudCwgcm93KSB7XG4gICAgICByZXR1cm4gcm93W2tdID09PSBudWxsID8gY291bnQgKyAxIDogY291bnQ7XG4gICAgfSwgMCk7XG5cbiAgICB2YXIgbnVtYmVycyA9IHV0aWwubnVtYmVycyhjb2x1bW4pO1xuXG4gICAgaWYgKG51bWJlcnMubGVuZ3RoID4gMCkge1xuICAgICAgc3RhdC5za2V3ID0gdXRpbC5za2V3KG51bWJlcnMpO1xuICAgICAgc3RhdC5zdGRldiA9IHV0aWwuc3RkZXYobnVtYmVycyk7XG4gICAgICBzdGF0Lm1lYW4gPSB1dGlsLm1lYW4obnVtYmVycyk7XG4gICAgICBzdGF0Lm1lZGlhbiA9IHV0aWwubWVkaWFuKG51bWJlcnMpO1xuICAgIH1cblxuICAgIHZhciBzYW1wbGUgPSB7fTtcbiAgICB3aGlsZShPYmplY3Qua2V5cyhzYW1wbGUpLmxlbmd0aCA8IE1hdGgubWluKHN0YXQuY2FyZGluYWxpdHksIDEwKSkge1xuICAgICAgdmFyIHZhbHVlID0gZGF0YVtNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBkYXRhLmxlbmd0aCldW2tdO1xuICAgICAgc2FtcGxlW3ZhbHVlXSA9IHRydWU7XG4gICAgfVxuICAgIHN0YXQuc2FtcGxlID0gT2JqZWN0LmtleXMoc2FtcGxlKTtcblxuICAgIHN0YXRzW2tdID0gc3RhdDtcbiAgfSk7XG4gIHN0YXRzLmNvdW50ID0gZGF0YS5sZW5ndGg7XG4gIHJldHVybiBzdGF0cztcbn07XG4iLCIvLyB1dGlsaXR5IGZvciBlbmNcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHRpbWUgPSByZXF1aXJlKCcuL2NvbXBpbGUvdGltZScpLFxuICB2bGZpZWxkID0gcmVxdWlyZSgnLi9maWVsZCcpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpLFxuICBlbmNUeXBlcyA9IHNjaGVtYS5lbmNUeXBlcztcblxudmFyIHZsZW5jID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudmxlbmMuY291bnRSZXRpbmFsID0gZnVuY3Rpb24oZW5jKSB7XG4gIHZhciBjb3VudCA9IDA7XG4gIGlmIChlbmMuY29sb3IpIGNvdW50Kys7XG4gIGlmIChlbmMuYWxwaGEpIGNvdW50Kys7XG4gIGlmIChlbmMuc2l6ZSkgY291bnQrKztcbiAgaWYgKGVuYy5zaGFwZSkgY291bnQrKztcbiAgcmV0dXJuIGNvdW50O1xufTtcblxudmxlbmMuaGFzID0gZnVuY3Rpb24oZW5jLCBlbmNUeXBlKSB7XG4gIHZhciBmaWVsZERlZiA9IGVuYyAmJiBlbmNbZW5jVHlwZV07XG4gIHJldHVybiBmaWVsZERlZiAmJiBmaWVsZERlZi5uYW1lO1xufTtcblxudmxlbmMuaXNBZ2dyZWdhdGUgPSBmdW5jdGlvbihlbmMpIHtcbiAgZm9yICh2YXIgayBpbiBlbmMpIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykgJiYgZW5jW2tdLmFnZ3IpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG52bGVuYy5mb3JFYWNoID0gZnVuY3Rpb24oZW5jLCBmKSB7XG4gIHZhciBpID0gMDtcbiAgZW5jVHlwZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspKSB7XG4gICAgICBmKGVuY1trXSwgaywgaSsrKTtcbiAgICB9XG4gIH0pO1xufTtcblxudmxlbmMubWFwID0gZnVuY3Rpb24oZW5jLCBmKSB7XG4gIHZhciBhcnIgPSBbXTtcbiAgZW5jVHlwZXMuZm9yRWFjaChmdW5jdGlvbihrKSB7XG4gICAgaWYgKHZsZW5jLmhhcyhlbmMsIGspKSB7XG4gICAgICBhcnIucHVzaChmKGVuY1trXSwgaywgZW5jKSk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGFycjtcbn07XG5cbnZsZW5jLnJlZHVjZSA9IGZ1bmN0aW9uKGVuYywgZiwgaW5pdCkge1xuICB2YXIgciA9IGluaXQsIGkgPSAwLCBrO1xuICBlbmNUeXBlcy5mb3JFYWNoKGZ1bmN0aW9uKGspIHtcbiAgICBpZiAodmxlbmMuaGFzKGVuYywgaykpIHtcbiAgICAgIHIgPSBmKHIsIGVuY1trXSwgaywgIGVuYyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIHI7XG59O1xuXG4vKlxuICogcmV0dXJuIGtleS12YWx1ZSBwYWlycyBvZiBmaWVsZCBuYW1lIGFuZCBsaXN0IG9mIGZpZWxkcyBvZiB0aGF0IGZpZWxkIG5hbWVcbiAqL1xudmxlbmMuZmllbGRzID0gZnVuY3Rpb24oZW5jKSB7XG4gIHJldHVybiB2bGVuYy5yZWR1Y2UoZW5jLCBmdW5jdGlvbiAobSwgZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIgZmllbGRMaXN0ID0gbVtmaWVsZC5uYW1lXSA9IG1bZmllbGQubmFtZV0gfHwgW10sXG4gICAgICBjb250YWluc1R5cGUgPSBmaWVsZExpc3QuY29udGFpbnNUeXBlID0gZmllbGRMaXN0LmNvbnRhaW5zVHlwZSB8fCB7fTtcblxuICAgIGlmIChmaWVsZExpc3QuaW5kZXhPZihmaWVsZCkgPT09IC0xKSB7XG4gICAgICBmaWVsZExpc3QucHVzaChmaWVsZCk7XG4gICAgICAvLyBhdWdtZW50IHRoZSBhcnJheSB3aXRoIGNvbnRhaW5zVHlwZS5RIC8gTyAvIFRcbiAgICAgIGNvbnRhaW5zVHlwZVtmaWVsZC50eXBlXSA9IHRydWU7XG4gICAgfVxuICAgIHJldHVybiBtO1xuICB9LCB7fSk7XG59O1xuXG52bGVuYy5zaG9ydGhhbmQgPSBmdW5jdGlvbihlbmMpIHtcbiAgcmV0dXJuIHZsZW5jLm1hcChlbmMsIGZ1bmN0aW9uKGZpZWxkLCBldCkge1xuICAgIHJldHVybiBldCArIGMuYXNzaWduICsgdmxmaWVsZC5zaG9ydGhhbmQoZmllbGQpO1xuICB9KS5qb2luKGMuZGVsaW0pO1xufTtcblxudmxlbmMuZnJvbVNob3J0aGFuZCA9IGZ1bmN0aW9uKHNob3J0aGFuZCwgY29udmVydFR5cGUpIHtcbiAgdmFyIGVuYyA9IHV0aWwuaXNBcnJheShzaG9ydGhhbmQpID8gc2hvcnRoYW5kIDogc2hvcnRoYW5kLnNwbGl0KGMuZGVsaW0pO1xuICByZXR1cm4gZW5jLnJlZHVjZShmdW5jdGlvbihtLCBlKSB7XG4gICAgdmFyIHNwbGl0ID0gZS5zcGxpdChjLmFzc2lnbiksXG4gICAgICAgIGVuY3R5cGUgPSBzcGxpdFswXS50cmltKCksXG4gICAgICAgIGZpZWxkID0gc3BsaXRbMV07XG5cbiAgICBtW2VuY3R5cGVdID0gdmxmaWVsZC5mcm9tU2hvcnRoYW5kKGZpZWxkLCBjb252ZXJ0VHlwZSk7XG4gICAgcmV0dXJuIG07XG4gIH0sIHt9KTtcbn07IiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyB1dGlsaXR5IGZvciBmaWVsZFxuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi9jb25zdHMnKSxcbiAgYyA9IGNvbnN0cy5zaG9ydGhhbmQsXG4gIHRpbWUgPSByZXF1aXJlKCcuL2NvbXBpbGUvdGltZScpLFxuICB1dGlsID0gcmVxdWlyZSgnLi91dGlsJyksXG4gIHNjaGVtYSA9IHJlcXVpcmUoJy4vc2NoZW1hL3NjaGVtYScpO1xuXG52YXIgdmxmaWVsZCA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbnZsZmllbGQuc2hvcnRoYW5kID0gZnVuY3Rpb24oZikge1xuICB2YXIgYyA9IGNvbnN0cy5zaG9ydGhhbmQ7XG4gIHJldHVybiAoZi5hZ2dyID8gZi5hZ2dyICsgYy5mdW5jIDogJycpICtcbiAgICAoZi5mbiA/IGYuZm4gKyBjLmZ1bmMgOiAnJykgK1xuICAgIChmLmJpbiA/ICdiaW4nICsgYy5mdW5jIDogJycpICtcbiAgICAoZi5uYW1lIHx8ICcnKSArIGMudHlwZSArXG4gICAgKGNvbnN0cy5kYXRhVHlwZU5hbWVzW2YudHlwZV0gfHwgZi50eXBlKTtcbn07XG5cbnZsZmllbGQuc2hvcnRoYW5kcyA9IGZ1bmN0aW9uKGZpZWxkcywgZGVsaW0pIHtcbiAgZGVsaW0gPSBkZWxpbSB8fCBjLmRlbGltO1xuICByZXR1cm4gZmllbGRzLm1hcCh2bGZpZWxkLnNob3J0aGFuZCkuam9pbihkZWxpbSk7XG59O1xuXG52bGZpZWxkLmZyb21TaG9ydGhhbmQgPSBmdW5jdGlvbihzaG9ydGhhbmQsIGNvbnZlcnRUeXBlKSB7XG4gIHZhciBzcGxpdCA9IHNob3J0aGFuZC5zcGxpdChjLnR5cGUpLCBpO1xuICB2YXIgbyA9IHtcbiAgICBuYW1lOiBzcGxpdFswXS50cmltKCksXG4gICAgdHlwZTogY29udmVydFR5cGUgPyBjb25zdHMuZGF0YVR5cGVzW3NwbGl0WzFdLnRyaW0oKV0gOiBzcGxpdFsxXS50cmltKClcbiAgfTtcblxuICAvLyBjaGVjayBhZ2dyZWdhdGUgdHlwZVxuICBmb3IgKGkgaW4gc2NoZW1hLmFnZ3IuZW51bSkge1xuICAgIHZhciBhID0gc2NoZW1hLmFnZ3IuZW51bVtpXTtcbiAgICBpZiAoby5uYW1lLmluZGV4T2YoYSArICdfJykgPT09IDApIHtcbiAgICAgIG8ubmFtZSA9IG8ubmFtZS5zdWJzdHIoYS5sZW5ndGggKyAxKTtcbiAgICAgIGlmIChhID09ICdjb3VudCcgJiYgby5uYW1lLmxlbmd0aCA9PT0gMCkgby5uYW1lID0gJyonO1xuICAgICAgby5hZ2dyID0gYTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIHRpbWUgZm5cbiAgZm9yIChpIGluIHNjaGVtYS50aW1lZm5zKSB7XG4gICAgdmFyIGYgPSBzY2hlbWEudGltZWZuc1tpXTtcbiAgICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKGYgKyAnXycpID09PSAwKSB7XG4gICAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKG8ubGVuZ3RoICsgMSk7XG4gICAgICBvLmZuID0gZjtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIC8vIGNoZWNrIGJpblxuICBpZiAoby5uYW1lICYmIG8ubmFtZS5pbmRleE9mKCdiaW5fJykgPT09IDApIHtcbiAgICBvLm5hbWUgPSBvLm5hbWUuc3Vic3RyKDQpO1xuICAgIG8uYmluID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBvO1xufTtcblxudmFyIHR5cGVPcmRlciA9IHtcbiAgTzogMCxcbiAgRzogMSxcbiAgVDogMixcbiAgUTogM1xufTtcblxudmxmaWVsZC5vcmRlciA9IHt9O1xuXG52bGZpZWxkLm9yZGVyLnR5cGUgPSBmdW5jdGlvbihmaWVsZCkge1xuICBpZiAoZmllbGQuYWdncj09PSdjb3VudCcpIHJldHVybiA0O1xuICByZXR1cm4gdHlwZU9yZGVyW2ZpZWxkLnR5cGVdO1xufTtcblxudmxmaWVsZC5vcmRlci50eXBlVGhlbk5hbWUgPSBmdW5jdGlvbihmaWVsZCkge1xuICByZXR1cm4gdmxmaWVsZC5vcmRlci50eXBlKGZpZWxkKSArICdfJyArIGZpZWxkLm5hbWUudG9Mb3dlckNhc2UoKTtcbn07XG5cbnZsZmllbGQub3JkZXIub3JpZ2luYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIDA7IC8vIG5vIHN3YXAgd2lsbCBvY2N1clxufTtcblxudmxmaWVsZC5vcmRlci5uYW1lID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGZpZWxkLm5hbWU7XG59O1xuXG52bGZpZWxkLm9yZGVyLnR5cGVUaGVuQ2FyZGluYWxpdHkgPSBmdW5jdGlvbihmaWVsZCwgc3RhdHMpe1xuICByZXR1cm4gc3RhdHNbZmllbGQubmFtZV0uY2FyZGluYWxpdHk7XG59O1xuXG4vLyBGSVhNRSByZWZhY3RvclxudmxmaWVsZC5pc1R5cGUgPSBmdW5jdGlvbiAoZmllbGREZWYsIHR5cGUpIHtcbiAgcmV0dXJuIChmaWVsZERlZi50eXBlICYgdHlwZSkgPiAwO1xufTtcblxudmxmaWVsZC5pc1R5cGUuYnlDb2RlID0gdmxmaWVsZC5pc1R5cGU7XG5cbnZsZmllbGQuaXNUeXBlLmJ5TmFtZSA9IGZ1bmN0aW9uIChmaWVsZCwgdHlwZSkge1xuICByZXR1cm4gZmllbGQudHlwZSA9PT0gY29uc3RzLmRhdGFUeXBlTmFtZXNbdHlwZV07XG59O1xuXG5cbmZ1bmN0aW9uIGdldElzVHlwZSh1c2VUeXBlQ29kZSkge1xuICByZXR1cm4gdXNlVHlwZUNvZGUgPyB2bGZpZWxkLmlzVHlwZS5ieUNvZGUgOiB2bGZpZWxkLmlzVHlwZS5ieU5hbWU7XG59XG5cbnZsZmllbGQuaXNUeXBlLmdldCA9IGdldElzVHlwZTsgLy9GSVhNRVxuXG4vKlxuICogTW9zdCBmaWVsZHMgdGhhdCB1c2Ugb3JkaW5hbCBzY2FsZSBhcmUgZGltZW5zaW9ucy5cbiAqIEhvd2V2ZXIsIFlFQVIoVCksIFlFQVJNT05USChUKSB1c2UgdGltZSBzY2FsZSwgbm90IG9yZGluYWwgYnV0IGFyZSBkaW1lbnNpb25zIHRvby5cbiAqL1xudmxmaWVsZC5pc09yZGluYWxTY2FsZSA9IGZ1bmN0aW9uKGZpZWxkLCB1c2VUeXBlQ29kZSAvKm9wdGlvbmFsKi8pIHtcbiAgdmFyIGlzVHlwZSA9IGdldElzVHlwZSh1c2VUeXBlQ29kZSk7XG4gIHJldHVybiAgaXNUeXBlKGZpZWxkLCBPKSB8fCBmaWVsZC5iaW4gfHxcbiAgICAoIGlzVHlwZShmaWVsZCwgVCkgJiYgZmllbGQuZm4gJiYgdGltZS5pc09yZGluYWxGbihmaWVsZC5mbikgKTtcbn07XG5cbmZ1bmN0aW9uIGlzRGltZW5zaW9uKGZpZWxkLCB1c2VUeXBlQ29kZSAvKm9wdGlvbmFsKi8pIHtcbiAgdmFyIGlzVHlwZSA9IGdldElzVHlwZSh1c2VUeXBlQ29kZSk7XG4gIHJldHVybiAgaXNUeXBlKGZpZWxkLCBPKSB8fCAhIWZpZWxkLmJpbiB8fFxuICAgICggaXNUeXBlKGZpZWxkLCBUKSAmJiAhIWZpZWxkLmZuICk7XG59XG5cbi8qKlxuICogRm9yIGVuY29kaW5nLCB1c2UgZW5jb2RpbmcuaXNEaW1lbnNpb24oKSB0byBhdm9pZCBjb25mdXNpb24uXG4gKiBPciB1c2UgRW5jb2RpbmcuaXNUeXBlIGlmIHlvdXIgZmllbGQgaXMgZnJvbSBFbmNvZGluZyAoYW5kIHRodXMgaGF2ZSBudW1lcmljIGRhdGEgdHlwZSkuXG4gKiBvdGhlcndpc2UsIGRvIG5vdCBzcGVjaWZpYyBpc1R5cGUgc28gd2UgY2FuIHVzZSB0aGUgZGVmYXVsdCBpc1R5cGVOYW1lIGhlcmUuXG4gKi9cbnZsZmllbGQuaXNEaW1lbnNpb24gPSBmdW5jdGlvbihmaWVsZCwgdXNlVHlwZUNvZGUgLypvcHRpb25hbCovKSB7XG4gIHJldHVybiBmaWVsZCAmJiBpc0RpbWVuc2lvbihmaWVsZCwgdXNlVHlwZUNvZGUpO1xufTtcblxudmxmaWVsZC5pc01lYXN1cmUgPSBmdW5jdGlvbihmaWVsZCwgdXNlVHlwZUNvZGUpIHtcbiAgcmV0dXJuIGZpZWxkICYmICFpc0RpbWVuc2lvbihmaWVsZCwgdXNlVHlwZUNvZGUpO1xufTtcblxudmxmaWVsZC5yb2xlID0gZnVuY3Rpb24oZmllbGQpIHtcbiAgcmV0dXJuIGlzRGltZW5zaW9uKGZpZWxkKSA/ICdkaW1lbnNpb24nIDogJ21lYXN1cmUnO1xufTtcblxudmxmaWVsZC5jb3VudCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4ge25hbWU6JyonLCBhZ2dyOiAnY291bnQnLCB0eXBlOidRJywgZGlzcGxheU5hbWU6IHZsZmllbGQuY291bnQuZGlzcGxheU5hbWV9O1xufTtcblxudmxmaWVsZC5jb3VudC5kaXNwbGF5TmFtZSA9ICdOdW1iZXIgb2YgUmVjb3Jkcyc7XG5cbnZsZmllbGQuaXNDb3VudCA9IGZ1bmN0aW9uKGZpZWxkKSB7XG4gIHJldHVybiBmaWVsZC5hZ2dyID09PSAnY291bnQnO1xufTtcblxuLyoqXG4gKiBGb3IgZW5jb2RpbmcsIHVzZSBlbmNvZGluZy5jYXJkaW5hbGl0eSgpIHRvIGF2b2lkIGNvbmZ1c2lvbi4gIE9yIHVzZSBFbmNvZGluZy5pc1R5cGUgaWYgeW91ciBmaWVsZCBpcyBmcm9tIEVuY29kaW5nIChhbmQgdGh1cyBoYXZlIG51bWVyaWMgZGF0YSB0eXBlKS5cbiAqIG90aGVyd2lzZSwgZG8gbm90IHNwZWNpZmljIGlzVHlwZSBzbyB3ZSBjYW4gdXNlIHRoZSBkZWZhdWx0IGlzVHlwZU5hbWUgaGVyZS5cbiAqL1xudmxmaWVsZC5jYXJkaW5hbGl0eSA9IGZ1bmN0aW9uKGZpZWxkLCBzdGF0cywgZmlsdGVyTnVsbCwgdXNlVHlwZUNvZGUpIHtcbiAgLy8gRklYTUUgbmVlZCB0byB0YWtlIGZpbHRlciBpbnRvIGFjY291bnRcbiAgdmFyIGlzVHlwZSA9IGdldElzVHlwZSh1c2VUeXBlQ29kZSksXG4gICAgdHlwZSA9IHVzZVR5cGVDb2RlID8gY29uc3RzLmRhdGFUeXBlTmFtZXNbZmllbGQudHlwZV0gOiBmaWVsZC50eXBlO1xuXG4gIGZpbHRlck51bGwgPSBmaWx0ZXJOdWxsIHx8IHt9O1xuXG4gIGlmIChmaWVsZC5iaW4pIHtcbiAgICB2YXIgYmlucyA9IHV0aWwuZ2V0YmlucyhzdGF0c1tmaWVsZC5uYW1lXSwgZmllbGQuYmluLm1heGJpbnMgfHwgc2NoZW1hLk1BWEJJTlNfREVGQVVMVCk7XG4gICAgcmV0dXJuIChiaW5zLnN0b3AgLSBiaW5zLnN0YXJ0KSAvIGJpbnMuc3RlcDtcbiAgfVxuICBpZiAoaXNUeXBlKGZpZWxkLCBUKSkge1xuICAgIHZhciBjYXJkaW5hbGl0eSA9IHRpbWUuY2FyZGluYWxpdHkoZmllbGQsIHN0YXRzLCBmaWx0ZXJOdWxsLCB0eXBlKTtcbiAgICBpZihjYXJkaW5hbGl0eSAhPT0gbnVsbCkgcmV0dXJuIGNhcmRpbmFsaXR5O1xuICAgIC8vb3RoZXJ3aXNlIHVzZSBjYWxjdWxhdGlvbiBiZWxvd1xuICB9XG4gIGlmIChmaWVsZC5hZ2dyKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cblxuICAvLyByZW1vdmUgbnVsbFxuICB2YXIgc3RhdCA9IHN0YXRzW2ZpZWxkLm5hbWVdO1xuICByZXR1cm4gc3RhdC5jYXJkaW5hbGl0eSAtXG4gICAgKHN0YXQubnVtTnVsbHMgPiAwICYmIGZpbHRlck51bGxbdHlwZV0gPyAxIDogMCk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG4vLyBkZWNsYXJlIGdsb2JhbCBjb25zdGFudFxudmFyIGcgPSBnbG9iYWwgfHwgd2luZG93O1xuXG5nLlRBQkxFID0gJ3RhYmxlJztcbmcuUkFXID0gJ3Jhdyc7XG5nLlNUQUNLRUQgPSAnc3RhY2tlZCc7XG5nLklOREVYID0gJ2luZGV4JztcblxuZy5YID0gJ3gnO1xuZy5ZID0gJ3knO1xuZy5ST1cgPSAncm93JztcbmcuQ09MID0gJ2NvbCc7XG5nLlNJWkUgPSAnc2l6ZSc7XG5nLlNIQVBFID0gJ3NoYXBlJztcbmcuQ09MT1IgPSAnY29sb3InO1xuZy5BTFBIQSA9ICdhbHBoYSc7XG5nLlRFWFQgPSAndGV4dCc7XG5nLkRFVEFJTCA9ICdkZXRhaWwnO1xuXG5nLk8gPSAxO1xuZy5RID0gMjtcbmcuVCA9IDQ7XG4iLCIvLyBQYWNrYWdlIG9mIGRlZmluaW5nIFZlZ2FsaXRlIFNwZWNpZmljYXRpb24ncyBqc29uIHNjaGVtYVxuXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBzY2hlbWEgPSBtb2R1bGUuZXhwb3J0cyA9IHt9LFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5zY2hlbWEudXRpbCA9IHJlcXVpcmUoJy4vc2NoZW1hdXRpbCcpO1xuXG5zY2hlbWEubWFya3R5cGUgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBlbnVtOiBbJ3BvaW50JywgJ3RpY2snLCAnYmFyJywgJ2xpbmUnLCAnYXJlYScsICdjaXJjbGUnLCAnc3F1YXJlJywgJ3RleHQnXVxufTtcblxuc2NoZW1hLmFnZ3IgPSB7XG4gIHR5cGU6ICdzdHJpbmcnLFxuICBlbnVtOiBbJ2F2ZycsICdzdW0nLCAnbWluJywgJ21heCcsICdjb3VudCddLFxuICBzdXBwb3J0ZWRFbnVtczoge1xuICAgIFE6IFsnYXZnJywgJ3N1bScsICdtaW4nLCAnbWF4JywgJ2NvdW50J10sXG4gICAgTzogW10sXG4gICAgVDogWydhdmcnLCAnbWluJywgJ21heCddLFxuICAgICcnOiBbJ2NvdW50J11cbiAgfSxcbiAgc3VwcG9ydGVkVHlwZXM6IHsnUSc6IHRydWUsICdPJzogdHJ1ZSwgJ1QnOiB0cnVlLCAnJzogdHJ1ZX1cbn07XG5zY2hlbWEuYmFuZCA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBzaXplOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfSxcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBtaW5pbXVtOiAwLFxuICAgICAgZGVmYXVsdDogMVxuICAgIH1cbiAgfVxufTtcblxuc2NoZW1hLmdldFN1cHBvcnRlZFJvbGUgPSBmdW5jdGlvbihlbmNUeXBlKSB7XG4gIHJldHVybiBzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuZW5jLnByb3BlcnRpZXNbZW5jVHlwZV0uc3VwcG9ydGVkUm9sZTtcbn07XG5cbnNjaGVtYS50aW1lZm5zID0gWyd5ZWFyJywgJ21vbnRoJywgJ2RheScsICdkYXRlJywgJ2hvdXJzJywgJ21pbnV0ZXMnLCAnc2Vjb25kcyddO1xuXG5zY2hlbWEuZGVmYXVsdFRpbWVGbiA9ICdtb250aCc7XG5cbnNjaGVtYS5mbiA9IHtcbiAgdHlwZTogJ3N0cmluZycsXG4gIGVudW06IHNjaGVtYS50aW1lZm5zLFxuICBzdXBwb3J0ZWRUeXBlczogeydUJzogdHJ1ZX1cbn07XG5cbi8vVE9ETyhrYW5pdHcpOiBhZGQgb3RoZXIgdHlwZSBvZiBmdW5jdGlvbiBoZXJlXG5cbnNjaGVtYS5zY2FsZV90eXBlID0ge1xuICB0eXBlOiAnc3RyaW5nJyxcbiAgZW51bTogWydsaW5lYXInLCAnbG9nJywgJ3BvdycsICdzcXJ0JywgJ3F1YW50aWxlJ10sXG4gIGRlZmF1bHQ6ICdsaW5lYXInLFxuICBzdXBwb3J0ZWRUeXBlczogeydRJzogdHJ1ZX1cbn07XG5cbnNjaGVtYS5maWVsZCA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBuYW1lOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJ1xuICAgIH1cbiAgfVxufTtcblxudmFyIGNsb25lID0gdXRpbC5kdXBsaWNhdGU7XG52YXIgbWVyZ2UgPSBzY2hlbWEudXRpbC5tZXJnZTtcblxuc2NoZW1hLk1BWEJJTlNfREVGQVVMVCA9IDE1O1xuXG52YXIgYmluID0ge1xuICB0eXBlOiBbJ2Jvb2xlYW4nLCAnb2JqZWN0J10sXG4gIGRlZmF1bHQ6IGZhbHNlLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbWF4Ymluczoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogc2NoZW1hLk1BWEJJTlNfREVGQVVMVCxcbiAgICAgIG1pbmltdW06IDJcbiAgICB9XG4gIH0sXG4gIHN1cHBvcnRlZFR5cGVzOiB7J1EnOiB0cnVlfSAvLyBUT0RPOiBhZGQgJ08nIGFmdGVyIGZpbmlzaGluZyAjODFcbn07XG5cbnZhciB0eXBpY2FsRmllbGQgPSBtZXJnZShjbG9uZShzY2hlbWEuZmllbGQpLCB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdHlwZToge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICBlbnVtOiBbJ08nLCAnUScsICdUJ11cbiAgICB9LFxuICAgIGFnZ3I6IHNjaGVtYS5hZ2dyLFxuICAgIGZuOiBzY2hlbWEuZm4sXG4gICAgYmluOiBiaW4sXG4gICAgc2NhbGU6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB0eXBlOiBzY2hlbWEuc2NhbGVfdHlwZSxcbiAgICAgICAgcmV2ZXJzZToge1xuICAgICAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgICAgICBzdXBwb3J0ZWRUeXBlczogeydRJzogdHJ1ZSwgJ1QnOiB0cnVlfVxuICAgICAgICB9LFxuICAgICAgICB6ZXJvOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnSW5jbHVkZSB6ZXJvJyxcbiAgICAgICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgICAgIHN1cHBvcnRlZFR5cGVzOiB7J1EnOiB0cnVlLCAnVCc6IHRydWV9XG4gICAgICAgIH0sXG4gICAgICAgIG5pY2U6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ3NlY29uZCcsICdtaW51dGUnLCAnaG91cicsICdkYXknLCAnd2VlaycsICdtb250aCcsICd5ZWFyJ10sXG4gICAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHsnVCc6IHRydWV9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn0pO1xuXG52YXIgb25seU9yZGluYWxGaWVsZCA9IG1lcmdlKGNsb25lKHNjaGVtYS5maWVsZCksIHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBkaW1lbnNpb246IHRydWVcbiAgfSxcbiAgcHJvcGVydGllczoge1xuICAgIHR5cGU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydPJywnUScsICdUJ10gLy8gb3JkaW5hbC1vbmx5IGZpZWxkIHN1cHBvcnRzIFEgd2hlbiBiaW4gaXMgYXBwbGllZCBhbmQgVCB3aGVuIGZuIGlzIGFwcGxpZWQuXG4gICAgfSxcbiAgICBmbjogc2NoZW1hLmZuLFxuICAgIGJpbjogYmluLFxuICAgIGFnZ3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgZW51bTogWydjb3VudCddLFxuICAgICAgc3VwcG9ydGVkVHlwZXM6IHsnTyc6IHRydWV9XG4gICAgfVxuICB9XG59KTtcblxudmFyIGF4aXNNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIGF4aXM6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBncmlkOiB7XG4gICAgICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBIGZsYWcgaW5kaWNhdGUgaWYgZ3JpZGxpbmVzIHNob3VsZCBiZSBjcmVhdGVkIGluIGFkZGl0aW9uIHRvIHRpY2tzLidcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGU6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0EgdGl0bGUgZm9yIHRoZSBheGlzLidcbiAgICAgICAgfSxcbiAgICAgICAgdGl0bGVPZmZzZXQ6IHtcbiAgICAgICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAgLy8gYXV0b1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnQSB0aXRsZSBvZmZzZXQgdmFsdWUgZm9yIHRoZSBheGlzLidcbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAgLy8gYXV0b1xuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVGhlIGZvcm1hdHRpbmcgcGF0dGVybiBmb3IgYXhpcyBsYWJlbHMuJ1xuICAgICAgICB9LFxuICAgICAgICBtYXhMYWJlbExlbmd0aDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiAyNSxcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVHJ1bmNhdGUgbGFiZWxzIHRoYXQgYXJlIHRvbyBsb25nLidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIHNvcnRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBzb3J0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgZGVmYXVsdDogW10sXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnb2JqZWN0JyxcbiAgICAgICAgc3VwcG9ydGVkVHlwZXM6IHsnTyc6IHRydWV9LFxuICAgICAgICByZXF1aXJlZDogWyduYW1lJywgJ2FnZ3InXSxcbiAgICAgICAgbmFtZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnXG4gICAgICAgIH0sXG4gICAgICAgIGFnZ3I6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBlbnVtOiBbJ2F2ZycsICdzdW0nLCAnbWluJywgJ21heCcsICdjb3VudCddXG4gICAgICAgIH0sXG4gICAgICAgIHJldmVyc2U6IHtcbiAgICAgICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICAgICAgZGVmYXVsdDogZmFsc2VcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGJhbmRNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBiYW5kOiBzY2hlbWEuYmFuZFxuICB9XG59O1xuXG52YXIgbGVnZW5kTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbGVnZW5kOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlXG4gICAgfVxuICB9XG59O1xuXG52YXIgdGV4dE1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7J3RleHQnOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHRleHQ6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBhbGlnbjoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdsZWZ0J1xuICAgICAgICB9LFxuICAgICAgICBiYXNlbGluZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdtaWRkbGUnXG4gICAgICAgIH0sXG4gICAgICAgIG1hcmdpbjoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiA0LFxuICAgICAgICAgIG1pbmltdW06IDBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG4gICAgZm9udDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHdlaWdodDoge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGVudW06IFsnbm9ybWFsJywgJ2JvbGQnXSxcbiAgICAgICAgICBkZWZhdWx0OiAnbm9ybWFsJ1xuICAgICAgICB9LFxuICAgICAgICBzaXplOiB7XG4gICAgICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgICAgIGRlZmF1bHQ6IDEwLFxuICAgICAgICAgIG1pbmltdW06IDBcbiAgICAgICAgfSxcbiAgICAgICAgZmFtaWx5OiB7XG4gICAgICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICAgICAgZGVmYXVsdDogJ0hlbHZldGljYSBOZXVlJ1xuICAgICAgICB9LFxuICAgICAgICBzdHlsZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6ICdub3JtYWwnLFxuICAgICAgICAgIGVudW06IFsnbm9ybWFsJywgJ2l0YWxpYyddXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaXplTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgYmFyOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgdGV4dDogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICB2YWx1ZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMzAsXG4gICAgICBtaW5pbXVtOiAwXG4gICAgfVxuICB9XG59O1xuXG52YXIgY29sb3JNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLCAndGV4dCc6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICdzdGVlbGJsdWUnXG4gICAgfSxcbiAgICBzY2FsZToge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHJhbmdlOiB7XG4gICAgICAgICAgdHlwZTogWydzdHJpbmcnLCAnYXJyYXknXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG52YXIgYWxwaGFNaXhpbiA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHN1cHBvcnRlZE1hcmt0eXBlczoge3BvaW50OiB0cnVlLCB0aWNrOiB0cnVlLCBiYXI6IHRydWUsIGxpbmU6IHRydWUsIGFyZWE6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlLCAndGV4dCc6IHRydWV9LFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgdmFsdWU6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkLCAgLy8gYXV0b1xuICAgICAgbWluaW11bTogMCxcbiAgICAgIG1heGltdW06IDFcbiAgICB9XG4gIH1cbn07XG5cbnZhciBzaGFwZU1peGluID0ge1xuICB0eXBlOiAnb2JqZWN0JyxcbiAgc3VwcG9ydGVkTWFya3R5cGVzOiB7cG9pbnQ6IHRydWUsIGNpcmNsZTogdHJ1ZSwgc3F1YXJlOiB0cnVlfSxcbiAgcHJvcGVydGllczoge1xuICAgIHZhbHVlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnY2lyY2xlJywgJ3NxdWFyZScsICdjcm9zcycsICdkaWFtb25kJywgJ3RyaWFuZ2xlLXVwJywgJ3RyaWFuZ2xlLWRvd24nXSxcbiAgICAgIGRlZmF1bHQ6ICdjaXJjbGUnXG4gICAgfVxuICB9XG59O1xuXG52YXIgZGV0YWlsTWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgbGluZTogdHJ1ZSwgY2lyY2xlOiB0cnVlLCBzcXVhcmU6IHRydWV9XG59O1xuXG52YXIgcm93TWl4aW4gPSB7XG4gIHByb3BlcnRpZXM6IHtcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIGRlZmF1bHQ6IDE1MFxuICAgIH0sXG4gICAgZ3JpZDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnQSBmbGFnIGluZGljYXRlIGlmIGdyaWRsaW5lcyBzaG91bGQgYmUgY3JlYXRlZCBpbiBhZGRpdGlvbiB0byB0aWNrcy4nXG4gICAgfSxcbiAgfVxufTtcblxudmFyIGNvbE1peGluID0ge1xuICBwcm9wZXJ0aWVzOiB7XG4gICAgd2lkdGg6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgbWluaW11bTogMCxcbiAgICAgIGRlZmF1bHQ6IDE1MFxuICAgIH0sXG4gICAgYXhpczoge1xuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBtYXhMYWJlbExlbmd0aDoge1xuICAgICAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgICAgICBkZWZhdWx0OiAxMixcbiAgICAgICAgICBtaW5pbXVtOiAwLFxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnVHJ1bmNhdGUgbGFiZWxzIHRoYXQgYXJlIHRvbyBsb25nLidcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGZhY2V0TWl4aW4gPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBzdXBwb3J0ZWRNYXJrdHlwZXM6IHtwb2ludDogdHJ1ZSwgdGljazogdHJ1ZSwgYmFyOiB0cnVlLCBsaW5lOiB0cnVlLCBhcmVhOiB0cnVlLCBjaXJjbGU6IHRydWUsIHNxdWFyZTogdHJ1ZSwgdGV4dDogdHJ1ZX0sXG4gIHByb3BlcnRpZXM6IHtcbiAgICBwYWRkaW5nOiB7XG4gICAgICB0eXBlOiAnbnVtYmVyJyxcbiAgICAgIG1pbmltdW06IDAsXG4gICAgICBtYXhpbXVtOiAxLFxuICAgICAgZGVmYXVsdDogMC4xXG4gICAgfVxuICB9XG59O1xuXG52YXIgcmVxdWlyZWROYW1lVHlwZSA9IHtcbiAgcmVxdWlyZWQ6IFsnbmFtZScsICd0eXBlJ11cbn07XG5cbnZhciBtdWx0aVJvbGVGaWVsZCA9IG1lcmdlKGNsb25lKHR5cGljYWxGaWVsZCksIHtcbiAgc3VwcG9ydGVkUm9sZToge1xuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgZGltZW5zaW9uOiB0cnVlXG4gIH1cbn0pO1xuXG52YXIgcXVhbnRpdGF0aXZlRmllbGQgPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCB7XG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIGRpbWVuc2lvbjogJ29yZGluYWwtb25seScgLy8gdXNpbmcgYWxwaGEgLyBzaXplIHRvIGVuY29kaW5nIGNhdGVnb3J5IGxlYWQgdG8gb3JkZXIgaW50ZXJwcmV0YXRpb25cbiAgfVxufSk7XG5cbnZhciBvbmx5UXVhbnRpdGF0aXZlRmllbGQgPSBtZXJnZShjbG9uZSh0eXBpY2FsRmllbGQpLCB7XG4gIHN1cHBvcnRlZFJvbGU6IHtcbiAgICBtZWFzdXJlOiB0cnVlXG4gIH1cbn0pO1xuXG52YXIgeCA9IG1lcmdlKGNsb25lKG11bHRpUm9sZUZpZWxkKSwgYXhpc01peGluLCBiYW5kTWl4aW4sIHJlcXVpcmVkTmFtZVR5cGUsIHNvcnRNaXhpbik7XG52YXIgeSA9IGNsb25lKHgpO1xuXG52YXIgZmFjZXQgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgcmVxdWlyZWROYW1lVHlwZSwgZmFjZXRNaXhpbiwgc29ydE1peGluKTtcbnZhciByb3cgPSBtZXJnZShjbG9uZShmYWNldCksIGF4aXNNaXhpbiwgcm93TWl4aW4pO1xudmFyIGNvbCA9IG1lcmdlKGNsb25lKGZhY2V0KSwgYXhpc01peGluLCBjb2xNaXhpbik7XG5cbnZhciBzaXplID0gbWVyZ2UoY2xvbmUocXVhbnRpdGF0aXZlRmllbGQpLCBsZWdlbmRNaXhpbiwgc2l6ZU1peGluLCBzb3J0TWl4aW4pO1xudmFyIGNvbG9yID0gbWVyZ2UoY2xvbmUobXVsdGlSb2xlRmllbGQpLCBsZWdlbmRNaXhpbiwgY29sb3JNaXhpbiwgc29ydE1peGluKTtcbnZhciBhbHBoYSA9IG1lcmdlKGNsb25lKHF1YW50aXRhdGl2ZUZpZWxkKSwgYWxwaGFNaXhpbiwgc29ydE1peGluKTtcbnZhciBzaGFwZSA9IG1lcmdlKGNsb25lKG9ubHlPcmRpbmFsRmllbGQpLCBsZWdlbmRNaXhpbiwgc2hhcGVNaXhpbiwgc29ydE1peGluKTtcbnZhciBkZXRhaWwgPSBtZXJnZShjbG9uZShvbmx5T3JkaW5hbEZpZWxkKSwgZGV0YWlsTWl4aW4sIHNvcnRNaXhpbik7XG5cbi8vIHdlIG9ubHkgcHV0IGFnZ3JlZ2F0ZWQgbWVhc3VyZSBpbiBwaXZvdCB0YWJsZVxudmFyIHRleHQgPSBtZXJnZShjbG9uZShvbmx5UXVhbnRpdGF0aXZlRmllbGQpLCB0ZXh0TWl4aW4sIHNvcnRNaXhpbik7XG5cbi8vIFRPRE8gYWRkIGxhYmVsXG5cbnZhciBmaWx0ZXIgPSB7XG4gIHR5cGU6ICdhcnJheScsXG4gIGl0ZW1zOiB7XG4gICAgdHlwZTogJ29iamVjdCcsXG4gICAgcHJvcGVydGllczoge1xuICAgICAgb3BlcmFuZHM6IHtcbiAgICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgICAgaXRlbXM6IHtcbiAgICAgICAgICB0eXBlOiBbJ3N0cmluZycsICdib29sZWFuJywgJ2ludGVnZXInLCAnbnVtYmVyJ11cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIG9wZXJhdG9yOiB7XG4gICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICBlbnVtOiBbJz4nLCAnPj0nLCAnPScsICchPScsICc8JywgJzw9JywgJ25vdE51bGwnXVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGRhdGEgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLy8gZGF0YSBzb3VyY2VcbiAgICBmb3JtYXRUeXBlOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGVudW06IFsnanNvbicsICdjc3YnXSxcbiAgICAgIGRlZmF1bHQ6ICdqc29uJ1xuICAgIH0sXG4gICAgdXJsOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgdmVnYVNlcnZlcjoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBkZWZhdWx0OiBudWxsLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICB0YWJsZToge1xuICAgICAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgICAgICB9LFxuICAgICAgICB1cmw6IHtcbiAgICAgICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgICAgICBkZWZhdWx0OiAnaHR0cDovL2xvY2FsaG9zdDozMDAxJ1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG5jb25zb2xlLmxvZyhzY2hlbWEudXRpbC5pbnN0YW50aWF0ZShkYXRhKSk7XG5cbnZhciBjb25maWcgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgLy8gdGVtcGxhdGVcbiAgICB3aWR0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogdW5kZWZpbmVkXG4gICAgfSxcbiAgICBoZWlnaHQ6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IHVuZGVmaW5lZFxuICAgIH0sXG4gICAgdmlld3BvcnQ6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge1xuICAgICAgICB0eXBlOiAnaW50ZWdlcidcbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiB1bmRlZmluZWRcbiAgICB9LFxuICAgIGdyaWRDb2xvcjoge1xuICAgICAgdHlwZTogJ3N0cmluZycsXG4gICAgICByb2xlOiAnY29sb3InLFxuICAgICAgZGVmYXVsdDogJyNlZWVlZWUnXG4gICAgfSxcblxuICAgIC8vIGZpbHRlciBudWxsXG4gICAgZmlsdGVyTnVsbDoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIE86IHt0eXBlOidib29sZWFuJywgZGVmYXVsdDogZmFsc2V9LFxuICAgICAgICBROiB7dHlwZTonYm9vbGVhbicsIGRlZmF1bHQ6IHRydWV9LFxuICAgICAgICBUOiB7dHlwZTonYm9vbGVhbicsIGRlZmF1bHQ6IHRydWV9XG4gICAgICB9XG4gICAgfSxcbiAgICB0b2dnbGVTb3J0OiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdPJ1xuICAgIH0sXG5cbiAgICAvLyBzaW5nbGUgcGxvdFxuICAgIHNpbmdsZUhlaWdodDoge1xuICAgICAgLy8gd2lsbCBiZSBvdmVyd3JpdHRlbiBieSBiYW5kV2lkdGggKiAoY2FyZGluYWxpdHkgKyBwYWRkaW5nKVxuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMjAwLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgc2luZ2xlV2lkdGg6IHtcbiAgICAgIC8vIHdpbGwgYmUgb3ZlcndyaXR0ZW4gYnkgYmFuZFdpZHRoICogKGNhcmRpbmFsaXR5ICsgcGFkZGluZylcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwMCxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIC8vIGJhbmQgc2l6ZVxuICAgIGxhcmdlQmFuZFNpemU6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIxLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG4gICAgc21hbGxCYW5kU2l6ZToge1xuICAgICAgLy9zbWFsbCBtdWx0aXBsZXMgb3Igc2luZ2xlIHBsb3Qgd2l0aCBoaWdoIGNhcmRpbmFsaXR5XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAxMixcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIGxhcmdlQmFuZE1heENhcmRpbmFsaXR5OiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAxMFxuICAgIH0sXG4gICAgLy8gc21hbGwgbXVsdGlwbGVzXG4gICAgY2VsbFBhZGRpbmc6IHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgZGVmYXVsdDogMC4xXG4gICAgfSxcbiAgICBjZWxsR3JpZENvbG9yOiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIHJvbGU6ICdjb2xvcicsXG4gICAgICBkZWZhdWx0OiAnI2FhYWFhYSdcbiAgICB9LFxuICAgIGNlbGxCYWNrZ3JvdW5kQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdzdHJpbmcnLFxuICAgICAgcm9sZTogJ2NvbG9yJyxcbiAgICAgIGRlZmF1bHQ6ICd0cmFuc3BhcmVudCdcbiAgICB9LFxuICAgIHRleHRDZWxsV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDkwLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG5cbiAgICAvLyBtYXJrc1xuICAgIHN0cm9rZVdpZHRoOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyLFxuICAgICAgbWluaW11bTogMFxuICAgIH0sXG5cbiAgICAvLyBzY2FsZXNcbiAgICB0aW1lU2NhbGVMYWJlbExlbmd0aDoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogMyxcbiAgICAgIG1pbmltdW06IDBcbiAgICB9LFxuICAgIC8vIG90aGVyXG4gICAgY2hhcmFjdGVyV2lkdGg6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDZcbiAgICB9XG4gIH1cbn07XG5cbi8qKiBAdHlwZSBPYmplY3QgU2NoZW1hIG9mIGEgdmVnYWxpdGUgc3BlY2lmaWNhdGlvbiAqL1xuc2NoZW1hLnNjaGVtYSA9IHtcbiAgJHNjaGVtYTogJ2h0dHA6Ly9qc29uLXNjaGVtYS5vcmcvZHJhZnQtMDQvc2NoZW1hIycsXG4gIGRlc2NyaXB0aW9uOiAnU2NoZW1hIGZvciB2ZWdhbGl0ZSBzcGVjaWZpY2F0aW9uJyxcbiAgdHlwZTogJ29iamVjdCcsXG4gIHJlcXVpcmVkOiBbJ21hcmt0eXBlJywgJ2VuYycsICdkYXRhJywgJ2NvbmZpZyddLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgZGF0YTogZGF0YSxcbiAgICBtYXJrdHlwZTogc2NoZW1hLm1hcmt0eXBlLFxuICAgIGVuYzoge1xuICAgICAgdHlwZTogJ29iamVjdCcsXG4gICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHJvdzogcm93LFxuICAgICAgICBjb2w6IGNvbCxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgY29sb3I6IGNvbG9yLFxuICAgICAgICBhbHBoYTogYWxwaGEsXG4gICAgICAgIHNoYXBlOiBzaGFwZSxcbiAgICAgICAgdGV4dDogdGV4dCxcbiAgICAgICAgZGV0YWlsOiBkZXRhaWxcbiAgICAgIH1cbiAgICB9LFxuICAgIGZpbHRlcjogZmlsdGVyLFxuICAgIGNvbmZpZzogY29uZmlnXG4gIH1cbn07XG5cbnNjaGVtYS5lbmNUeXBlcyA9IHV0aWwua2V5cyhzY2hlbWEuc2NoZW1hLnByb3BlcnRpZXMuZW5jLnByb3BlcnRpZXMpO1xuXG4vKiogSW5zdGFudGlhdGUgYSB2ZXJib3NlIHZsIHNwZWMgZnJvbSB0aGUgc2NoZW1hICovXG5zY2hlbWEuaW5zdGFudGlhdGUgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHNjaGVtYS51dGlsLmluc3RhbnRpYXRlKHNjaGVtYS5zY2hlbWEpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHNjaGVtYXV0aWwgPSBtb2R1bGUuZXhwb3J0cyA9IHt9LFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG52YXIgaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gT2JqZWN0LmtleXMob2JqKS5sZW5ndGggPT09IDA7XG59O1xuXG5zY2hlbWF1dGlsLmV4dGVuZCA9IGZ1bmN0aW9uKGluc3RhbmNlLCBzY2hlbWEpIHtcbiAgcmV0dXJuIHNjaGVtYXV0aWwubWVyZ2Uoc2NoZW1hdXRpbC5pbnN0YW50aWF0ZShzY2hlbWEpLCBpbnN0YW5jZSk7XG59O1xuXG4vLyBpbnN0YW50aWF0ZSBhIHNjaGVtYVxuc2NoZW1hdXRpbC5pbnN0YW50aWF0ZSA9IGZ1bmN0aW9uKHNjaGVtYSkge1xuICB2YXIgdmFsO1xuICBpZiAoc2NoZW1hID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9IGVsc2UgaWYgKCdkZWZhdWx0JyBpbiBzY2hlbWEpIHtcbiAgICB2YWwgPSBzY2hlbWEuZGVmYXVsdDtcbiAgICByZXR1cm4gdXRpbC5pc09iamVjdCh2YWwpID8gdXRpbC5kdXBsaWNhdGUodmFsKSA6IHZhbDtcbiAgfSBlbHNlIGlmIChzY2hlbWEudHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgaW5zdGFuY2UgPSB7fTtcbiAgICBmb3IgKHZhciBuYW1lIGluIHNjaGVtYS5wcm9wZXJ0aWVzKSB7XG4gICAgICB2YWwgPSBzY2hlbWF1dGlsLmluc3RhbnRpYXRlKHNjaGVtYS5wcm9wZXJ0aWVzW25hbWVdKTtcbiAgICAgIGlmICh2YWwgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbnN0YW5jZVtuYW1lXSA9IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2UgaWYgKHNjaGVtYS50eXBlID09PSAnYXJyYXknKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHJldHVybiB1bmRlZmluZWQ7XG59O1xuXG4vLyByZW1vdmUgYWxsIGRlZmF1bHRzIGZyb20gYW4gaW5zdGFuY2VcbnNjaGVtYXV0aWwuc3VidHJhY3QgPSBmdW5jdGlvbihpbnN0YW5jZSwgZGVmYXVsdHMpIHtcbiAgdmFyIGNoYW5nZXMgPSB7fTtcbiAgZm9yICh2YXIgcHJvcCBpbiBpbnN0YW5jZSkge1xuICAgIHZhciBkZWYgPSBkZWZhdWx0c1twcm9wXTtcbiAgICB2YXIgaW5zID0gaW5zdGFuY2VbcHJvcF07XG4gICAgLy8gTm90ZTogZG9lcyBub3QgcHJvcGVybHkgc3VidHJhY3QgYXJyYXlzXG4gICAgaWYgKCFkZWZhdWx0cyB8fCBkZWYgIT09IGlucykge1xuICAgICAgaWYgKHR5cGVvZiBpbnMgPT09ICdvYmplY3QnICYmICF1dGlsLmlzQXJyYXkoaW5zKSAmJiBkZWYpIHtcbiAgICAgICAgdmFyIGMgPSBzY2hlbWF1dGlsLnN1YnRyYWN0KGlucywgZGVmKTtcbiAgICAgICAgaWYgKCFpc0VtcHR5KGMpKVxuICAgICAgICAgIGNoYW5nZXNbcHJvcF0gPSBjO1xuICAgICAgfSBlbHNlIGlmICghdXRpbC5pc0FycmF5KGlucykgfHwgaW5zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgY2hhbmdlc1twcm9wXSA9IGlucztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGNoYW5nZXM7XG59O1xuXG5zY2hlbWF1dGlsLm1lcmdlID0gZnVuY3Rpb24oLypkZXN0Kiwgc3JjMCwgc3JjMSwgLi4uKi8pe1xuICB2YXIgZGVzdCA9IGFyZ3VtZW50c1swXTtcbiAgZm9yICh2YXIgaT0xIDsgaTxhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICBkZXN0ID0gbWVyZ2UoZGVzdCwgYXJndW1lbnRzW2ldKTtcbiAgfVxuICByZXR1cm4gZGVzdDtcbn07XG5cbi8vIHJlY3Vyc2l2ZWx5IG1lcmdlcyBzcmMgaW50byBkZXN0XG5mdW5jdGlvbiBtZXJnZShkZXN0LCBzcmMpIHtcbiAgaWYgKHR5cGVvZiBzcmMgIT09ICdvYmplY3QnIHx8IHNyYyA9PT0gbnVsbCkge1xuICAgIHJldHVybiBkZXN0O1xuICB9XG5cbiAgZm9yICh2YXIgcCBpbiBzcmMpIHtcbiAgICBpZiAoIXNyYy5oYXNPd25Qcm9wZXJ0eShwKSkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChzcmNbcF0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygc3JjW3BdICE9PSAnb2JqZWN0JyB8fCBzcmNbcF0gPT09IG51bGwpIHtcbiAgICAgIGRlc3RbcF0gPSBzcmNbcF07XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZGVzdFtwXSAhPT0gJ29iamVjdCcgfHwgZGVzdFtwXSA9PT0gbnVsbCkge1xuICAgICAgZGVzdFtwXSA9IG1lcmdlKHNyY1twXS5jb25zdHJ1Y3RvciA9PT0gQXJyYXkgPyBbXSA6IHt9LCBzcmNbcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBtZXJnZShkZXN0W3BdLCBzcmNbcF0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGVzdDtcbn0iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlsID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxudXRpbC5rZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gIHZhciBrID0gW10sIHg7XG4gIGZvciAoeCBpbiBvYmopIGsucHVzaCh4KTtcbiAgcmV0dXJuIGs7XG59O1xuXG51dGlsLnZhbHMgPSBmdW5jdGlvbihvYmopIHtcbiAgdmFyIHYgPSBbXSwgeDtcbiAgZm9yICh4IGluIG9iaikgdi5wdXNoKG9ialt4XSk7XG4gIHJldHVybiB2O1xufTtcblxudXRpbC5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgIHN0ZXAgPSAxO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMikge1xuICAgICAgc3RvcCA9IHN0YXJ0O1xuICAgICAgc3RhcnQgPSAwO1xuICAgIH1cbiAgfVxuICBpZiAoKHN0b3AgLSBzdGFydCkgLyBzdGVwID09IEluZmluaXR5KSB0aHJvdyBuZXcgRXJyb3IoJ2luZmluaXRlIHJhbmdlJyk7XG4gIHZhciByYW5nZSA9IFtdLCBpID0gLTEsIGo7XG4gIGlmIChzdGVwIDwgMCkgd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA+IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIGVsc2Ugd2hpbGUgKChqID0gc3RhcnQgKyBzdGVwICogKytpKSA8IHN0b3ApIHJhbmdlLnB1c2goaik7XG4gIHJldHVybiByYW5nZTtcbn07XG5cbnV0aWwuZmluZCA9IGZ1bmN0aW9uKGxpc3QsIHBhdHRlcm4pIHtcbiAgdmFyIGwgPSBsaXN0LmZpbHRlcihmdW5jdGlvbih4KSB7XG4gICAgcmV0dXJuIHhbcGF0dGVybi5uYW1lXSA9PT0gcGF0dGVybi52YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBsLmxlbmd0aCAmJiBsWzBdIHx8IG51bGw7XG59O1xuXG51dGlsLmlzaW4gPSBmdW5jdGlvbihpdGVtLCBhcnJheSkge1xuICByZXR1cm4gYXJyYXkuaW5kZXhPZihpdGVtKSAhPT0gLTE7XG59O1xuXG51dGlsLnVuaXEgPSBmdW5jdGlvbihkYXRhLCBmaWVsZCkge1xuICB2YXIgbWFwID0ge30sIGNvdW50ID0gMCwgaSwgaztcbiAgZm9yIChpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyArK2kpIHtcbiAgICBrID0gZGF0YVtpXVtmaWVsZF07XG4gICAgaWYgKCFtYXBba10pIHtcbiAgICAgIG1hcFtrXSA9IDE7XG4gICAgICBjb3VudCArPSAxO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY291bnQ7XG59O1xuXG52YXIgaXNOdW1iZXIgPSBmdW5jdGlvbihuKSB7XG4gIHJldHVybiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59O1xuXG4vLyB0cnkgcGFyc2luZyB0byBudW1iZXJcbnV0aWwubnVtYmVycyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgbnVtcyA9IFtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgIGlmIChpc051bWJlcih2YWx1ZXNbaV0pKSB7XG4gICAgICBudW1zLnB1c2goK3ZhbHVlc1tpXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBudW1zO1xufTtcblxuLy8gdHJ5IHRvIHBhcnNlIGFzIGRhdGVcbnV0aWwuZGF0ZXMgPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgdmFyIGRhdGVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRhdGUgPSBEYXRlLnBhcnNlKHZhbHVlc1tpXSk7XG4gICAgaWYgKCFpc05hTihkYXRlKSkge1xuICAgICAgZGF0ZXMucHVzaChuZXcgRGF0ZShkYXRlKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkYXRlcztcbn07XG5cbnV0aWwubWVkaWFuID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhbHVlcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtyZXR1cm4gYSAtIGI7fSk7XG4gIHZhciBoYWxmID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoLzIpO1xuICBpZiAodmFsdWVzLmxlbmd0aCAlIDIpIHtcbiAgICByZXR1cm4gdmFsdWVzW2hhbGZdO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiAodmFsdWVzW2hhbGYtMV0gKyB2YWx1ZXNbaGFsZl0pIC8gMi4wO1xuICB9XG59O1xuXG51dGlsLm1lYW4gPSBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoZnVuY3Rpb24odiwgcikge3JldHVybiB2ICsgcjt9LCAwKSAvIHZhbHVlcy5sZW5ndGg7XG59O1xuXG51dGlsLnZhcmlhbmNlID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHZhciBhdmcgPSB1dGlsLm1lYW4odmFsdWVzKTtcbiAgdmFyIGRpZmZzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsdWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGlmZnMucHVzaChNYXRoLnBvdygodmFsdWVzW2ldIC0gYXZnKSwgMikpO1xuICB9XG4gIHJldHVybiB1dGlsLm1lYW4oZGlmZnMpO1xufTtcblxudXRpbC5zdGFibGVzb3J0ID0gZnVuY3Rpb24oYXJyYXksIHNvcnRCeSwga2V5Rm4pIHtcbiAgdmFyIGluZGljZXMgPSB7fTtcblxuICBhcnJheS5mb3JFYWNoKGZ1bmN0aW9uKHYsIGkpIHtcbiAgICBpbmRpY2VzW2tleUZuKHYpXSA9IGk7XG4gIH0pO1xuXG4gIGFycmF5LnNvcnQoZnVuY3Rpb24oYSwgYikge1xuICAgIHZhciBzYSA9IHNvcnRCeShhKSxcbiAgICAgIHNiID0gc29ydEJ5KGIpO1xuXG4gICAgcmV0dXJuIHNhPHNiID8gLTEgOiBzYT5zYiA/IDEgOiAoaW5kaWNlc1trZXlGbihhKV0gLSBpbmRpY2VzW2tleUZuKGIpXSk7XG4gIH0pO1xuICByZXR1cm4gYXJyYXk7XG59O1xuXG51dGlsLnN0ZGV2ID0gZnVuY3Rpb24odmFsdWVzKSB7XG4gIHJldHVybiBNYXRoLnNxcnQodXRpbC52YXJpYW5jZSh2YWx1ZXMpKTtcbn07XG5cbnV0aWwuc2tldyA9IGZ1bmN0aW9uKHZhbHVlcykge1xuICB2YXIgYXZnID0gdXRpbC5tZWFuKHZhbHVlcyksXG4gICAgbWVkID0gdXRpbC5tZWRpYW4odmFsdWVzKSxcbiAgICBzdGQgPSB1dGlsLnN0ZGV2KHZhbHVlcyk7XG4gIHJldHVybiAxLjAgKiAoYXZnIC0gbWVkKSAvIHN0ZDtcbn07XG5cbi8vIHBhcnNlcyBhIHN0cmluZyB0byBkYXRlIG9yIG51bWJlclxudXRpbC5wYXJzZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gIGlmIChpc051bWJlcih2YWx1ZSkpIHtcbiAgICByZXR1cm4gK3ZhbHVlO1xuICB9XG5cbiAgdmFyIGRhdGUgPSBEYXRlLnBhcnNlKHZhbHVlKTtcbiAgaWYgKCFpc05hTihkYXRlKSkge1xuICAgIHJldHVybiAobmV3IERhdGUoZGF0ZSkpO1xuICB9XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbnV0aWwubWlubWF4ID0gZnVuY3Rpb24oZGF0YSkge1xuICB2YXIgc3RhdHMgPSB7bWluOiArSW5maW5pdHksIG1heDogLUluZmluaXR5fTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHYgPSBkYXRhW2ldO1xuICAgIGlmICh2ICE9PSBudWxsKSB7XG4gICAgICBpZiAodiA+IHN0YXRzLm1heCB8fCBzdGF0cy5tYXggPT09IC1JbmZpbml0eSkgc3RhdHMubWF4ID0gdjtcbiAgICAgIGlmICh2IDwgc3RhdHMubWluIHx8IHN0YXRzLm1pbiA9PT0gK0luZmluaXR5KSBzdGF0cy5taW4gPSB2O1xuICAgIH1cbiAgfVxuICByZXR1cm4gc3RhdHM7XG59O1xuXG51dGlsLmR1cGxpY2F0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShvYmopKTtcbn07XG5cbnV0aWwuaXNPYmplY3QgPSBmdW5jdGlvbihvYmopIHtcbiAgcmV0dXJuIG9iaiA9PT0gT2JqZWN0KG9iaik7XG59O1xuXG51dGlsLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKG9iaikge1xuICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xuXG51dGlsLmFycmF5ID0gZnVuY3Rpb24oeCkge1xuICByZXR1cm4geCA/ICh1dGlsLmlzQXJyYXkoeCkgPyB4IDogW3hdKSA6IFtdO1xufTtcblxudXRpbC5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBmLCB0aGlzQXJnKSB7XG4gIGlmIChvYmouZm9yRWFjaCkge1xuICAgIG9iai5mb3JFYWNoLmNhbGwodGhpc0FyZywgZik7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIGYuY2FsbCh0aGlzQXJnLCBvYmpba10sIGsgLCBvYmopO1xuICAgIH1cbiAgfVxufTtcblxudXRpbC5yZWR1Y2UgPSBmdW5jdGlvbihvYmosIGYsIGluaXQsIHRoaXNBcmcpIHtcbiAgaWYgKG9iai5yZWR1Y2UpIHtcbiAgICByZXR1cm4gb2JqLnJlZHVjZS5jYWxsKHRoaXNBcmcsIGYsIGluaXQpO1xuICB9IGVsc2Uge1xuICAgIGZvciAodmFyIGsgaW4gb2JqKSB7XG4gICAgICBpbml0ID0gZi5jYWxsKHRoaXNBcmcsIGluaXQsIG9ialtrXSwgaywgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIGluaXQ7XG4gIH1cbn07XG5cbnV0aWwubWFwID0gZnVuY3Rpb24ob2JqLCBmLCB0aGlzQXJnKSB7XG4gIGlmIChvYmoubWFwKSB7XG4gICAgcmV0dXJuIG9iai5tYXAuY2FsbCh0aGlzQXJnLCBmKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgb3V0cHV0ID0gW107XG4gICAgZm9yICh2YXIgayBpbiBvYmopIHtcbiAgICAgIG91dHB1dC5wdXNoKCBmLmNhbGwodGhpc0FyZywgb2JqW2tdLCBrLCBvYmopKTtcbiAgICB9XG4gIH1cbn07XG5cbnV0aWwuYW55ID0gZnVuY3Rpb24oYXJyLCBmKSB7XG4gIHZhciBpID0gMCwgaztcbiAgZm9yIChrIGluIGFycikge1xuICAgIGlmIChmKGFycltrXSwgaywgaSsrKSkgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxudXRpbC5hbGwgPSBmdW5jdGlvbihhcnIsIGYpIHtcbiAgdmFyIGkgPSAwLCBrO1xuICBmb3IgKGsgaW4gYXJyKSB7XG4gICAgaWYgKCFmKGFycltrXSwgaywgaSsrKSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufTtcblxuXG51dGlsLmNtcCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgaWYgKGEgPCBiKSB7XG4gICAgcmV0dXJuIC0xO1xuICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgcmV0dXJuIDE7XG4gIH0gZWxzZSBpZiAoYSA+PSBiKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA9PT0gbnVsbCAmJiBiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDA7XG4gIH0gZWxzZSBpZiAoYSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAtMTtcbiAgfSBlbHNlIGlmIChiID09PSBudWxsKSB7XG4gICAgcmV0dXJuIDE7XG4gIH1cbiAgcmV0dXJuIE5hTjtcbn07XG5cbnZhciBtZXJnZSA9IGZ1bmN0aW9uKGRlc3QsIHNyYykge1xuICByZXR1cm4gdXRpbC5rZXlzKHNyYykucmVkdWNlKGZ1bmN0aW9uKGMsIGspIHtcbiAgICBjW2tdID0gc3JjW2tdO1xuICAgIHJldHVybiBjO1xuICB9LCBkZXN0KTtcbn07XG5cbnV0aWwubWVyZ2UgPSBmdW5jdGlvbigvKmRlc3QqLCBzcmMwLCBzcmMxLCAuLi4qLyl7XG4gIHZhciBkZXN0ID0gYXJndW1lbnRzWzBdO1xuICBmb3IgKHZhciBpPTEgOyBpPGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgIGRlc3QgPSBtZXJnZShkZXN0LCBhcmd1bWVudHNbaV0pO1xuICB9XG4gIHJldHVybiBkZXN0O1xufTtcblxudXRpbC5nZXRiaW5zID0gZnVuY3Rpb24oc3RhdHMsIG1heGJpbnMpIHtcbiAgcmV0dXJuIHV0aWwuYmlucyh7XG4gICAgbWluOiBzdGF0cy5taW4sXG4gICAgbWF4OiBzdGF0cy5tYXgsXG4gICAgbWF4YmluczogbWF4Ymluc1xuICB9KTtcbn07XG5cblxudXRpbC5iaW5zID0gZnVuY3Rpb24ob3B0KSB7XG4gIG9wdCA9IG9wdCB8fCB7fTtcblxuICAvLyBkZXRlcm1pbmUgcmFuZ2VcbiAgdmFyIG1heGIgPSBvcHQubWF4YmlucyB8fCAxMDI0LFxuICAgICAgYmFzZSA9IG9wdC5iYXNlIHx8IDEwLFxuICAgICAgZGl2ID0gb3B0LmRpdiB8fCBbNSwgMl0sXG4gICAgICBtaW5zID0gb3B0Lm1pbnN0ZXAgfHwgMCxcbiAgICAgIGxvZ2IgPSBNYXRoLmxvZyhiYXNlKSxcbiAgICAgIGxldmVsID0gTWF0aC5jZWlsKE1hdGgubG9nKG1heGIpIC8gbG9nYiksXG4gICAgICBtaW4gPSBvcHQubWluLFxuICAgICAgbWF4ID0gb3B0Lm1heCxcbiAgICAgIHNwYW4gPSBtYXggLSBtaW4sXG4gICAgICBzdGVwID0gTWF0aC5tYXgobWlucywgTWF0aC5wb3coYmFzZSwgTWF0aC5yb3VuZChNYXRoLmxvZyhzcGFuKSAvIGxvZ2IpIC0gbGV2ZWwpKSxcbiAgICAgIG5iaW5zID0gTWF0aC5jZWlsKHNwYW4gLyBzdGVwKSxcbiAgICAgIHByZWNpc2lvbiwgdiwgaSwgZXBzO1xuXG4gIGlmIChvcHQuc3RlcCkge1xuICAgIHN0ZXAgPSBvcHQuc3RlcDtcbiAgfSBlbHNlIGlmIChvcHQuc3RlcHMpIHtcbiAgICAvLyBpZiBwcm92aWRlZCwgbGltaXQgY2hvaWNlIHRvIGFjY2VwdGFibGUgc3RlcCBzaXplc1xuICAgIHN0ZXAgPSBvcHQuc3RlcHNbTWF0aC5taW4oXG4gICAgICAgIG9wdC5zdGVwcy5sZW5ndGggLSAxLFxuICAgICAgICB1dGlsX2Jpc2VjdExlZnQob3B0LnN0ZXBzLCBzcGFuIC8gbWF4YiwgMCwgb3B0LnN0ZXBzLmxlbmd0aClcbiAgICApXTtcbiAgfSBlbHNlIHtcbiAgICAvLyBpbmNyZWFzZSBzdGVwIHNpemUgaWYgdG9vIG1hbnkgYmluc1xuICAgIGRvIHtcbiAgICAgIHN0ZXAgKj0gYmFzZTtcbiAgICAgIG5iaW5zID0gTWF0aC5jZWlsKHNwYW4gLyBzdGVwKTtcbiAgICB9IHdoaWxlIChuYmlucyA+IG1heGIpO1xuXG4gICAgLy8gZGVjcmVhc2Ugc3RlcCBzaXplIGlmIGFsbG93ZWRcbiAgICBmb3IgKGkgPSAwOyBpIDwgZGl2Lmxlbmd0aDsgKytpKSB7XG4gICAgICB2ID0gc3RlcCAvIGRpdltpXTtcbiAgICAgIGlmICh2ID49IG1pbnMgJiYgc3BhbiAvIHYgPD0gbWF4Yikge1xuICAgICAgICBzdGVwID0gdjtcbiAgICAgICAgbmJpbnMgPSBNYXRoLmNlaWwoc3BhbiAvIHN0ZXApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHVwZGF0ZSBwcmVjaXNpb24sIG1pbiBhbmQgbWF4XG4gIHYgPSBNYXRoLmxvZyhzdGVwKTtcbiAgcHJlY2lzaW9uID0gdiA+PSAwID8gMCA6IH5+KC12IC8gbG9nYikgKyAxO1xuICBlcHMgPSAobWluPDAgPyAtMSA6IDEpICogTWF0aC5wb3coYmFzZSwgLXByZWNpc2lvbiAtIDEpO1xuICBtaW4gPSBNYXRoLm1pbihtaW4sIE1hdGguZmxvb3IobWluIC8gc3RlcCArIGVwcykgKiBzdGVwKTtcbiAgbWF4ID0gTWF0aC5jZWlsKG1heCAvIHN0ZXApICogc3RlcDtcblxuICByZXR1cm4ge1xuICAgIHN0YXJ0OiBtaW4sXG4gICAgc3RvcDogbWF4LFxuICAgIHN0ZXA6IHN0ZXAsXG4gICAgdW5pdDogcHJlY2lzaW9uXG4gIH07XG59O1xuXG5mdW5jdGlvbiB1dGlsX2Jpc2VjdExlZnQoYSwgeCwgbG8sIGhpKSB7XG4gIHdoaWxlIChsbyA8IGhpKSB7XG4gICAgdmFyIG1pZCA9IGxvICsgaGkgPj4+IDE7XG4gICAgaWYgKHV0aWwuY21wKGFbbWlkXSwgeCkgPCAwKSB7IGxvID0gbWlkICsgMTsgfVxuICAgIGVsc2UgeyBoaSA9IG1pZDsgfVxuICB9XG4gIHJldHVybiBsbztcbn1cblxuLyoqXG4gKiB4W3BbMF1dLi4uW3Bbbl1dID0gdmFsXG4gKiBAcGFyYW0gbm9hdWdtZW50IGRldGVybWluZSB3aGV0aGVyIG5ldyBvYmplY3Qgc2hvdWxkIGJlIGFkZGVkIGZcbiAqIG9yIG5vbi1leGlzdGluZyBwcm9wZXJ0aWVzIGFsb25nIHRoZSBwYXRoXG4gKi9cbnV0aWwuc2V0dGVyID0gZnVuY3Rpb24oeCwgcCwgdmFsLCBub2F1Z21lbnQpIHtcbiAgZm9yICh2YXIgaT0wOyBpPHAubGVuZ3RoLTE7ICsraSkge1xuICAgIGlmICghbm9hdWdtZW50ICYmICEocFtpXSBpbiB4KSl7XG4gICAgICB4ID0geFtwW2ldXSA9IHt9O1xuICAgIH0gZWxzZSB7XG4gICAgICB4ID0geFtwW2ldXTtcbiAgICB9XG4gIH1cbiAgeFtwW2ldXSA9IHZhbDtcbn07XG5cblxuLyoqXG4gKiByZXR1cm5zIHhbcFswXV0uLi5bcFtuXV1cbiAqIEBwYXJhbSBhdWdtZW50IGRldGVybWluZSB3aGV0aGVyIG5ldyBvYmplY3Qgc2hvdWxkIGJlIGFkZGVkIGZcbiAqIG9yIG5vbi1leGlzdGluZyBwcm9wZXJ0aWVzIGFsb25nIHRoZSBwYXRoXG4gKi9cbnV0aWwuZ2V0dGVyID0gZnVuY3Rpb24oeCwgcCwgbm9hdWdtZW50KSB7XG4gIGZvciAodmFyIGk9MDsgaTxwLmxlbmd0aDsgKytpKSB7XG4gICAgaWYgKCFub2F1Z21lbnQgJiYgIShwW2ldIGluIHgpKXtcbiAgICAgIHggPSB4W3BbaV1dID0ge307XG4gICAgfSBlbHNlIHtcbiAgICAgIHggPSB4W3BbaV1dO1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn07XG5cbnV0aWwudHJ1bmNhdGUgPSBmdW5jdGlvbihzLCBsZW5ndGgsIHBvcywgd29yZCwgZWxsaXBzaXMpIHtcbiAgdmFyIGxlbiA9IHMubGVuZ3RoO1xuICBpZiAobGVuIDw9IGxlbmd0aCkgcmV0dXJuIHM7XG4gIGVsbGlwc2lzID0gZWxsaXBzaXMgfHwgXCIuLi5cIjtcbiAgdmFyIGwgPSBNYXRoLm1heCgwLCBsZW5ndGggLSBlbGxpcHNpcy5sZW5ndGgpO1xuXG4gIHN3aXRjaCAocG9zKSB7XG4gICAgY2FzZSBcImxlZnRcIjpcbiAgICAgIHJldHVybiBlbGxpcHNpcyArICh3b3JkID8gdmdfdHJ1bmNhdGVPbldvcmQocyxsLDEpIDogcy5zbGljZShsZW4tbCkpO1xuICAgIGNhc2UgXCJtaWRkbGVcIjpcbiAgICBjYXNlIFwiY2VudGVyXCI6XG4gICAgICB2YXIgbDEgPSBNYXRoLmNlaWwobC8yKSwgbDIgPSBNYXRoLmZsb29yKGwvMik7XG4gICAgICByZXR1cm4gKHdvcmQgPyB2Z190cnVuY2F0ZU9uV29yZChzLGwxKSA6IHMuc2xpY2UoMCxsMSkpICsgZWxsaXBzaXMgK1xuICAgICAgICAod29yZCA/IHZnX3RydW5jYXRlT25Xb3JkKHMsbDIsMSkgOiBzLnNsaWNlKGxlbi1sMikpO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gKHdvcmQgPyB2Z190cnVuY2F0ZU9uV29yZChzLGwpIDogcy5zbGljZSgwLGwpKSArIGVsbGlwc2lzO1xuICB9XG59O1xuXG5mdW5jdGlvbiB2Z190cnVuY2F0ZU9uV29yZChzLCBsZW4sIHJldikge1xuICB2YXIgY250ID0gMCwgdG9rID0gcy5zcGxpdCh2Z190cnVuY2F0ZV93b3JkX3JlKTtcbiAgaWYgKHJldikge1xuICAgIHMgPSAodG9rID0gdG9rLnJldmVyc2UoKSlcbiAgICAgIC5maWx0ZXIoZnVuY3Rpb24odykgeyBjbnQgKz0gdy5sZW5ndGg7IHJldHVybiBjbnQgPD0gbGVuOyB9KVxuICAgICAgLnJldmVyc2UoKTtcbiAgfSBlbHNlIHtcbiAgICBzID0gdG9rLmZpbHRlcihmdW5jdGlvbih3KSB7IGNudCArPSB3Lmxlbmd0aDsgcmV0dXJuIGNudCA8PSBsZW47IH0pO1xuICB9XG4gIHJldHVybiBzLmxlbmd0aCA/IHMuam9pbihcIlwiKS50cmltKCkgOiB0b2tbMF0uc2xpY2UoMCwgbGVuKTtcbn1cblxudmFyIHZnX3RydW5jYXRlX3dvcmRfcmUgPSAvKFtcXHUwMDA5XFx1MDAwQVxcdTAwMEJcXHUwMDBDXFx1MDAwRFxcdTAwMjBcXHUwMEEwXFx1MTY4MFxcdTE4MEVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwQVxcdTIwMkZcXHUyMDVGXFx1MjAyOFxcdTIwMjlcXHUzMDAwXFx1RkVGRl0pLztcblxuXG51dGlsLmVycm9yID0gZnVuY3Rpb24obXNnKSB7XG4gIGNvbnNvbGUuZXJyb3IoJ1tWTCBFcnJvcl0nLCBtc2cpO1xufTtcblxuIl19\n","'use strict';\n\nvar globals = require('./globals'),\n  consts = require('./consts'),\n  util = require('./util'),\n  vlfield = require('./field'),\n  vlenc = require('./enc'),\n  schema = require('./schema/schema'),\n  time = require('./compile/time');\n\nvar Encoding = module.exports = (function() {\n\n  function Encoding(marktype, enc, data, config, filter, theme) {\n    var defaults = schema.instantiate();\n\n    var spec = {\n      data: data,\n      marktype: marktype,\n      enc: enc,\n      config: config,\n      filter: filter || []\n    };\n\n    // type to bitcode\n    for (var e in defaults.enc) {\n      defaults.enc[e].type = consts.dataTypes[defaults.enc[e].type];\n    }\n\n    var specExtended = schema.util.merge(defaults, theme || {}, spec) ;\n\n    this._data = specExtended.data;\n    this._marktype = specExtended.marktype;\n    this._enc = specExtended.enc;\n    this._config = specExtended.config;\n    this._filter = specExtended.filter;\n  }\n\n  var proto = Encoding.prototype;\n\n  proto.marktype = function() {\n    return this._marktype;\n  };\n\n  proto.is = function(m) {\n    return this._marktype === m;\n  };\n\n  proto.has = function(encType) {\n    // equivalent to calling vlenc.has(this._enc, encType)\n    return this._enc[encType].name !== undefined;\n  };\n\n  proto.enc = function(et) {\n    return this._enc[et];\n  };\n\n  proto.filter = function() {\n    var filterNull = [],\n      fields = this.fields(),\n      self = this;\n\n    util.forEach(fields, function(fieldList, fieldName) {\n      if (fieldName === '*') return; //count\n\n      if ((self.config('filterNull').Q && fieldList.containsType[Q]) ||\n          (self.config('filterNull').T && fieldList.containsType[T]) ||\n          (self.config('filterNull').O && fieldList.containsType[O])) {\n        filterNull.push({\n          operands: [fieldName],\n          operator: 'notNull'\n        });\n      }\n    });\n\n    return filterNull.concat(this._filter);\n  };\n\n  // get \"field\" property for vega\n  proto.field = function(et, nodata, nofn) {\n    if (!this.has(et)) return null;\n\n    var f = (nodata ? '' : 'data.');\n\n    if (this._enc[et].aggr === 'count') {\n      return f + 'count';\n    } else if (!nofn && this._enc[et].bin) {\n      return f + 'bin_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].aggr) {\n      return f + this._enc[et].aggr + '_' + this._enc[et].name;\n    } else if (!nofn && this._enc[et].fn) {\n      return f + this._enc[et].fn + '_' + this._enc[et].name;\n    } else {\n      return f + this._enc[et].name;\n    }\n  };\n\n  proto.fieldName = function(et) {\n    return this._enc[et].name;\n  };\n\n  /*\n   * return key-value pairs of field name and list of fields of that field name\n   */\n  proto.fields = function() {\n    return vlenc.fields(this._enc);\n  };\n\n  proto.fieldTitle = function(et) {\n    if (vlfield.isCount(this._enc[et])) {\n      return vlfield.count.displayName;\n    }\n    var fn = this._enc[et].aggr || this._enc[et].fn || (this._enc[et].bin && \"bin\");\n    if (fn) {\n      return fn.toUpperCase() + '(' + this._enc[et].name + ')';\n    } else {\n      return this._enc[et].name;\n    }\n  };\n\n  proto.scale = function(et) {\n    return this._enc[et].scale || {};\n  };\n\n  proto.axis = function(et) {\n    return this._enc[et].axis || {};\n  };\n\n  proto.band = function(et) {\n    return this._enc[et].band || {};\n  };\n\n  proto.bandSize = function(encType, useSmallBand) {\n    useSmallBand = useSmallBand ||\n      //isBandInSmallMultiples\n      (encType === Y && this.has(ROW) && this.has(Y)) ||\n      (encType === X && this.has(COL) && this.has(X));\n\n    // if band.size is explicitly specified, follow the specification, otherwise draw value from config.\n    return this.band(encType).size ||\n      this.config(useSmallBand ? 'smallBandSize' : 'largeBandSize');\n  };\n\n  proto.aggr = function(et) {\n    return this._enc[et].aggr;\n  };\n\n  // returns false if binning is disabled, otherwise an object with binning properties\n  proto.bin = function(et) {\n    var bin = this._enc[et].bin;\n    if (bin === {})\n      return false;\n    if (bin === true)\n      return {\n        maxbins: schema.MAXBINS_DEFAULT\n      };\n    return bin;\n  };\n\n  proto.legend = function(et) {\n    return this._enc[et].legend;\n  };\n\n  proto.value = function(et) {\n    return this._enc[et].value;\n  };\n\n  proto.fn = function(et) {\n    return this._enc[et].fn;\n  };\n\n  proto.sort = function(et, stats) {\n    var sort = this._enc[et].sort,\n      enc = this._enc,\n      isType = vlfield.isType.byCode;\n\n    // console.log('sort:', sort, 'support:', Encoding.toggleSort.support({enc:this._enc}, stats) , 'toggle:', this.config('toggleSort'))\n\n    if ((!sort || sort.length===0) &&\n        Encoding.toggleSort.support({enc:this._enc}, stats, true) && //HACK\n        this.config('toggleSort') === 'Q'\n      ) {\n      var qField = isType(enc.x, O) ? enc.y : enc.x;\n\n      if (isType(enc[et], O)) {\n        sort = [{\n          name: qField.name,\n          aggr: qField.aggr,\n          type: qField.type,\n          reverse: true\n        }];\n      }\n    }\n\n    return sort;\n  };\n\n  proto.any = function(f) {\n    return util.any(this._enc, f);\n  };\n\n  proto.all = function(f) {\n    return util.all(this._enc, f);\n  };\n\n  proto.length = function() {\n    return util.keys(this._enc).length;\n  };\n\n  proto.map = function(f) {\n    return vlenc.map(this._enc, f);\n  };\n\n  proto.reduce = function(f, init) {\n    return vlenc.reduce(this._enc, f, init);\n  };\n\n  proto.forEach = function(f) {\n    return vlenc.forEach(this._enc, f);\n  };\n\n  proto.type = function(et) {\n    return this.has(et) ? this._enc[et].type : null;\n  };\n\n  proto.role = function(et) {\n    return this.has(et) ? vlfield.role(this._enc[et]) : null;\n  };\n\n  proto.text = function(prop) {\n    var text = this._enc[TEXT].text;\n    return prop ? text[prop] : text;\n  };\n\n  proto.font = function(prop) {\n    var font = this._enc[TEXT].font;\n    return prop ? font[prop] : font;\n  };\n\n  proto.isType = function(et, type) {\n    var field = this.enc(et);\n    return field && Encoding.isType(field, type);\n  };\n\n  Encoding.isType = function (fieldDef, type) {\n    // FIXME vlfield.isType\n    return (fieldDef.type & type) > 0;\n  };\n\n  Encoding.isOrdinalScale = function(encoding, encType) {\n    return vlfield.isOrdinalScale(encoding.enc(encType), true);\n  };\n\n  Encoding.isDimension = function(encoding, encType) {\n    return vlfield.isDimension(encoding.enc(encType), true);\n  };\n\n  Encoding.isMeasure = function(encoding, encType) {\n    return vlfield.isMeasure(encoding.enc(encType), true);\n  };\n\n  proto.isOrdinalScale = function(encType) {\n    return this.has(encType) && Encoding.isOrdinalScale(this, encType);\n  };\n\n  proto.isDimension = function(encType) {\n    return this.has(encType) && Encoding.isDimension(this, encType);\n  };\n\n  proto.isMeasure = function(encType) {\n    return this.has(encType) && Encoding.isMeasure(this, encType);\n  };\n\n  proto.isAggregate = function() {\n    return vlenc.isAggregate(this._enc);\n  };\n\n  Encoding.isAggregate = function(spec) {\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.alwaysNoOcclusion = function(spec, stats) {\n    // FIXME raw OxQ with # of rows = # of O\n    return vlenc.isAggregate(spec.enc);\n  };\n\n  Encoding.isStack = function(spec) {\n    // FIXME update this once we have control for stack ...\n    return (spec.marktype === 'bar' || spec.marktype === 'area') &&\n      spec.enc.color;\n  };\n\n  proto.isStack = function() {\n    // FIXME update this once we have control for stack ...\n    return (this.is('bar') || this.is('area')) && this.has('color');\n  };\n\n  proto.cardinality = function(encType, stats) {\n    return vlfield.cardinality(this.enc(encType), stats, this.config('filterNull'), true);\n  };\n\n  proto.isRaw = function() {\n    return !this.isAggregate();\n  };\n\n  proto.data = function(name) {\n    return this._data[name];\n  };\n\n  proto.config = function(name) {\n    return this._config[name];\n  };\n\n  proto.toSpec = function(excludeConfig) {\n    var enc = util.duplicate(this._enc),\n      spec;\n\n    // convert type's bitcode to type name\n    for (var e in enc) {\n      enc[e].type = consts.dataTypeNames[enc[e].type];\n    }\n\n    spec = {\n      marktype: this._marktype,\n      enc: enc,\n      filter: this._filter\n    };\n\n    if (!excludeConfig) {\n      spec.config = util.duplicate(this._config);\n    }\n\n    // remove defaults\n    var defaults = schema.instantiate();\n    return schema.util.subtract(spec, defaults);\n  };\n\n  proto.toShorthand = function() {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + this._marktype +\n      c.delim + vlenc.shorthand(this._enc);\n  };\n\n  Encoding.shorthand = function (spec) {\n    var c = consts.shorthand;\n    return 'mark' + c.assign + spec.marktype +\n      c.delim + vlenc.shorthand(spec.enc);\n  };\n\n  Encoding.fromShorthand = function(shorthand, data, config, theme) {\n    var c = consts.shorthand,\n        split = shorthand.split(c.delim),\n        marktype = split.shift().split(c.assign)[1].trim(),\n        enc = vlenc.fromShorthand(split, true);\n\n    return new Encoding(marktype, enc, data, config, null, theme);\n  };\n\n  Encoding.specFromShorthand = function(shorthand, data, config, excludeConfig) {\n    return Encoding.fromShorthand(shorthand, data, config).toSpec(excludeConfig);\n  };\n\n  Encoding.fromSpec = function(spec, theme) {\n    var enc = util.duplicate(spec.enc || {});\n\n    //convert type from string to bitcode (e.g, O=1)\n    for (var e in enc) {\n      enc[e].type = consts.dataTypes[enc[e].type];\n    }\n\n    return new Encoding(spec.marktype, enc, spec.data, spec.config, spec.filter, theme);\n  };\n\n  Encoding.transpose = function(spec) {\n    var oldenc = spec.enc,\n      enc = util.duplicate(spec.enc);\n    enc.x = oldenc.y;\n    enc.y = oldenc.x;\n    enc.row = oldenc.col;\n    enc.col = oldenc.row;\n    spec.enc = enc;\n    return spec;\n  };\n\n  Encoding.toggleSort = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.toggleSort = spec.config.toggleSort === 'Q' ? 'O' :'Q';\n    return spec;\n  };\n\n\n  Encoding.toggleSort.direction = function(spec, useTypeCode) {\n    if (!Encoding.toggleSort.support(spec, useTypeCode)) { return; }\n    var enc = spec.enc;\n    return enc.x.type === 'O' ? 'x' :  'y';\n  };\n\n  Encoding.toggleSort.mode = function(spec) {\n    return spec.config.toggleSort;\n  };\n\n  Encoding.toggleSort.support = function(spec, stats, useTypeCode) {\n    var enc = spec.enc,\n      isType = vlfield.isType.get(useTypeCode);\n\n    if (vlenc.has(enc, ROW) || vlenc.has(enc, COL) ||\n      !vlenc.has(enc, X) || !vlenc.has(enc, Y) ||\n      !Encoding.alwaysNoOcclusion(spec, stats)) {\n      return false;\n    }\n\n    return ( isType(enc.x, O) && vlfield.isMeasure(enc.y, useTypeCode)) ? 'x' :\n      ( isType(enc.y, O) && vlfield.isMeasure(enc.x, useTypeCode)) ? 'y' : false;\n  };\n\n  Encoding.toggleFilterNullO = function(spec) {\n    spec.config = spec.config || {};\n    spec.config.filterNull = spec.config.filterNull || { //FIXME\n      T: true,\n      Q: true\n    };\n    spec.config.filterNull.O = !spec.config.filterNull.O;\n    return spec;\n  };\n\n  Encoding.toggleFilterNullO.support = function(spec, stats) {\n    var fields = vlenc.fields(spec.enc);\n    for (var fieldName in fields) {\n      var fieldList = fields[fieldName];\n      if (fieldList.containsType.O && fieldName in stats && stats[fieldName].numNulls > 0) {\n        return true;\n      }\n    }\n    return false;\n  };\n\n  return Encoding;\n})();\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = aggregates;\n\nfunction aggregates(spec, encoding, opt) {\n  opt = opt || {};\n\n  var dims = {}, meas = {}, detail = {}, facets = {},\n    data = spec.data[1]; // currently data[0] is raw and data[1] is table\n\n  encoding.forEach(function(field, encType) {\n    if (field.aggr) {\n      if (field.aggr === 'count') {\n        meas.count = {op: 'count', field: '*'};\n      }else {\n        meas[field.aggr + '|'+ field.name] = {\n          op: field.aggr,\n          field: 'data.'+ field.name\n        };\n      }\n    } else {\n      dims[field.name] = encoding.field(encType);\n      if (encType == ROW || encType == COL) {\n        facets[field.name] = dims[field.name];\n      }else if (encType !== X && encType !== Y) {\n        detail[field.name] = dims[field.name];\n      }\n    }\n  });\n  dims = util.vals(dims);\n  meas = util.vals(meas);\n\n  if (meas.length > 0 && !opt.preaggregatedData) {\n    if (!data.transform) data.transform = [];\n    data.transform.push({\n      type: 'aggregate',\n      groupby: dims,\n      fields: meas\n    });\n  }\n  return {\n    details: util.vals(detail),\n    dims: dims,\n    facets: util.vals(facets),\n    aggregated: meas.length > 0\n  };\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  getter = util.getter,\n  time = require('./time');\n\nvar axis = module.exports = {};\n\naxis.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    var s = props[x].scale;\n    if (s === X || s === Y) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\naxis.defs = function(names, encoding, layout, stats, opt) {\n  return names.reduce(function(a, name) {\n    a.push(axis.def(name, encoding, layout, stats, opt));\n    return a;\n  }, []);\n};\n\naxis.def = function(name, encoding, layout, stats, opt) {\n  var type = name;\n  var isCol = name == COL, isRow = name == ROW;\n  var rowOffset = axisTitleOffset(encoding, layout, Y) + 20,\n    cellPadding = layout.cellPadding;\n\n\n  if (isCol) type = 'x';\n  if (isRow) type = 'y';\n\n  var def = {\n    type: type,\n    scale: name\n  };\n\n  if (encoding.axis(name).grid) {\n    def.grid = true;\n    def.layer = (isRow || isCol) ? 'front' :  'back';\n\n    if (isCol) {\n      // set grid property -- put the lines on the right the cell\n      setter(def, ['properties', 'grid'], {\n        x: {\n          offset: layout.cellWidth * (1+ cellPadding/2.0),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'col'\n        },\n        y: {\n          value: -layout.cellHeight * (cellPadding/2),\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else if (isRow) {\n      // set grid property -- put the lines on the top\n      setter(def, ['properties', 'grid'], {\n        y: {\n          offset: -layout.cellHeight * (cellPadding/2),\n          // default value(s) -- vega doesn't do recursive merge\n          scale: 'row'\n        },\n        x: {\n          value: rowOffset\n        },\n        x2: {\n          offset: rowOffset + (layout.cellWidth * 0.05),\n          // default value(s) -- vega doesn't do recursive merge\n          group: \"mark.group.width\",\n          mult: 1\n        },\n        stroke: { value: encoding.config('cellGridColor') }\n      });\n    } else {\n      setter(def, ['properties', 'grid', 'stroke'], {\n        value: encoding.config('gridColor')\n      });\n    }\n  }\n\n  if (encoding.axis(name).title) {\n    def = axis_title(def, name, encoding, layout, opt);\n  }\n\n  if (isRow || isCol) {\n    setter(def, ['properties', 'ticks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'majorTicks'], {\n      opacity: {value: 0}\n    });\n    setter(def, ['properties', 'axis'], {\n      opacity: {value: 0}\n    });\n  }\n\n  if (isCol) {\n    def.orient = 'top';\n  }\n\n  if (isRow) {\n    def.offset = rowOffset;\n  }\n\n  if (name == X) {\n    if (encoding.has(Y) && encoding.isOrdinalScale(Y) && encoding.cardinality(Y, stats) > 30) {\n      def.orient = 'top';\n    }\n\n    if (encoding.isDimension(X) || encoding.isType(X, T)) {\n      setter(def, ['properties','labels'], {\n        angle: {value: 270},\n        align: {value: 'right'},\n        baseline: {value: 'middle'}\n      });\n    } else { // Q\n      def.ticks = 5;\n    }\n  }\n\n  def = axis_labels(def, name, encoding, layout, opt);\n\n  return def;\n};\n\nfunction axis_title(def, name, encoding, layout, opt) {\n  var maxlength = null,\n    fieldTitle = encoding.fieldTitle(name);\n  if (name===X) {\n    maxlength = layout.cellWidth / encoding.config('characterWidth');\n  } else if (name === Y) {\n    maxlength = layout.cellHeight / encoding.config('characterWidth');\n  }\n\n  def.title = maxlength ? util.truncate(fieldTitle, maxlength) : fieldTitle;\n\n  if (name === ROW) {\n    setter(def, ['properties','title'], {\n      angle: {value: 0},\n      align: {value: 'right'},\n      baseline: {value: 'middle'},\n      dy: {value: (-layout.height/2) -20}\n    });\n  }\n\n  def.titleOffset = axisTitleOffset(encoding, layout, name);\n  return def;\n}\n\nfunction axis_labels(def, name, encoding, layout, opt) {\n  var fn;\n  // add custom label for time type\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) && (time.hasScale(fn))) {\n    setter(def, ['properties','labels','text','scale'], 'time-'+ fn);\n  }\n\n  var textTemplatePath = ['properties','labels','text','template'];\n  if (encoding.axis(name).format) {\n    def.format = encoding.axis(name).format;\n  } else if (encoding.isType(name, Q)) {\n    setter(def, textTemplatePath, \"{{data | number:'.3s'}}\");\n  } else if (encoding.isType(name, T) && !encoding.fn(name)) {\n    setter(def, textTemplatePath, \"{{data | time:'%Y-%m-%d'}}\");\n  } else if (encoding.isType(name, T) && encoding.fn(name) === 'year') {\n    setter(def, textTemplatePath, \"{{data | number:'d'}}\");\n  } else if (encoding.isType(name, O) && encoding.axis(name).maxLabelLength) {\n    setter(def, textTemplatePath, '{{data | truncate:' + encoding.axis(name).maxLabelLength + '}}');\n  }\n\n  return def;\n}\n\nfunction axisTitleOffset(encoding, layout, name) {\n  var value = encoding.axis(name).titleOffset;\n  if (value) {\n    return value;\n  }\n  switch (name) {\n    case ROW: return 0;\n    case COL: return 35;\n  }\n  return getter(layout, [name, 'axisTitleOffset']);\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = binning;\n\nfunction binning(spec, encoding, opt) {\n  opt = opt || {};\n  var bins = {};\n\n  if (opt.preaggregatedData) {\n    return;\n  }\n\n  if (!spec.transform) spec.transform = [];\n\n  encoding.forEach(function(field, encType) {\n    if (encoding.bin(encType)) {\n      spec.transform.push({\n        type: 'bin',\n        field: 'data.' + field.name,\n        output: 'data.bin_' + field.name,\n        maxbins: encoding.bin(encType).maxbins\n      });\n    }\n  });\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = compile;\n\nvar Encoding = require('../Encoding'),\n  template = compile.template = require('./template'),\n  axis = compile.axis = require('./axis'),\n  filter = compile.filter = require('./filter'),\n  legend = compile.legend = require('./legend'),\n  marks = compile.marks = require('./marks'),\n  scale = compile.scale = require('./scale'),\n  vlsort = compile.sort = require('./sort'),\n  vlstyle = compile.style = require('./style'),\n  time = compile.time = require('./time'),\n  aggregate = compile.aggregate = require('./aggregate'),\n  bin = compile.bin = require('./bin'),\n  facet = compile.facet = require('./facet'),\n  vlstack = compile.stack = require('./stack'),\n  subfacet = compile.subfacet = require('./subfacet');\n\ncompile.layout = require('./layout');\ncompile.group = require('./group');\n\nfunction compile(spec, stats, theme) {\n  return compile.encoding(Encoding.fromSpec(spec, theme), stats);\n}\n\ncompile.shorthand = function (shorthand, stats, config, theme) {\n  return compile.encoding(Encoding.fromShorthand(shorthand, config, theme), stats);\n};\n\ncompile.encoding = function (encoding, stats) {\n  var layout = compile.layout(encoding, stats),\n    style = vlstyle(encoding, stats),\n    spec = template(encoding, layout, stats),\n    group = spec.marks[0],\n    mark = marks[encoding.marktype()],\n    mdefs = marks.def(mark, encoding, layout, style),\n    mdef = mdefs[0];  // TODO: remove this dirty hack by refactoring the whole flow\n\n  filter.addFilters(spec, encoding);\n  var sorting = vlsort(spec, encoding, stats);\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  var preaggregatedData = !!encoding.data('vegaServer');\n\n  for (var i = 0; i < mdefs.length; i++) {\n    group.marks.push(mdefs[i]);\n  }\n\n  bin(spec.data[1], encoding, {preaggregatedData: preaggregatedData});\n\n  var lineType = marks[encoding.marktype()].line;\n\n  if (!preaggregatedData) {\n    spec = time(spec, encoding);\n  }\n\n  // handle subfacets\n  var aggResult = aggregate(spec, encoding, {preaggregatedData: preaggregatedData}),\n    details = aggResult.details,\n    hasDetails = details && details.length > 0,\n    stack = hasDetails && vlstack(spec, encoding, mdef, aggResult.facets);\n\n  if (hasDetails && (stack || lineType)) {\n    //subfacet to group stack / line together in one group\n    subfacet(group, mdef, details, stack, encoding);\n  }\n\n  // auto-sort line/area values\n  //TODO(kanitw): have some config to turn off auto-sort for line (for line chart that encodes temporal information)\n  if (lineType) {\n    var f = (encoding.isMeasure(X) && encoding.isDimension(Y)) ? Y : X;\n    if (!mdef.from) mdef.from = {};\n    // TODO: why - ?\n    mdef.from.transform = [{type: 'sort', by: '-' + encoding.field(f)}];\n  }\n\n  // Small Multiples\n  if (hasRow || hasCol) {\n    spec = facet(group, encoding, layout, style, sorting, spec, mdef, stack, stats);\n    spec.legends = legend.defs(encoding);\n  } else {\n    group.scales = scale.defs(scale.names(mdef.properties.update), encoding, layout, style, sorting,\n      {stack: stack, stats: stats});\n    group.axes = axis.defs(axis.names(mdef.properties.update), encoding, layout, stats);\n    group.legends = legend.defs(encoding);\n  }\n\n  filter.filterLessThanZero(spec, encoding);\n\n  return spec;\n};\n\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nvar axis = require('./axis'),\n  groupdef = require('./group').def,\n  scale = require('./scale');\n\nmodule.exports = faceting;\n\nfunction faceting(group, encoding, layout, style, sorting, spec, mdef, stack, stats) {\n  var enter = group.properties.enter;\n  var facetKeys = [], cellAxes = [], from, axesGrp;\n\n  var hasRow = encoding.has(ROW), hasCol = encoding.has(COL);\n\n  enter.fill = {value: encoding.config('cellBackgroundColor')};\n\n  //move \"from\" to cell level and add facet transform\n  group.from = {data: group.marks[0].from.data};\n\n  // Hack, this needs to be refactored\n  for (var i = 0; i < group.marks.length; i++) {\n    var mark = group.marks[i];\n    if (mark.from.transform) {\n      delete mark.from.data; //need to keep transform for subfacetting case\n    } else {\n      delete mark.from;\n    }\n  }\n\n  if (hasRow) {\n    if (!encoding.isDimension(ROW)) {\n      util.error('Row encoding should be ordinal.');\n    }\n    enter.y = {scale: ROW, field: 'keys.' + facetKeys.length};\n    enter.height = {'value': layout.cellHeight}; // HACK\n\n    facetKeys.push(encoding.field(ROW));\n\n    if (hasCol) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(COL)]});\n    }\n\n    axesGrp = groupdef('x-axes', {\n        axes: encoding.has(X) ? axis.defs(['x'], encoding, layout, stats) : undefined,\n        x: hasCol ? {scale: COL, field: 'keys.0'} : {value: 0},\n        width: hasCol && {'value': layout.cellWidth}, //HACK?\n        from: from\n      });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['row'], encoding, layout, stats));\n  } else { // doesn't have row\n    if (encoding.has(X)) {\n      //keep x axis in the cell\n      cellAxes.push.apply(cellAxes, axis.defs(['x'], encoding, layout, stats));\n    }\n  }\n\n  if (hasCol) {\n    if (!encoding.isDimension(COL)) {\n      util.error('Col encoding should be ordinal.');\n    }\n    enter.x = {scale: COL, field: 'keys.' + facetKeys.length};\n    enter.width = {'value': layout.cellWidth}; // HACK\n\n    facetKeys.push(encoding.field(COL));\n\n    if (hasRow) {\n      from = util.duplicate(group.from);\n      from.transform = from.transform || [];\n      from.transform.unshift({type: 'facet', keys: [encoding.field(ROW)]});\n    }\n\n    axesGrp = groupdef('y-axes', {\n      axes: encoding.has(Y) ? axis.defs(['y'], encoding, layout, stats) : undefined,\n      y: hasRow && {scale: ROW, field: 'keys.0'},\n      x: hasRow && {value: 0},\n      height: hasRow && {'value': layout.cellHeight}, //HACK?\n      from: from\n    });\n\n    spec.marks.unshift(axesGrp); // need to prepend so it appears under the plots\n    (spec.axes = spec.axes || []);\n    spec.axes.push.apply(spec.axes, axis.defs(['col'], encoding, layout, stats));\n  } else { // doesn't have col\n    if (encoding.has(Y)) {\n      cellAxes.push.apply(cellAxes, axis.defs(['y'], encoding, layout, stats));\n    }\n  }\n\n  // assuming equal cellWidth here\n  // TODO: support heterogenous cellWidth (maybe by using multiple scales?)\n  spec.scales = (spec.scales || []).concat(scale.defs(\n    scale.names(enter).concat(scale.names(mdef.properties.update)),\n    encoding,\n    layout,\n    style,\n    sorting,\n    {stack: stack, facet: true, stats: stats}\n  )); // row/col scales + cell scales\n\n  if (cellAxes.length > 0) {\n    group.axes = cellAxes;\n  }\n\n  // add facet transform\n  var trans = (group.from.transform || (group.from.transform = []));\n  trans.unshift({type: 'facet', keys: facetKeys});\n\n  return spec;\n}\n","'use strict';\n\nvar globals = require('../globals');\n\nvar filter = module.exports = {};\n\nvar BINARY = {\n  '>':  true,\n  '>=': true,\n  '=':  true,\n  '!=': true,\n  '<':  true,\n  '<=': true\n};\n\nfilter.addFilters = function(spec, encoding) {\n  var filters = encoding.filter(),\n    data = spec.data[0];  // apply filters to raw data before aggregation\n\n  if (!data.transform)\n    data.transform = [];\n\n  // add custom filters\n  for (var i in filters) {\n    var filter = filters[i];\n\n    var condition = '';\n    var operator = filter.operator;\n    var operands = filter.operands;\n\n    if (BINARY[operator]) {\n      // expects a field and a value\n      if (operator === '=') {\n        operator = '==';\n      }\n\n      var op1 = operands[0];\n      var op2 = operands[1];\n      condition = 'd.data.' + op1 + operator + op2;\n    } else if (operator === 'notNull') {\n      // expects a number of fields\n      for (var j in operands) {\n        condition += 'd.data.' + operands[j] + '!==null';\n        if (j < operands.length - 1) {\n          condition += ' && ';\n        }\n      }\n    } else {\n      console.warn('Unsupported operator: ', operator);\n    }\n\n    data.transform.push({\n      type: 'filter',\n      test: condition\n    });\n  }\n};\n\n// remove less than 0 values if we use log function\nfilter.filterLessThanZero = function(spec, encoding) {\n  encoding.forEach(function(field, encType) {\n    if (encoding.scale(encType).type === 'log') {\n      spec.data[1].transform.push({\n        type: 'filter',\n        test: 'd.' + encoding.field(encType) + '>0'\n      });\n    }\n  });\n};\n\n","'use strict';\n\nmodule.exports = {\n  def: groupdef\n};\n\nfunction groupdef(name, opt) {\n  opt = opt || {};\n  return {\n    _name: name || undefined,\n    type: 'group',\n    from: opt.from,\n    properties: {\n      enter: {\n        x: opt.x || undefined,\n        y: opt.y || undefined,\n        width: opt.width || {group: 'width'},\n        height: opt.height || {group: 'height'}\n      }\n    },\n    scales: opt.scales || undefined,\n    axes: opt.axes || undefined,\n    marks: opt.marks || []\n  };\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  setter = util.setter,\n  schema = require('../schema/schema'),\n  time = require('./time'),\n  vlfield = require('../field');\n\nmodule.exports = vllayout;\n\nfunction vllayout(encoding, stats) {\n  var layout = box(encoding, stats);\n  layout = offset(encoding, stats, layout);\n  return layout;\n}\n\n/*\n  HACK to set chart size\n  NOTE: this fails for plots driven by derived values (e.g., aggregates)\n  One solution is to update Vega to support auto-sizing\n  In the meantime, auto-padding (mostly) does the trick\n */\nfunction box(encoding, stats) {\n  var hasRow = encoding.has(ROW),\n      hasCol = encoding.has(COL),\n      hasX = encoding.has(X),\n      hasY = encoding.has(Y),\n      marktype = encoding.marktype();\n\n  // FIXME/HACK we need to take filter into account\n  var xCardinality = hasX && encoding.isDimension(X) ? encoding.cardinality(X, stats) : 1,\n    yCardinality = hasY && encoding.isDimension(Y) ? encoding.cardinality(Y, stats) : 1;\n\n  var useSmallBand = xCardinality > encoding.config('largeBandMaxCardinality') ||\n    yCardinality > encoding.config('largeBandMaxCardinality');\n\n  var cellWidth, cellHeight, cellPadding = encoding.config('cellPadding');\n\n  // set cellWidth\n  if (hasX) {\n    if (encoding.isOrdinalScale(X)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellWidth = (xCardinality + encoding.band(X).padding) * encoding.bandSize(X, useSmallBand);\n    } else {\n      cellWidth = hasCol || hasRow ? encoding.enc(COL).width :  encoding.config(\"singleWidth\");\n    }\n  } else {\n    if (marktype === TEXT) {\n      cellWidth = encoding.config('textCellWidth');\n    } else {\n      cellWidth = encoding.bandSize(X);\n    }\n  }\n\n  // set cellHeight\n  if (hasY) {\n    if (encoding.isOrdinalScale(Y)) {\n      // for ordinal, hasCol or not doesn't matter -- we scale based on cardinality\n      cellHeight = (yCardinality + encoding.band(Y).padding) * encoding.bandSize(Y, useSmallBand);\n    } else {\n      cellHeight = hasCol || hasRow ? encoding.enc(ROW).height :  encoding.config(\"singleHeight\");\n    }\n  } else {\n    cellHeight = encoding.bandSize(Y);\n  }\n\n  // Cell bands use rangeBands(). There are n-1 padding.  Outerpadding = 0 for cells\n\n  var width = cellWidth, height = cellHeight;\n  if (hasCol) {\n    var colCardinality = encoding.cardinality(COL, stats);\n    width = cellWidth * ((1 + cellPadding) * (colCardinality - 1) + 1);\n  }\n  if (hasRow) {\n    var rowCardinality =  encoding.cardinality(ROW, stats);\n    height = cellHeight * ((1 + cellPadding) * (rowCardinality - 1) + 1);\n  }\n\n  return {\n    // width and height of the whole cell\n    cellWidth: cellWidth,\n    cellHeight: cellHeight,\n    cellPadding: cellPadding,\n    // width and height of the chart\n    width: width,\n    height: height,\n    // information about x and y, such as band size\n    x: {useSmallBand: useSmallBand},\n    y: {useSmallBand: useSmallBand}\n  };\n}\n\nfunction offset(encoding, stats, layout) {\n  [X, Y].forEach(function (x) {\n    var maxLength;\n    if (encoding.isDimension(x) || encoding.isType(x, T)) {\n      maxLength = stats[encoding.fieldName(x)].maxlength;\n    } else if (encoding.aggr(x) === 'count') {\n      //assign default value for count as it won't have stats\n      maxLength =  3;\n    } else if (encoding.isType(x, Q)) {\n      if (x===X) {\n        maxLength = 3;\n      } else { // Y\n        //assume that default formating is always shorter than 7\n        maxLength = Math.min(stats[encoding.fieldName(x)].maxlength, 7);\n      }\n    }\n    setter(layout,[x, 'axisTitleOffset'], encoding.config('characterWidth') *  maxLength + 20);\n  });\n  return layout;\n}\n","'use strict';\n\nvar global = require('../globals'),\n  time = require('./time');\n\nvar legend = module.exports = {};\n\nlegend.defs = function(encoding) {\n  var defs = [];\n\n  // TODO: support alpha\n\n  if (encoding.has(COLOR) && encoding.legend(COLOR)) {\n    defs.push(legend.def(COLOR, encoding, {\n      fill: COLOR,\n      orient: 'right'\n    }));\n  }\n\n  if (encoding.has(SIZE) && encoding.legend(SIZE)) {\n    defs.push(legend.def(SIZE, encoding, {\n      size: SIZE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  if (encoding.has(SHAPE) && encoding.legend(SHAPE)) {\n    if (defs.length === 2) {\n      // TODO: fix this\n      console.error('Vegalite currently only supports two legends');\n      return defs;\n    }\n    defs.push(legend.def(SHAPE, encoding, {\n      shape: SHAPE,\n      orient: defs.length === 1 ? 'left' : 'right'\n    }));\n  }\n\n  return defs;\n};\n\nlegend.def = function(name, encoding, props) {\n  var def = props, fn;\n\n  def.title = encoding.fieldTitle(name);\n\n  if (encoding.isType(name, T) && (fn = encoding.fn(name)) &&\n    time.hasScale(fn)) {\n    var properties = def.properties = def.properties || {},\n      labels = properties.labels = properties.labels || {},\n      text = labels.text = labels.text || {};\n\n    text.scale = 'time-'+ fn;\n  }\n\n  return def;\n};\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlscale = require('./scale');\n\nvar marks = module.exports = {};\n\nmarks.def = function(mark, encoding, layout, style) {\n  var defs = [];\n\n  // to add a background to text, we need to add it before the text\n  if (encoding.marktype() === TEXT && encoding.has(COLOR)) {\n    var bg = {\n      x: {value: 0},\n      y: {value: 0},\n      x2: {value: layout.cellWidth},\n      y2: {value: layout.cellHeight},\n      fill: {scale: COLOR, field: encoding.field(COLOR)}\n    };\n    defs.push({\n      type: 'rect',\n      from: {data: TABLE},\n      properties: {enter: bg, update: bg}\n    });\n  }\n\n  // add the mark def for the main thing\n  var p = mark.prop(encoding, layout, style);\n  defs.push({\n    type: mark.type,\n    from: {data: TABLE},\n    properties: {enter: p, update: p}\n  });\n\n  return defs;\n};\n\nmarks.bar = {\n  type: 'rect',\n  stack: true,\n  prop: bar_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1}\n};\n\nmarks.line = {\n  type: 'line',\n  line: true,\n  prop: line_props,\n  requiredEncoding: ['x', 'y'],\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail:1}\n};\n\nmarks.area = {\n  type: 'area',\n  stack: true,\n  line: true,\n  requiredEncoding: ['x', 'y'],\n  prop: area_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1}\n};\n\nmarks.tick = {\n  type: 'rect',\n  prop: tick_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.circle = {\n  type: 'symbol',\n  prop: filled_point_props('circle'),\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, detail: 1}\n};\n\nmarks.square = {\n  type: 'symbol',\n  prop: filled_point_props('square'),\n  supportedEncoding: marks.circle.supportedEncoding\n};\n\nmarks.point = {\n  type: 'symbol',\n  prop: point_props,\n  supportedEncoding: {row: 1, col: 1, x: 1, y: 1, size: 1, color: 1, alpha: 1, shape: 1, detail: 1}\n};\n\nmarks.text = {\n  type: 'text',\n  prop: text_props,\n  requiredEncoding: ['text'],\n  supportedEncoding: {row: 1, col: 1, size: 1, color: 1, alpha: 1, text: 1}\n};\n\nfunction bar_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: e.scale(X).type === 'log' ? 1 : 0};\n    }\n  } else if (e.has(X)) { // is ordinal\n    p.xc = {scale: X, field: e.field(X)};\n  } else {\n    // TODO add single bar offset\n    p.xc = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: e.scale(Y).type === 'log' ? 1 : 0};\n  } else if (e.has(Y)) { // is ordinal\n    p.yc = {scale: Y, field: e.field(Y)};\n  } else {\n    // TODO add single bar offset\n    p.yc = {group: 'height'};\n  }\n\n  // width\n  if (!e.has(X) || e.isOrdinalScale(X)) { // no X or X is ordinal\n    if (e.has(SIZE)) {\n      p.width = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.width = {\n        value: e.bandSize(X, layout.x.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // X is Quant or Time Scale\n    p.width = {value: 2};\n  }\n\n  // height\n  if (!e.has(Y) || e.isOrdinalScale(Y)) { // no Y or Y is ordinal\n    if (e.has(SIZE)) {\n      p.height = {scale: SIZE, field: e.field(SIZE)};\n    } else {\n      p.height = {\n        value: e.bandSize(Y, layout.y.useSmallBand),\n        offset: -1\n      };\n    }\n  } else { // Y is Quant or Time Scale\n    p.height = {value: 2};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction point_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.size = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.size = {value: e.value(SIZE)};\n  }\n\n  // shape\n  if (e.has(SHAPE)) {\n    p.shape = {scale: SHAPE, field: e.field(SHAPE)};\n  } else if (!e.has(SHAPE)) {\n    p.shape = {value: e.value(SHAPE)};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction line_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.stroke = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.stroke = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  p.strokeWidth = {value: e.config('strokeWidth')};\n\n  return p;\n}\n\nfunction area_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.isMeasure(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(Y)) {\n      p.x2 = {scale: X, value: 0};\n      p.orient = {value: 'horizontal'};\n    }\n  } else if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.isMeasure(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    p.y2 = {scale: Y, value: 0};\n  } else if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else {\n    p.y = {group: 'height'};\n  }\n\n  // stroke\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else if (!e.has(COLOR)) {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  }\n\n  return p;\n}\n\nfunction tick_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n    if (e.isDimension(X)) {\n      p.x.offset = -e.bandSize(X, layout.x.useSmallBand) / 3;\n    }\n  } else if (!e.has(X)) {\n    p.x = {value: 0};\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n    if (e.isDimension(Y)) {\n      p.y.offset = -e.bandSize(Y, layout.y.useSmallBand) / 3;\n    }\n  } else if (!e.has(Y)) {\n    p.y = {value: 0};\n  }\n\n  // width\n  if (!e.has(X) || e.isDimension(X)) {\n    p.width = {value: e.bandSize(X, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.width = {value: 1};\n  }\n\n  // height\n  if (!e.has(Y) || e.isDimension(Y)) {\n    p.height = {value: e.bandSize(Y, layout.y.useSmallBand) / 1.5};\n  } else {\n    p.height = {value: 1};\n  }\n\n  // fill\n  if (e.has(COLOR)) {\n    p.fill = {scale: COLOR, field: e.field(COLOR)};\n  } else {\n    p.fill = {value: e.value(COLOR)};\n  }\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else if (!e.has(COLOR)) {\n    p.opacity = {value: style.opacity};\n  }\n\n  return p;\n}\n\nfunction filled_point_props(shape) {\n  return function(e, layout, style) {\n    var p = {};\n\n    // x\n    if (e.has(X)) {\n      p.x = {scale: X, field: e.field(X)};\n    } else if (!e.has(X)) {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n\n    // y\n    if (e.has(Y)) {\n      p.y = {scale: Y, field: e.field(Y)};\n    } else if (!e.has(Y)) {\n      p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n    }\n\n    // size\n    if (e.has(SIZE)) {\n      p.size = {scale: SIZE, field: e.field(SIZE)};\n    } else if (!e.has(X)) {\n      p.size = {value: e.value(SIZE)};\n    }\n\n    // shape\n    p.shape = {value: shape};\n\n    // fill\n    if (e.has(COLOR)) {\n      p.fill = {scale: COLOR, field: e.field(COLOR)};\n    } else if (!e.has(COLOR)) {\n      p.fill = {value: e.value(COLOR)};\n    }\n\n    // alpha\n    if (e.has(ALPHA)) {\n      p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n    } else if (e.value(ALPHA) !== undefined) {\n      p.opacity = {value: e.value(ALPHA)};\n    } else if (!e.has(COLOR)) {\n      p.opacity = {value: style.opacity};\n    }\n\n    return p;\n  };\n}\n\nfunction text_props(e, layout, style) {\n  var p = {};\n\n  // x\n  if (e.has(X)) {\n    p.x = {scale: X, field: e.field(X)};\n  } else if (!e.has(X)) {\n    if (e.has(TEXT) && e.isType(TEXT, Q)) {\n      p.x = {value: layout.cellWidth-5};\n    } else {\n      p.x = {value: e.bandSize(X, layout.x.useSmallBand) / 2};\n    }\n  }\n\n  // y\n  if (e.has(Y)) {\n    p.y = {scale: Y, field: e.field(Y)};\n  } else if (!e.has(Y)) {\n    p.y = {value: e.bandSize(Y, layout.y.useSmallBand) / 2};\n  }\n\n  // size\n  if (e.has(SIZE)) {\n    p.fontSize = {scale: SIZE, field: e.field(SIZE)};\n  } else if (!e.has(SIZE)) {\n    p.fontSize = {value: e.font('size')};\n  }\n\n  // fill\n  // color should be set to background\n  p.fill = {value: 'black'};\n\n  // alpha\n  if (e.has(ALPHA)) {\n    p.opacity = {scale: ALPHA, field: e.field(ALPHA)};\n  } else if (e.value(ALPHA) !== undefined) {\n    p.opacity = {value: e.value(ALPHA)};\n  } else {\n    p.opacity = {value: style.opacity};\n  }\n\n  // text\n  if (e.has(TEXT)) {\n    if (e.isType(TEXT, Q)) {\n      p.text = {template: \"{{\" + e.field(TEXT) + \" | number:'.3s'}}\"};\n      p.align = {value: 'right'};\n    } else {\n      p.text = {field: e.field(TEXT)};\n    }\n  } else {\n    p.text = {value: 'Abc'};\n  }\n\n  p.font = {value: e.font('family')};\n  p.fontWeight = {value: e.font('weight')};\n  p.fontStyle = {value: e.font('style')};\n  p.baseline = {value: e.text('baseline')};\n\n  return p;\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  time = require('./time');\n\nvar scale = module.exports = {};\n\nscale.names = function(props) {\n  return util.keys(util.keys(props).reduce(function(a, x) {\n    if (props[x] && props[x].scale) a[props[x].scale] = 1;\n    return a;\n  }, {}));\n};\n\nscale.defs = function(names, encoding, layout, style, sorting, opt) {\n  opt = opt || {};\n\n  return names.reduce(function(a, name) {\n    var s = {\n      name: name,\n      type: scale.type(name, encoding),\n      domain: scale_domain(name, encoding, sorting, opt)\n    };\n    if (s.type === 'ordinal' && !encoding.bin(name) && encoding.sort(name).length === 0) {\n      s.sort = true;\n    }\n\n    scale_range(s, encoding, layout, style, opt);\n\n    return (a.push(s), a);\n  }, []);\n};\n\nscale.type = function(name, encoding) {\n\n  switch (encoding.type(name)) {\n    case O: return 'ordinal';\n    case T:\n      var fn = encoding.fn(name);\n      return (fn && time.scale.type(fn, name)) || 'time';\n    case Q:\n      if (encoding.bin(name)) {\n        return name === COLOR ? 'linear' : 'ordinal';\n      }\n      return encoding.scale(name).type;\n  }\n};\n\nfunction scale_domain(name, encoding, sorting, opt) {\n  if (encoding.isType(name, T)) {\n    var range = time.scale.domain(encoding.fn(name), name);\n    if(range) return range;\n  }\n\n  if (encoding.bin(name)) {\n    // TODO: add includeEmptyConfig here\n    if (opt.stats) {\n      var bins = util.getbins(opt.stats[encoding.fieldName(name)], encoding.bin(name).maxbins);\n      var domain = util.range(bins.start, bins.stop, bins.step);\n      return name === Y ? domain.reverse() : domain;\n    }\n  }\n\n  return name == opt.stack ?\n    {\n      data: STACKED,\n      field: 'data.' + (opt.facet ? 'max_' : '') + 'sum_' + encoding.field(name, true)\n    } :\n    {data: sorting.getDataset(name), field: encoding.field(name)};\n}\n\nfunction scale_range(s, encoding, layout, style, opt) {\n  var spec = encoding.scale(s.name);\n  switch (s.name) {\n    case X:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(X, layout.x.useSmallBand);\n      } else {\n        s.range = layout.cellWidth ? [0, layout.cellWidth] : 'width';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n      s.round = true;\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name);\n      }else {\n        s.nice = true;\n      }\n      break;\n    case Y:\n      if (s.type === 'ordinal') {\n        s.bandWidth = encoding.bandSize(Y, layout.y.useSmallBand);\n      } else {\n        s.range = layout.cellHeight ? [layout.cellHeight, 0] : 'height';\n\n        if (encoding.isType(s.name,T) && encoding.fn(s.name) === 'year') {\n          s.zero = false;\n        } else {\n          s.zero = spec.zero === undefined ? true : spec.zero;\n        }\n\n        s.reverse = spec.reverse;\n      }\n\n      s.round = true;\n\n      if (s.type === 'time') {\n        s.nice = encoding.fn(s.name) || encoding.config('timeScaleNice');\n      }else {\n        s.nice = true;\n      }\n      break;\n    case ROW: // support only ordinal\n      s.bandWidth = layout.cellHeight;\n      s.round = true;\n      s.nice = true;\n      break;\n    case COL: // support only ordinal\n      s.bandWidth = layout.cellWidth;\n      s.round = true;\n      s.nice = true;\n      break;\n    case SIZE:\n      if (encoding.is('bar')) {\n        // FIXME this is definitely incorrect\n        // but let's fix it later since bar size is a bad encoding anyway\n        s.range = [3, Math.max(encoding.bandSize(X), encoding.bandSize(Y))];\n      } else if (encoding.is(TEXT)) {\n        s.range = [8, 40];\n      } else { //point\n        var bandSize = Math.min(encoding.bandSize(X), encoding.bandSize(Y)) - 1;\n        s.range = [10, 0.8 * bandSize*bandSize];\n      }\n      s.round = true;\n      s.zero = false;\n      break;\n    case SHAPE:\n      s.range = 'shapes';\n      break;\n    case COLOR:\n      var range = encoding.scale(COLOR).range;\n      if (range === undefined) {\n        if (s.type === 'ordinal') {\n          // FIXME\n          range = style.colorRange;\n        } else {\n          range = ['#A9DB9F', '#0D5C21'];\n          s.zero = false;\n        }\n      }\n      s.range = range;\n      break;\n    case ALPHA:\n      s.range = [0.2, 1.0];\n      break;\n    default:\n      throw new Error('Unknown encoding name: '+ s.name);\n  }\n\n  switch (s.name) {\n    case ROW:\n    case COL:\n      s.padding = encoding.config('cellPadding');\n      s.outerPadding = 0;\n      break;\n    case X:\n    case Y:\n      if (s.type === 'ordinal') { //&& !s.bandWidth\n        s.points = true;\n        s.padding = encoding.band(s.name).padding;\n      }\n  }\n}\n","'use strict';\n\nvar globals = require('../globals');\n\nmodule.exports = addSortTransforms;\n\n// adds new transforms that produce sorted fields\nfunction addSortTransforms(spec, encoding, stats, opt) {\n  var datasetMapping = {};\n  var counter = 0;\n\n  encoding.forEach(function(field, encType) {\n    var sortBy = encoding.sort(encType, stats);\n    if (sortBy.length > 0) {\n      var fields = sortBy.map(function(d) {\n        return {\n          op: d.aggr,\n          field: 'data.' + d.name\n        };\n      });\n\n      var byClause = sortBy.map(function(d) {\n        var reverse = (d.reverse ? '-' : '');\n        return reverse + 'data.' + (d.aggr==='count' ? 'count' : (d.aggr + '_' + d.name));\n      });\n\n      var dataName = 'sorted' + counter++;\n\n      var transforms = [\n        {\n          type: 'aggregate',\n          groupby: ['data.' + field.name],\n          fields: fields\n        },\n        {\n          type: 'sort',\n          by: byClause\n        }\n      ];\n\n      spec.data.push({\n        name: dataName,\n        source: RAW,\n        transform: transforms\n      });\n\n      datasetMapping[encType] = dataName;\n    }\n  });\n\n  return {\n    spec: spec,\n    getDataset: function(encType) {\n      var data = datasetMapping[encType];\n      if (!data) {\n        return TABLE;\n      }\n      return data;\n    }\n  };\n}\n","\"use strict\";\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  marks = require('./marks');\n\nmodule.exports = stacking;\n\nfunction stacking(spec, encoding, mdef, facets) {\n  if (!marks[encoding.marktype()].stack) return false;\n\n  // TODO: add || encoding.has(LOD) here once LOD is implemented\n  if (!encoding.has(COLOR)) return false;\n\n  var dim=null, val=null, idx =null,\n    isXMeasure = encoding.isMeasure(X),\n    isYMeasure = encoding.isMeasure(Y);\n\n  if (isXMeasure && !isYMeasure) {\n    dim = Y;\n    val = X;\n    idx = 0;\n  } else if (isYMeasure && !isXMeasure) {\n    dim = X;\n    val = Y;\n    idx = 1;\n  } else {\n    return null; // no stack encoding\n  }\n\n  // add transform to compute sums for scale\n  var stacked = {\n    name: STACKED,\n    source: TABLE,\n    transform: [{\n      type: 'aggregate',\n      groupby: [encoding.field(dim)].concat(facets), // dim and other facets\n      fields: [{op: 'sum', field: encoding.field(val)}] // TODO check if field with aggr is correct?\n    }]\n  };\n\n  if (facets && facets.length > 0) {\n    stacked.transform.push({ //calculate max for each facet\n      type: 'aggregate',\n      groupby: facets,\n      fields: [{op: 'max', field: 'data.sum_' + encoding.field(val, true)}]\n    });\n  }\n\n  spec.data.push(stacked);\n\n  // add stack transform to mark\n  mdef.from.transform = [{\n    type: 'stack',\n    point: encoding.field(dim),\n    height: encoding.field(val),\n    output: {y1: val, y0: val + '2'}\n  }];\n\n  // TODO: This is super hack-ish -- consolidate into modular mark properties?\n  mdef.properties.update[val] = mdef.properties.enter[val] = {scale: val, field: val};\n  mdef.properties.update[val + '2'] = mdef.properties.enter[val + '2'] = {scale: val, field: val + '2'};\n\n  return val; //return stack encoding\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util'),\n  vlfield = require('../field'),\n  Encoding = require('../Encoding');\n\nmodule.exports = function(encoding, stats) {\n  return {\n    opacity: estimateOpacity(encoding, stats),\n    colorRange: colorRange(encoding, stats)\n  };\n};\n\nfunction colorRange(encoding, stats){\n  if (encoding.has(COLOR) && encoding.isDimension(COLOR)) {\n    var cardinality = encoding.cardinality(COLOR, stats);\n    if (cardinality <= 10) {\n      return \"category10\";\n    } else {\n      return \"category20\";\n    }\n    // TODO can vega interpolate range for ordinal scale?\n  }\n  return null;\n}\n\nfunction estimateOpacity(encoding,stats) {\n  if (!stats) {\n    return 1;\n  }\n\n  var numPoints = 0;\n\n  if (encoding.isAggregate()) { // aggregate plot\n    numPoints = 1;\n\n    //  get number of points in each \"cell\"\n    //  by calculating product of cardinality\n    //  for each non faceting and non-ordinal X / Y fields\n    //  note that ordinal x,y are not include since we can\n    //  consider that ordinal x are subdividing the cell into subcells anyway\n    encoding.forEach(function(field, encType) {\n\n      if (encType !== ROW && encType !== COL &&\n          !((encType === X || encType === Y) &&\n          vlfield.isOrdinalScale(field, true))\n        ) {\n        numPoints *= encoding.cardinality(encType, stats);\n      }\n    });\n\n  } else { // raw plot\n    numPoints = stats.count;\n\n    // small multiples divide number of points\n    var numMultiples = 1;\n    if (encoding.has(ROW)) {\n      numMultiples *= encoding.cardinality(ROW, stats);\n    }\n    if (encoding.has(COL)) {\n      numMultiples *= encoding.cardinality(COL, stats);\n    }\n    numPoints /= numMultiples;\n  }\n\n  var opacity = 0;\n  if (numPoints < 20) {\n    opacity = 1;\n  } else if (numPoints < 200) {\n    opacity = 0.7;\n  } else if (numPoints < 1000 || encoding.is('tick')) {\n    opacity = 0.6;\n  } else {\n    opacity = 0.3;\n  }\n\n  return opacity;\n}\n\n","'use strict';\n\nvar global = require('../globals');\n\nvar groupdef = require('./group').def;\n\nmodule.exports = subfaceting;\n\nfunction subfaceting(group, mdef, details, stack, encoding) {\n  var m = group.marks,\n    g = groupdef('subfacet', {marks: m});\n\n  group.marks = [g];\n  g.from = mdef.from;\n  delete mdef.from;\n\n  //TODO test LOD -- we should support stack / line without color (LOD) field\n  var trans = (g.from.transform || (g.from.transform = []));\n  trans.unshift({type: 'facet', keys: details});\n\n  if (stack && encoding.has(COLOR)) {\n    trans.unshift({type: 'sort', by: encoding.field(COLOR)});\n  }\n}\n","'use strict';\n\nvar globals = require('../globals');\n\nvar groupdef = require('./group').def,\n  vldata = require('../data');\n\nmodule.exports = template;\n\nfunction template(encoding, layout, stats) { //hack use stats\n\n  var data = {name: RAW, format: {type: encoding.data('formatType')}},\n    table = {name: TABLE, source: RAW},\n    dataUrl = vldata.getUrl(encoding, stats);\n  if (dataUrl) data.url = dataUrl;\n\n  var preaggregatedData = !!encoding.data('vegaServer');\n\n  encoding.forEach(function(field, encType) {\n    var name;\n    if (field.type == T) {\n      data.format.parse = data.format.parse || {};\n      data.format.parse[field.name] = 'date';\n    } else if (field.type == Q) {\n      data.format.parse = data.format.parse || {};\n      if (field.aggr === 'count') {\n        name = 'count';\n      } else if (preaggregatedData && field.bin) {\n        name = 'bin_' + field.name;\n      } else if (preaggregatedData && field.aggr) {\n        name = field.aggr + '_' + field.name;\n      } else {\n        name = field.name;\n      }\n      data.format.parse[name] = 'number';\n    }\n  });\n\n  return {\n    width: layout.width,\n    height: layout.height,\n    padding: 'auto',\n    data: [data, table],\n    marks: [groupdef('cell', {\n      width: layout.cellWidth ? {value: layout.cellWidth} : undefined,\n      height: layout.cellHeight ? {value: layout.cellHeight} : undefined\n    })]\n  };\n}\n","'use strict';\n\nvar globals = require('../globals'),\n  util = require('../util');\n\nmodule.exports = time;\n\nfunction time(spec, encoding, opt) {\n  var timeFields = {}, timeFn = {};\n\n  // find unique formula transformation and bin function\n  encoding.forEach(function(field, encType) {\n    if (field.type === T && field.fn) {\n      timeFields[encoding.field(encType)] = {\n        field: field,\n        encType: encType\n      };\n      timeFn[field.fn] = true;\n    }\n  });\n\n  // add formula transform\n  var data = spec.data[1],\n    transform = data.transform = data.transform || [];\n\n  for (var f in timeFields) {\n    var tf = timeFields[f];\n    time.transform(transform, encoding, tf.encType, tf.field);\n  }\n\n  // add scales\n  var scales = spec.scales = spec.scales || [];\n  for (var fn in timeFn) {\n    time.scale(scales, fn, encoding);\n  }\n  return spec;\n}\n\ntime.cardinality = function(field, stats, filterNull, type) {\n  var fn = field.fn;\n  switch (fn) {\n    case 'seconds': return 60;\n    case 'minutes': return 60;\n    case 'hours': return 24;\n    case 'day': return 7;\n    case 'date': return 31;\n    case 'month': return 12;\n    case 'year':\n      var stat = stats[field.name],\n        yearstat = stats['year_'+field.name];\n\n      if (!yearstat) { return null; }\n\n      return yearstat.cardinality -\n        (stat.numNulls > 0 && filterNull[type] ? 1 : 0);\n  }\n\n  return null;\n};\n\nfunction fieldFn(func, field) {\n  return 'utc' + func + '(d.data.'+ field.name +')';\n}\n\n/**\n * @return {String} date binning formula of the given field\n */\ntime.formula = function(field) {\n  return fieldFn(field.fn, field);\n};\n\n/** add formula transforms to data */\ntime.transform = function(transform, encoding, encType, field) {\n  transform.push({\n    type: 'formula',\n    field: encoding.field(encType),\n    expr: time.formula(field)\n  });\n};\n\n/** append custom time scales for axis label */\ntime.scale = function(scales, fn, encoding) {\n  var labelLength = encoding.config('timeScaleLabelLength');\n  // TODO add option for shorter scale / custom range\n  switch (fn) {\n    case 'day':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 7),\n        range: ['Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday', 'Sunday'].map(\n          function(s) { return s.substr(0, labelLength);}\n        )\n      });\n      break;\n    case 'month':\n      scales.push({\n        name: 'time-'+fn,\n        type: 'ordinal',\n        domain: util.range(0, 12),\n        range: ['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'].map(\n            function(s) { return s.substr(0, labelLength);}\n          )\n      });\n      break;\n  }\n};\n\ntime.isOrdinalFn = function(fn) {\n  switch (fn) {\n    case 'seconds':\n    case 'minutes':\n    case 'hours':\n    case 'day':\n    case 'date':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\ntime.scale.type = function(fn, name) {\n  if (name === COLOR) {\n    return 'linear'; // this has order\n  }\n\n  return time.isOrdinalFn(fn) || name === COL || name === ROW ? 'ordinal' : 'linear';\n};\n\ntime.scale.domain = function(fn, name) {\n  var isColor = name === COLOR;\n  switch (fn) {\n    case 'seconds':\n    case 'minutes': return isColor ? [0,59] : util.range(0, 60);\n    case 'hours': return isColor ? [0,23] : util.range(0, 24);\n    case 'day': return isColor ? [0,6] : util.range(0, 7);\n    case 'date': return isColor ? [1,31] : util.range(1, 32);\n    case 'month': return isColor ? [0,11] : util.range(0, 12);\n  }\n  return null;\n};\n\n/** whether a particular time function has custom scale for labels implemented in time.scale */\ntime.hasScale = function(fn) {\n  switch (fn) {\n    case 'day':\n    case 'month':\n      return true;\n  }\n  return false;\n};\n\n\n","'use strict';\n\nvar globals = require('./globals');\n\nvar consts = module.exports = {};\n\nconsts.encodingTypes = [X, Y, ROW, COL, SIZE, SHAPE, COLOR, ALPHA, TEXT, DETAIL];\n\nconsts.dataTypes = {'O': O, 'Q': Q, 'T': T};\n\nconsts.dataTypeNames = ['O', 'Q', 'T'].reduce(function(r, x) {\n  r[consts.dataTypes[x]] = x;\n  return r;\n},{});\n\nconsts.shorthand = {\n  delim:  '|',\n  assign: '=',\n  type:   ',',\n  func:   '_'\n};\n","'use strict';\n\n// TODO: rename getDataUrl to vl.data.getUrl() ?\n\nvar util = require('./util');\n\nvar vldata = module.exports = {},\n  vlfield = require('./field');\n\nvldata.getUrl = function getDataUrl(encoding, stats) {\n  if (!encoding.data('vegaServer')) {\n    // don't use vega server\n    return encoding.data('url');\n  }\n\n  if (encoding.length() === 0) {\n    // no fields\n    return;\n  }\n\n  var fields = [];\n  encoding.forEach(function(field, encType) {\n    var obj = {\n      name: encoding.field(encType, true),\n      field: field.name\n    };\n    if (field.aggr) {\n      obj.aggr = field.aggr;\n    }\n    if (field.bin) {\n      obj.binSize = util.getbins(stats[field.name], encoding.bin(encType).maxbins).step;\n    }\n    fields.push(obj);\n  });\n\n  var query = {\n    table: encoding.data('vegaServer').table,\n    fields: fields\n  };\n\n  return encoding.data('vegaServer').url + '/query/?q=' + JSON.stringify(query);\n};\n\n/**\n * @param  {Object} data data in JSON/javascript object format\n * @return Array of {name: __name__, type: \"number|text|time|location\"}\n */\nvldata.getSchema = function(data, order) {\n  var schema = [],\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    // find non-null data\n    var i = 0, datum = data[i][k];\n    while (datum === '' || datum === null || datum === undefined) {\n      datum = data[++i][k];\n      if (i >= data.length) {\n        datum = '';\n        break;\n      }\n    }\n\n    datum = util.parse(datum);\n    var type = (typeof datum === 'number') ? 'Q':\n      (datum instanceof Date) ? 'T' : 'O';\n\n    schema.push({name: k, type: type});\n  });\n\n  schema = util.stablesort(schema, order || vlfield.order.typeThenName, vlfield.order.name);\n\n  return schema;\n};\n\nvldata.getStats = function(data) { // hack\n  var stats = {},\n    fields = util.keys(data[0]);\n\n  fields.forEach(function(k) {\n    var column = data.map(function(d) {return d[k];});\n\n    // Hack\n    var val = util.parse(data[0][k]);\n    var type = (typeof val === 'number') ? 'Q':\n      (val instanceof Date) ? 'T' : 'O';\n\n    var stat = {};\n    if (typeof val === 'number') {\n      stat = util.minmax(util.numbers(column));\n    } else if (val instanceof Date) {\n      stat = util.minmax(util.dates(column));\n    } else {\n      stat = util.minmax(column);\n    }\n\n    stat.cardinality = util.uniq(data, k);\n    stat.count = data.length;\n\n    stat.maxlength = data.reduce(function(max,row) {\n      if (row[k] === null) {\n        return max;\n      }\n      var len = row[k].toString().length;\n      return len > max ? len : max;\n    }, 0);\n\n    stat.numNulls = data.reduce(function(count, row) {\n      return row[k] === null ? count + 1 : count;\n    }, 0);\n\n    var numbers = util.numbers(column);\n\n    if (numbers.length > 0) {\n      stat.skew = util.skew(numbers);\n      stat.stdev = util.stdev(numbers);\n      stat.mean = util.mean(numbers);\n      stat.median = util.median(numbers);\n    }\n\n    var sample = {};\n    while(Object.keys(sample).length < Math.min(stat.cardinality, 10)) {\n      var value = data[Math.floor(Math.random() * data.length)][k];\n      sample[value] = true;\n    }\n    stat.sample = Object.keys(sample);\n\n    stats[k] = stat;\n  });\n  stats.count = data.length;\n  return stats;\n};\n","// utility for enc\n\n'use strict';\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  vlfield = require('./field'),\n  util = require('./util'),\n  schema = require('./schema/schema'),\n  encTypes = schema.encTypes;\n\nvar vlenc = module.exports = {};\n\nvlenc.countRetinal = function(enc) {\n  var count = 0;\n  if (enc.color) count++;\n  if (enc.alpha) count++;\n  if (enc.size) count++;\n  if (enc.shape) count++;\n  return count;\n};\n\nvlenc.has = function(enc, encType) {\n  var fieldDef = enc && enc[encType];\n  return fieldDef && fieldDef.name;\n};\n\nvlenc.isAggregate = function(enc) {\n  for (var k in enc) {\n    if (vlenc.has(enc, k) && enc[k].aggr) {\n      return true;\n    }\n  }\n  return false;\n};\n\nvlenc.forEach = function(enc, f) {\n  var i = 0;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      f(enc[k], k, i++);\n    }\n  });\n};\n\nvlenc.map = function(enc, f) {\n  var arr = [];\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      arr.push(f(enc[k], k, enc));\n    }\n  });\n  return arr;\n};\n\nvlenc.reduce = function(enc, f, init) {\n  var r = init, i = 0, k;\n  encTypes.forEach(function(k) {\n    if (vlenc.has(enc, k)) {\n      r = f(r, enc[k], k,  enc);\n    }\n  });\n  return r;\n};\n\n/*\n * return key-value pairs of field name and list of fields of that field name\n */\nvlenc.fields = function(enc) {\n  return vlenc.reduce(enc, function (m, field, encType) {\n    var fieldList = m[field.name] = m[field.name] || [],\n      containsType = fieldList.containsType = fieldList.containsType || {};\n\n    if (fieldList.indexOf(field) === -1) {\n      fieldList.push(field);\n      // augment the array with containsType.Q / O / T\n      containsType[field.type] = true;\n    }\n    return m;\n  }, {});\n};\n\nvlenc.shorthand = function(enc) {\n  return vlenc.map(enc, function(field, et) {\n    return et + c.assign + vlfield.shorthand(field);\n  }).join(c.delim);\n};\n\nvlenc.fromShorthand = function(shorthand, convertType) {\n  var enc = util.isArray(shorthand) ? shorthand : shorthand.split(c.delim);\n  return enc.reduce(function(m, e) {\n    var split = e.split(c.assign),\n        enctype = split[0].trim(),\n        field = split[1];\n\n    m[enctype] = vlfield.fromShorthand(field, convertType);\n    return m;\n  }, {});\n};","'use strict';\n\n// utility for field\n\nvar consts = require('./consts'),\n  c = consts.shorthand,\n  time = require('./compile/time'),\n  util = require('./util'),\n  schema = require('./schema/schema');\n\nvar vlfield = module.exports = {};\n\nvlfield.shorthand = function(f) {\n  var c = consts.shorthand;\n  return (f.aggr ? f.aggr + c.func : '') +\n    (f.fn ? f.fn + c.func : '') +\n    (f.bin ? 'bin' + c.func : '') +\n    (f.name || '') + c.type +\n    (consts.dataTypeNames[f.type] || f.type);\n};\n\nvlfield.shorthands = function(fields, delim) {\n  delim = delim || c.delim;\n  return fields.map(vlfield.shorthand).join(delim);\n};\n\nvlfield.fromShorthand = function(shorthand, convertType) {\n  var split = shorthand.split(c.type), i;\n  var o = {\n    name: split[0].trim(),\n    type: convertType ? consts.dataTypes[split[1].trim()] : split[1].trim()\n  };\n\n  // check aggregate type\n  for (i in schema.aggr.enum) {\n    var a = schema.aggr.enum[i];\n    if (o.name.indexOf(a + '_') === 0) {\n      o.name = o.name.substr(a.length + 1);\n      if (a == 'count' && o.name.length === 0) o.name = '*';\n      o.aggr = a;\n      break;\n    }\n  }\n\n  // check time fn\n  for (i in schema.timefns) {\n    var f = schema.timefns[i];\n    if (o.name && o.name.indexOf(f + '_') === 0) {\n      o.name = o.name.substr(o.length + 1);\n      o.fn = f;\n      break;\n    }\n  }\n\n  // check bin\n  if (o.name && o.name.indexOf('bin_') === 0) {\n    o.name = o.name.substr(4);\n    o.bin = true;\n  }\n\n  return o;\n};\n\nvar typeOrder = {\n  O: 0,\n  G: 1,\n  T: 2,\n  Q: 3\n};\n\nvlfield.order = {};\n\nvlfield.order.type = function(field) {\n  if (field.aggr==='count') return 4;\n  return typeOrder[field.type];\n};\n\nvlfield.order.typeThenName = function(field) {\n  return vlfield.order.type(field) + '_' + field.name.toLowerCase();\n};\n\nvlfield.order.original = function() {\n  return 0; // no swap will occur\n};\n\nvlfield.order.name = function(field) {\n  return field.name;\n};\n\nvlfield.order.typeThenCardinality = function(field, stats){\n  return stats[field.name].cardinality;\n};\n\n// FIXME refactor\nvlfield.isType = function (fieldDef, type) {\n  return (fieldDef.type & type) > 0;\n};\n\nvlfield.isType.byCode = vlfield.isType;\n\nvlfield.isType.byName = function (field, type) {\n  return field.type === consts.dataTypeNames[type];\n};\n\n\nfunction getIsType(useTypeCode) {\n  return useTypeCode ? vlfield.isType.byCode : vlfield.isType.byName;\n}\n\nvlfield.isType.get = getIsType; //FIXME\n\n/*\n * Most fields that use ordinal scale are dimensions.\n * However, YEAR(T), YEARMONTH(T) use time scale, not ordinal but are dimensions too.\n */\nvlfield.isOrdinalScale = function(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || field.bin ||\n    ( isType(field, T) && field.fn && time.isOrdinalFn(field.fn) );\n};\n\nfunction isDimension(field, useTypeCode /*optional*/) {\n  var isType = getIsType(useTypeCode);\n  return  isType(field, O) || !!field.bin ||\n    ( isType(field, T) && !!field.fn );\n}\n\n/**\n * For encoding, use encoding.isDimension() to avoid confusion.\n * Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.isDimension = function(field, useTypeCode /*optional*/) {\n  return field && isDimension(field, useTypeCode);\n};\n\nvlfield.isMeasure = function(field, useTypeCode) {\n  return field && !isDimension(field, useTypeCode);\n};\n\nvlfield.role = function(field) {\n  return isDimension(field) ? 'dimension' : 'measure';\n};\n\nvlfield.count = function() {\n  return {name:'*', aggr: 'count', type:'Q', displayName: vlfield.count.displayName};\n};\n\nvlfield.count.displayName = 'Number of Records';\n\nvlfield.isCount = function(field) {\n  return field.aggr === 'count';\n};\n\n/**\n * For encoding, use encoding.cardinality() to avoid confusion.  Or use Encoding.isType if your field is from Encoding (and thus have numeric data type).\n * otherwise, do not specific isType so we can use the default isTypeName here.\n */\nvlfield.cardinality = function(field, stats, filterNull, useTypeCode) {\n  // FIXME need to take filter into account\n  var isType = getIsType(useTypeCode),\n    type = useTypeCode ? consts.dataTypeNames[field.type] : field.type;\n\n  filterNull = filterNull || {};\n\n  if (field.bin) {\n    var bins = util.getbins(stats[field.name], field.bin.maxbins || schema.MAXBINS_DEFAULT);\n    return (bins.stop - bins.start) / bins.step;\n  }\n  if (isType(field, T)) {\n    var cardinality = time.cardinality(field, stats, filterNull, type);\n    if(cardinality !== null) return cardinality;\n    //otherwise use calculation below\n  }\n  if (field.aggr) {\n    return 1;\n  }\n\n  // remove null\n  var stat = stats[field.name];\n  return stat.cardinality -\n    (stat.numNulls > 0 && filterNull[type] ? 1 : 0);\n};\n","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.TABLE = 'table';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.ALPHA = 'alpha';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.O = 1;\ng.Q = 2;\ng.T = 4;\n","// Package of defining Vegalite Specification's json schema\n\"use strict\";\n\nvar schema = module.exports = {},\n  util = require('../util');\n\nschema.util = require('./schemautil');\n\nschema.marktype = {\n  type: 'string',\n  enum: ['point', 'tick', 'bar', 'line', 'area', 'circle', 'square', 'text']\n};\n\nschema.aggr = {\n  type: 'string',\n  enum: ['avg', 'sum', 'min', 'max', 'count'],\n  supportedEnums: {\n    Q: ['avg', 'sum', 'min', 'max', 'count'],\n    O: [],\n    T: ['avg', 'min', 'max'],\n    '': ['count']\n  },\n  supportedTypes: {'Q': true, 'O': true, 'T': true, '': true}\n};\nschema.band = {\n  type: 'object',\n  properties: {\n    size: {\n      type: 'integer',\n      minimum: 0\n    },\n    padding: {\n      type: 'integer',\n      minimum: 0,\n      default: 1\n    }\n  }\n};\n\nschema.getSupportedRole = function(encType) {\n  return schema.schema.properties.enc.properties[encType].supportedRole;\n};\n\nschema.timefns = ['year', 'month', 'day', 'date', 'hours', 'minutes', 'seconds'];\n\nschema.defaultTimeFn = 'month';\n\nschema.fn = {\n  type: 'string',\n  enum: schema.timefns,\n  supportedTypes: {'T': true}\n};\n\n//TODO(kanitw): add other type of function here\n\nschema.scale_type = {\n  type: 'string',\n  enum: ['linear', 'log', 'pow', 'sqrt', 'quantile'],\n  default: 'linear',\n  supportedTypes: {'Q': true}\n};\n\nschema.field = {\n  type: 'object',\n  properties: {\n    name: {\n      type: 'string'\n    }\n  }\n};\n\nvar clone = util.duplicate;\nvar merge = schema.util.merge;\n\nschema.MAXBINS_DEFAULT = 15;\n\nvar bin = {\n  type: ['boolean', 'object'],\n  default: false,\n  properties: {\n    maxbins: {\n      type: 'integer',\n      default: schema.MAXBINS_DEFAULT,\n      minimum: 2\n    }\n  },\n  supportedTypes: {'Q': true} // TODO: add 'O' after finishing #81\n};\n\nvar typicalField = merge(clone(schema.field), {\n  type: 'object',\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O', 'Q', 'T']\n    },\n    aggr: schema.aggr,\n    fn: schema.fn,\n    bin: bin,\n    scale: {\n      type: 'object',\n      properties: {\n        type: schema.scale_type,\n        reverse: {\n          type: 'boolean',\n          default: false,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        zero: {\n          type: 'boolean',\n          description: 'Include zero',\n          default: true,\n          supportedTypes: {'Q': true, 'T': true}\n        },\n        nice: {\n          type: 'string',\n          enum: ['second', 'minute', 'hour', 'day', 'week', 'month', 'year'],\n          supportedTypes: {'T': true}\n        }\n      }\n    }\n  }\n});\n\nvar onlyOrdinalField = merge(clone(schema.field), {\n  type: 'object',\n  supportedRole: {\n    dimension: true\n  },\n  properties: {\n    type: {\n      type: 'string',\n      enum: ['O','Q', 'T'] // ordinal-only field supports Q when bin is applied and T when fn is applied.\n    },\n    fn: schema.fn,\n    bin: bin,\n    aggr: {\n      type: 'string',\n      enum: ['count'],\n      supportedTypes: {'O': true}\n    }\n  }\n});\n\nvar axisMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true},\n  properties: {\n    axis: {\n      type: 'object',\n      properties: {\n        grid: {\n          type: 'boolean',\n          default: true,\n          description: 'A flag indicate if gridlines should be created in addition to ticks.'\n        },\n        title: {\n          type: 'boolean',\n          default: true,\n          description: 'A title for the axis.'\n        },\n        titleOffset: {\n          type: 'integer',\n          default: undefined,  // auto\n          description: 'A title offset value for the axis.'\n        },\n        format: {\n          type: 'string',\n          default: undefined,  // auto\n          description: 'The formatting pattern for axis labels.'\n        },\n        maxLabelLength: {\n          type: 'integer',\n          default: 25,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar sortMixin = {\n  type: 'object',\n  properties: {\n    sort: {\n      type: 'array',\n      default: [],\n      items: {\n        type: 'object',\n        supportedTypes: {'O': true},\n        required: ['name', 'aggr'],\n        name: {\n          type: 'string'\n        },\n        aggr: {\n          type: 'string',\n          enum: ['avg', 'sum', 'min', 'max', 'count']\n        },\n        reverse: {\n          type: 'boolean',\n          default: false\n        }\n      }\n    }\n  }\n};\n\nvar bandMixin = {\n  type: 'object',\n  properties: {\n    band: schema.band\n  }\n};\n\nvar legendMixin = {\n  type: 'object',\n  properties: {\n    legend: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nvar textMixin = {\n  type: 'object',\n  supportedMarktypes: {'text': true},\n  properties: {\n    text: {\n      type: 'object',\n      properties: {\n        align: {\n          type: 'string',\n          default: 'left'\n        },\n        baseline: {\n          type: 'string',\n          default: 'middle'\n        },\n        margin: {\n          type: 'integer',\n          default: 4,\n          minimum: 0\n        }\n      }\n    },\n    font: {\n      type: 'object',\n      properties: {\n        weight: {\n          type: 'string',\n          enum: ['normal', 'bold'],\n          default: 'normal'\n        },\n        size: {\n          type: 'integer',\n          default: 10,\n          minimum: 0\n        },\n        family: {\n          type: 'string',\n          default: 'Helvetica Neue'\n        },\n        style: {\n          type: 'string',\n          default: 'normal',\n          enum: ['normal', 'italic']\n        }\n      }\n    }\n  }\n};\n\nvar sizeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, bar: true, circle: true, square: true, text: true},\n  properties: {\n    value: {\n      type: 'integer',\n      default: 30,\n      minimum: 0\n    }\n  }\n};\n\nvar colorMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'string',\n      role: 'color',\n      default: 'steelblue'\n    },\n    scale: {\n      type: 'object',\n      properties: {\n        range: {\n          type: ['string', 'array']\n        }\n      }\n    }\n  }\n};\n\nvar alphaMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, 'text': true},\n  properties: {\n    value: {\n      type: 'number',\n      default: undefined,  // auto\n      minimum: 0,\n      maximum: 1\n    }\n  }\n};\n\nvar shapeMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, circle: true, square: true},\n  properties: {\n    value: {\n      type: 'string',\n      enum: ['circle', 'square', 'cross', 'diamond', 'triangle-up', 'triangle-down'],\n      default: 'circle'\n    }\n  }\n};\n\nvar detailMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, line: true, circle: true, square: true}\n};\n\nvar rowMixin = {\n  properties: {\n    height: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    grid: {\n      type: 'boolean',\n      default: true,\n      description: 'A flag indicate if gridlines should be created in addition to ticks.'\n    },\n  }\n};\n\nvar colMixin = {\n  properties: {\n    width: {\n      type: 'number',\n      minimum: 0,\n      default: 150\n    },\n    axis: {\n      properties: {\n        maxLabelLength: {\n          type: 'integer',\n          default: 12,\n          minimum: 0,\n          description: 'Truncate labels that are too long.'\n        }\n      }\n    }\n  }\n};\n\nvar facetMixin = {\n  type: 'object',\n  supportedMarktypes: {point: true, tick: true, bar: true, line: true, area: true, circle: true, square: true, text: true},\n  properties: {\n    padding: {\n      type: 'number',\n      minimum: 0,\n      maximum: 1,\n      default: 0.1\n    }\n  }\n};\n\nvar requiredNameType = {\n  required: ['name', 'type']\n};\n\nvar multiRoleField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: true\n  }\n});\n\nvar quantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true,\n    dimension: 'ordinal-only' // using alpha / size to encoding category lead to order interpretation\n  }\n});\n\nvar onlyQuantitativeField = merge(clone(typicalField), {\n  supportedRole: {\n    measure: true\n  }\n});\n\nvar x = merge(clone(multiRoleField), axisMixin, bandMixin, requiredNameType, sortMixin);\nvar y = clone(x);\n\nvar facet = merge(clone(onlyOrdinalField), requiredNameType, facetMixin, sortMixin);\nvar row = merge(clone(facet), axisMixin, rowMixin);\nvar col = merge(clone(facet), axisMixin, colMixin);\n\nvar size = merge(clone(quantitativeField), legendMixin, sizeMixin, sortMixin);\nvar color = merge(clone(multiRoleField), legendMixin, colorMixin, sortMixin);\nvar alpha = merge(clone(quantitativeField), alphaMixin, sortMixin);\nvar shape = merge(clone(onlyOrdinalField), legendMixin, shapeMixin, sortMixin);\nvar detail = merge(clone(onlyOrdinalField), detailMixin, sortMixin);\n\n// we only put aggregated measure in pivot table\nvar text = merge(clone(onlyQuantitativeField), textMixin, sortMixin);\n\n// TODO add label\n\nvar filter = {\n  type: 'array',\n  items: {\n    type: 'object',\n    properties: {\n      operands: {\n        type: 'array',\n        items: {\n          type: ['string', 'boolean', 'integer', 'number']\n        }\n      },\n      operator: {\n        type: 'string',\n        enum: ['>', '>=', '=', '!=', '<', '<=', 'notNull']\n      }\n    }\n  }\n};\n\nvar data = {\n  type: 'object',\n  properties: {\n    // data source\n    formatType: {\n      type: 'string',\n      enum: ['json', 'csv'],\n      default: 'json'\n    },\n    url: {\n      type: 'string',\n      default: undefined\n    },\n    vegaServer: {\n      type: 'object',\n      default: null,\n      properties: {\n        table: {\n          type: 'string',\n          default: undefined\n        },\n        url: {\n          type: 'string',\n          default: 'http://localhost:3001'\n        }\n      }\n    }\n  }\n};\n\nconsole.log(schema.util.instantiate(data));\n\nvar config = {\n  type: 'object',\n  properties: {\n    // template\n    width: {\n      type: 'integer',\n      default: undefined\n    },\n    height: {\n      type: 'integer',\n      default: undefined\n    },\n    viewport: {\n      type: 'array',\n      items: {\n        type: 'integer'\n      },\n      default: undefined\n    },\n    gridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#eeeeee'\n    },\n\n    // filter null\n    filterNull: {\n      type: 'object',\n      properties: {\n        O: {type:'boolean', default: false},\n        Q: {type:'boolean', default: true},\n        T: {type:'boolean', default: true}\n      }\n    },\n    toggleSort: {\n      type: 'string',\n      default: 'O'\n    },\n\n    // single plot\n    singleHeight: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    singleWidth: {\n      // will be overwritten by bandWidth * (cardinality + padding)\n      type: 'integer',\n      default: 200,\n      minimum: 0\n    },\n    // band size\n    largeBandSize: {\n      type: 'integer',\n      default: 21,\n      minimum: 0\n    },\n    smallBandSize: {\n      //small multiples or single plot with high cardinality\n      type: 'integer',\n      default: 12,\n      minimum: 0\n    },\n    largeBandMaxCardinality: {\n      type: 'integer',\n      default: 10\n    },\n    // small multiples\n    cellPadding: {\n      type: 'number',\n      default: 0.1\n    },\n    cellGridColor: {\n      type: 'string',\n      role: 'color',\n      default: '#aaaaaa'\n    },\n    cellBackgroundColor: {\n      type: 'string',\n      role: 'color',\n      default: 'transparent'\n    },\n    textCellWidth: {\n      type: 'integer',\n      default: 90,\n      minimum: 0\n    },\n\n    // marks\n    strokeWidth: {\n      type: 'integer',\n      default: 2,\n      minimum: 0\n    },\n\n    // scales\n    timeScaleLabelLength: {\n      type: 'integer',\n      default: 3,\n      minimum: 0\n    },\n    // other\n    characterWidth: {\n      type: 'integer',\n      default: 6\n    }\n  }\n};\n\n/** @type Object Schema of a vegalite specification */\nschema.schema = {\n  $schema: 'http://json-schema.org/draft-04/schema#',\n  description: 'Schema for vegalite specification',\n  type: 'object',\n  required: ['marktype', 'enc', 'data', 'config'],\n  properties: {\n    data: data,\n    marktype: schema.marktype,\n    enc: {\n      type: 'object',\n      properties: {\n        x: x,\n        y: y,\n        row: row,\n        col: col,\n        size: size,\n        color: color,\n        alpha: alpha,\n        shape: shape,\n        text: text,\n        detail: detail\n      }\n    },\n    filter: filter,\n    config: config\n  }\n};\n\nschema.encTypes = util.keys(schema.schema.properties.enc.properties);\n\n/** Instantiate a verbose vl spec from the schema */\nschema.instantiate = function() {\n  return schema.util.instantiate(schema.schema);\n};\n","'use strict';\n\nvar schemautil = module.exports = {},\n  util = require('../util');\n\nvar isEmpty = function(obj) {\n  return Object.keys(obj).length === 0;\n};\n\nschemautil.extend = function(instance, schema) {\n  return schemautil.merge(schemautil.instantiate(schema), instance);\n};\n\n// instantiate a schema\nschemautil.instantiate = function(schema) {\n  var val;\n  if (schema === undefined) {\n    return undefined;\n  } else if ('default' in schema) {\n    val = schema.default;\n    return util.isObject(val) ? util.duplicate(val) : val;\n  } else if (schema.type === 'object') {\n    var instance = {};\n    for (var name in schema.properties) {\n      val = schemautil.instantiate(schema.properties[name]);\n      if (val !== undefined) {\n        instance[name] = val;\n      }\n    }\n    return instance;\n  } else if (schema.type === 'array') {\n    return [];\n  }\n  return undefined;\n};\n\n// remove all defaults from an instance\nschemautil.subtract = function(instance, defaults) {\n  var changes = {};\n  for (var prop in instance) {\n    var def = defaults[prop];\n    var ins = instance[prop];\n    // Note: does not properly subtract arrays\n    if (!defaults || def !== ins) {\n      if (typeof ins === 'object' && !util.isArray(ins) && def) {\n        var c = schemautil.subtract(ins, def);\n        if (!isEmpty(c))\n          changes[prop] = c;\n      } else if (!util.isArray(ins) || ins.length > 0) {\n        changes[prop] = ins;\n      }\n    }\n  }\n  return changes;\n};\n\nschemautil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\n// recursively merges src into dest\nfunction merge(dest, src) {\n  if (typeof src !== 'object' || src === null) {\n    return dest;\n  }\n\n  for (var p in src) {\n    if (!src.hasOwnProperty(p)) {\n      continue;\n    }\n    if (src[p] === undefined) {\n      continue;\n    }\n    if (typeof src[p] !== 'object' || src[p] === null) {\n      dest[p] = src[p];\n    } else if (typeof dest[p] !== 'object' || dest[p] === null) {\n      dest[p] = merge(src[p].constructor === Array ? [] : {}, src[p]);\n    } else {\n      merge(dest[p], src[p]);\n    }\n  }\n  return dest;\n}","'use strict';\n\nvar util = module.exports = {};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.vals = function(obj) {\n  var v = [], x;\n  for (x in obj) v.push(obj[x]);\n  return v;\n};\n\nutil.range = function(start, stop, step) {\n  if (arguments.length < 3) {\n    step = 1;\n    if (arguments.length < 2) {\n      stop = start;\n      start = 0;\n    }\n  }\n  if ((stop - start) / step == Infinity) throw new Error('infinite range');\n  var range = [], i = -1, j;\n  if (step < 0) while ((j = start + step * ++i) > stop) range.push(j);\n  else while ((j = start + step * ++i) < stop) range.push(j);\n  return range;\n};\n\nutil.find = function(list, pattern) {\n  var l = list.filter(function(x) {\n    return x[pattern.name] === pattern.value;\n  });\n  return l.length && l[0] || null;\n};\n\nutil.isin = function(item, array) {\n  return array.indexOf(item) !== -1;\n};\n\nutil.uniq = function(data, field) {\n  var map = {}, count = 0, i, k;\n  for (i = 0; i < data.length; ++i) {\n    k = data[i][field];\n    if (!map[k]) {\n      map[k] = 1;\n      count += 1;\n    }\n  }\n  return count;\n};\n\nvar isNumber = function(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\n// try parsing to number\nutil.numbers = function(values) {\n  var nums = [];\n  for (var i = 0; i < values.length; i++) {\n    if (isNumber(values[i])) {\n      nums.push(+values[i]);\n    }\n  }\n  return nums;\n};\n\n// try to parse as date\nutil.dates = function(values) {\n  var dates = [];\n  for (var i = 0; i < values.length; i++) {\n    var date = Date.parse(values[i]);\n    if (!isNaN(date)) {\n      dates.push(new Date(date));\n    }\n  }\n  return dates;\n};\n\nutil.median = function(values) {\n  values.sort(function(a, b) {return a - b;});\n  var half = Math.floor(values.length/2);\n  if (values.length % 2) {\n    return values[half];\n  } else {\n    return (values[half-1] + values[half]) / 2.0;\n  }\n};\n\nutil.mean = function(values) {\n  return values.reduce(function(v, r) {return v + r;}, 0) / values.length;\n};\n\nutil.variance = function(values) {\n  var avg = util.mean(values);\n  var diffs = [];\n  for (var i = 0; i < values.length; i++) {\n    diffs.push(Math.pow((values[i] - avg), 2));\n  }\n  return util.mean(diffs);\n};\n\nutil.stablesort = function(array, sortBy, keyFn) {\n  var indices = {};\n\n  array.forEach(function(v, i) {\n    indices[keyFn(v)] = i;\n  });\n\n  array.sort(function(a, b) {\n    var sa = sortBy(a),\n      sb = sortBy(b);\n\n    return sa<sb ? -1 : sa>sb ? 1 : (indices[keyFn(a)] - indices[keyFn(b)]);\n  });\n  return array;\n};\n\nutil.stdev = function(values) {\n  return Math.sqrt(util.variance(values));\n};\n\nutil.skew = function(values) {\n  var avg = util.mean(values),\n    med = util.median(values),\n    std = util.stdev(values);\n  return 1.0 * (avg - med) / std;\n};\n\n// parses a string to date or number\nutil.parse = function(value) {\n  if (isNumber(value)) {\n    return +value;\n  }\n\n  var date = Date.parse(value);\n  if (!isNaN(date)) {\n    return (new Date(date));\n  }\n  return value;\n};\n\nutil.minmax = function(data) {\n  var stats = {min: +Infinity, max: -Infinity};\n  for (var i = 0; i < data.length; ++i) {\n    var v = data[i];\n    if (v !== null) {\n      if (v > stats.max || stats.max === -Infinity) stats.max = v;\n      if (v < stats.min || stats.min === +Infinity) stats.min = v;\n    }\n  }\n  return stats;\n};\n\nutil.duplicate = function(obj) {\n  return JSON.parse(JSON.stringify(obj));\n};\n\nutil.isObject = function(obj) {\n  return obj === Object(obj);\n};\n\nutil.isArray = Array.isArray || function(obj) {\n  return toString.call(obj) == '[object Array]';\n};\n\nutil.array = function(x) {\n  return x ? (util.isArray(x) ? x : [x]) : [];\n};\n\nutil.forEach = function(obj, f, thisArg) {\n  if (obj.forEach) {\n    obj.forEach.call(thisArg, f);\n  } else {\n    for (var k in obj) {\n      f.call(thisArg, obj[k], k , obj);\n    }\n  }\n};\n\nutil.reduce = function(obj, f, init, thisArg) {\n  if (obj.reduce) {\n    return obj.reduce.call(thisArg, f, init);\n  } else {\n    for (var k in obj) {\n      init = f.call(thisArg, init, obj[k], k, obj);\n    }\n    return init;\n  }\n};\n\nutil.map = function(obj, f, thisArg) {\n  if (obj.map) {\n    return obj.map.call(thisArg, f);\n  } else {\n    var output = [];\n    for (var k in obj) {\n      output.push( f.call(thisArg, obj[k], k, obj));\n    }\n  }\n};\n\nutil.any = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (f(arr[k], k, i++)) return true;\n  }\n  return false;\n};\n\nutil.all = function(arr, f) {\n  var i = 0, k;\n  for (k in arr) {\n    if (!f(arr[k], k, i++)) return false;\n  }\n  return true;\n};\n\n\nutil.cmp = function(a, b) {\n  if (a < b) {\n    return -1;\n  } else if (a > b) {\n    return 1;\n  } else if (a >= b) {\n    return 0;\n  } else if (a === null && b === null) {\n    return 0;\n  } else if (a === null) {\n    return -1;\n  } else if (b === null) {\n    return 1;\n  }\n  return NaN;\n};\n\nvar merge = function(dest, src) {\n  return util.keys(src).reduce(function(c, k) {\n    c[k] = src[k];\n    return c;\n  }, dest);\n};\n\nutil.merge = function(/*dest*, src0, src1, ...*/){\n  var dest = arguments[0];\n  for (var i=1 ; i<arguments.length; i++) {\n    dest = merge(dest, arguments[i]);\n  }\n  return dest;\n};\n\nutil.getbins = function(stats, maxbins) {\n  return util.bins({\n    min: stats.min,\n    max: stats.max,\n    maxbins: maxbins\n  });\n};\n\n\nutil.bins = function(opt) {\n  opt = opt || {};\n\n  // determine range\n  var maxb = opt.maxbins || 1024,\n      base = opt.base || 10,\n      div = opt.div || [5, 2],\n      mins = opt.minstep || 0,\n      logb = Math.log(base),\n      level = Math.ceil(Math.log(maxb) / logb),\n      min = opt.min,\n      max = opt.max,\n      span = max - min,\n      step = Math.max(mins, Math.pow(base, Math.round(Math.log(span) / logb) - level)),\n      nbins = Math.ceil(span / step),\n      precision, v, i, eps;\n\n  if (opt.step) {\n    step = opt.step;\n  } else if (opt.steps) {\n    // if provided, limit choice to acceptable step sizes\n    step = opt.steps[Math.min(\n        opt.steps.length - 1,\n        util_bisectLeft(opt.steps, span / maxb, 0, opt.steps.length)\n    )];\n  } else {\n    // increase step size if too many bins\n    do {\n      step *= base;\n      nbins = Math.ceil(span / step);\n    } while (nbins > maxb);\n\n    // decrease step size if allowed\n    for (i = 0; i < div.length; ++i) {\n      v = step / div[i];\n      if (v >= mins && span / v <= maxb) {\n        step = v;\n        nbins = Math.ceil(span / step);\n      }\n    }\n  }\n\n  // update precision, min and max\n  v = Math.log(step);\n  precision = v >= 0 ? 0 : ~~(-v / logb) + 1;\n  eps = (min<0 ? -1 : 1) * Math.pow(base, -precision - 1);\n  min = Math.min(min, Math.floor(min / step + eps) * step);\n  max = Math.ceil(max / step) * step;\n\n  return {\n    start: min,\n    stop: max,\n    step: step,\n    unit: precision\n  };\n};\n\nfunction util_bisectLeft(a, x, lo, hi) {\n  while (lo < hi) {\n    var mid = lo + hi >>> 1;\n    if (util.cmp(a[mid], x) < 0) { lo = mid + 1; }\n    else { hi = mid; }\n  }\n  return lo;\n}\n\n/**\n * x[p[0]]...[p[n]] = val\n * @param noaugment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.setter = function(x, p, val, noaugment) {\n  for (var i=0; i<p.length-1; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  x[p[i]] = val;\n};\n\n\n/**\n * returns x[p[0]]...[p[n]]\n * @param augment determine whether new object should be added f\n * or non-existing properties along the path\n */\nutil.getter = function(x, p, noaugment) {\n  for (var i=0; i<p.length; ++i) {\n    if (!noaugment && !(p[i] in x)){\n      x = x[p[i]] = {};\n    } else {\n      x = x[p[i]];\n    }\n  }\n  return x;\n};\n\nutil.truncate = function(s, length, pos, word, ellipsis) {\n  var len = s.length;\n  if (len <= length) return s;\n  ellipsis = ellipsis || \"...\";\n  var l = Math.max(0, length - ellipsis.length);\n\n  switch (pos) {\n    case \"left\":\n      return ellipsis + (word ? vg_truncateOnWord(s,l,1) : s.slice(len-l));\n    case \"middle\":\n    case \"center\":\n      var l1 = Math.ceil(l/2), l2 = Math.floor(l/2);\n      return (word ? vg_truncateOnWord(s,l1) : s.slice(0,l1)) + ellipsis +\n        (word ? vg_truncateOnWord(s,l2,1) : s.slice(len-l2));\n    default:\n      return (word ? vg_truncateOnWord(s,l) : s.slice(0,l)) + ellipsis;\n  }\n};\n\nfunction vg_truncateOnWord(s, len, rev) {\n  var cnt = 0, tok = s.split(vg_truncate_word_re);\n  if (rev) {\n    s = (tok = tok.reverse())\n      .filter(function(w) { cnt += w.length; return cnt <= len; })\n      .reverse();\n  } else {\n    s = tok.filter(function(w) { cnt += w.length; return cnt <= len; });\n  }\n  return s.length ? s.join(\"\").trim() : tok[0].slice(0, len);\n}\n\nvar vg_truncate_word_re = /([\\u0009\\u000A\\u000B\\u000C\\u000D\\u0020\\u00A0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u2028\\u2029\\u3000\\uFEFF])/;\n\n\nutil.error = function(msg) {\n  console.error('[VL Error]', msg);\n};\n\n"],"sourceRoot":"/source/"}