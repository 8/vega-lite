import { assert } from 'chai';
import { Channel, SCALE_CHANNELS } from '../src/channel';
import * as scale from '../src/scale';
import { channelSupportScaleType, CONTINUOUS_TO_CONTINUOUS_SCALES, getSupportedScaleType, SCALE_TYPES, ScaleType } from '../src/scale';
import { Type } from '../src/type';
import { some, without } from '../src/util';
describe('scale', function () {
    describe('scaleTypeSupportProperty', function () {
        // Make sure we always edit this when we add new channel
        it('should have at least one supported scale types for all scale properties', function () {
            var _loop_1 = function (prop) {
                assert(some(scale.SCALE_TYPES, function (scaleType) {
                    return scale.scaleTypeSupportProperty(scaleType, prop);
                }));
            };
            for (var _i = 0, _a = scale.SCALE_PROPERTIES; _i < _a.length; _i++) {
                var prop = _a[_i];
                _loop_1(prop);
            }
        });
        // TODO: write more test blindly (Don't look at our code, just look at D3 code.)
        assert.isFalse(scale.scaleTypeSupportProperty('bin-linear', 'zero'));
    });
    describe('scaleTypes', function () {
        it('should either hasContinuousDomain or hasDiscreteDomain', function () {
            for (var _i = 0, _a = scale.SCALE_TYPES; _i < _a.length; _i++) {
                var scaleType = _a[_i];
                assert(scale.hasContinuousDomain(scaleType) !== scale.hasDiscreteDomain(scaleType));
            }
        });
    });
    describe('channelSupportScaleType', function () {
        // Make sure we always edit this when we add new channel
        it('should have at least one supported scale types for all channels with scale', function () {
            var _loop_2 = function (channel) {
                assert(some(SCALE_TYPES, function (scaleType) {
                    return channelSupportScaleType(channel, scaleType);
                }));
            };
            for (var _i = 0, SCALE_CHANNELS_1 = SCALE_CHANNELS; _i < SCALE_CHANNELS_1.length; _i++) {
                var channel = SCALE_CHANNELS_1[_i];
                _loop_2(channel);
            }
        });
        // Make sure we always edit this when we add new scale type
        it('should have at least one supported channel for all scale types', function () {
            var _loop_3 = function (scaleType) {
                assert(some(SCALE_CHANNELS, function (channel) {
                    return channelSupportScaleType(channel, scaleType);
                }));
            };
            for (var _i = 0, SCALE_TYPES_1 = SCALE_TYPES; _i < SCALE_TYPES_1.length; _i++) {
                var scaleType = SCALE_TYPES_1[_i];
                _loop_3(scaleType);
            }
        });
        it('shape should support only ordinal', function () {
            assert(channelSupportScaleType('shape', 'ordinal'));
            var nonOrdinal = without(SCALE_TYPES, ['ordinal']);
            for (var _i = 0, nonOrdinal_1 = nonOrdinal; _i < nonOrdinal_1.length; _i++) {
                var scaleType = nonOrdinal_1[_i];
                assert(!channelSupportScaleType('shape', scaleType));
            }
        });
        it('color should support all scale types except band', function () {
            for (var _i = 0, SCALE_TYPES_2 = SCALE_TYPES; _i < SCALE_TYPES_2.length; _i++) {
                var scaleType = SCALE_TYPES_2[_i];
                assert.equal(channelSupportScaleType('color', scaleType), scaleType !== 'band');
            }
        });
        it('x, y, size, opacity should support all continuous scale type as well as band and point', function () {
            // x,y should use either band or point for ordinal input
            var scaleTypes = CONTINUOUS_TO_CONTINUOUS_SCALES.concat([ScaleType.BAND, ScaleType.POINT]);
            for (var _i = 0, _a = ['x', 'y', 'size', 'opacity']; _i < _a.length; _i++) {
                var channel = _a[_i];
                assert(!channelSupportScaleType(channel, 'ordinal'));
                assert(!channelSupportScaleType(channel, 'sequential'));
                for (var _b = 0, scaleTypes_1 = scaleTypes; _b < scaleTypes_1.length; _b++) {
                    var scaleType = scaleTypes_1[_b];
                    assert(channelSupportScaleType(channel, scaleType), "Error: " + channel + ", " + scaleType);
                }
            }
        });
    });
    describe('getSupportedScaleType', function () {
        it('should return correct scale types for quantitative positional channels', function () {
            var type = Type.QUANTITATIVE;
            var positionalScaleTypes = [ScaleType.LINEAR, ScaleType.LOG, ScaleType.POW, ScaleType.SQRT];
            // x channel
            var scaleTypes = getSupportedScaleType(Channel.X, type);
            assert.deepEqual(positionalScaleTypes, scaleTypes);
            // y channel
            scaleTypes = getSupportedScaleType(Channel.Y, Type.QUANTITATIVE);
            assert.deepEqual(scaleTypes, positionalScaleTypes);
        });
        it('should return correct scale types for quantitative positional channels with bin', function () {
            var type = Type.QUANTITATIVE;
            var positionalScaleTypesBinned = [ScaleType.LINEAR, ScaleType.BIN_LINEAR];
            // x channel
            var scaleTypes = getSupportedScaleType(Channel.X, type, true);
            assert.deepEqual(scaleTypes, positionalScaleTypesBinned);
            // y channel
            scaleTypes = getSupportedScaleType(Channel.Y, type, true);
            assert.deepEqual(scaleTypes, positionalScaleTypesBinned);
        });
        it('should return correct scale types for nominal positional channels', function () {
            var type = Type.NOMINAL;
            var nominalPositionalScaleTypes = [ScaleType.POINT, ScaleType.BAND];
            var scaleTypes = getSupportedScaleType(Channel.X, type);
            assert.deepEqual(scaleTypes, nominalPositionalScaleTypes);
            scaleTypes = getSupportedScaleType(Channel.Y, type);
            assert.deepEqual(scaleTypes, nominalPositionalScaleTypes);
        });
        it('should return correct scale types for temporal positional channels', function () {
            var type = Type.TEMPORAL;
            var temporalPositionalScaleTypes = [ScaleType.TIME, ScaleType.UTC];
            var scaleTypes = getSupportedScaleType(Channel.X, type);
            assert.deepEqual(scaleTypes, temporalPositionalScaleTypes);
            scaleTypes = getSupportedScaleType(Channel.Y, type);
            assert.deepEqual(scaleTypes, temporalPositionalScaleTypes);
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NhbGUudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3Rlc3Qvc2NhbGUudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBQzVCLE9BQU8sRUFBQyxPQUFPLEVBQUUsY0FBYyxFQUFlLE1BQU0sZ0JBQWdCLENBQUM7QUFDckUsT0FBTyxLQUFLLEtBQUssTUFBTSxjQUFjLENBQUM7QUFDdEMsT0FBTyxFQUNMLHVCQUF1QixFQUN2QiwrQkFBK0IsRUFBRSxxQkFBcUIsRUFDdEQsV0FBVyxFQUNYLFNBQVMsRUFDVixNQUFNLGNBQWMsQ0FBQztBQUN0QixPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQ2pDLE9BQU8sRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBRTFDLFFBQVEsQ0FBQyxPQUFPLEVBQUU7SUFDaEIsUUFBUSxDQUFDLDBCQUEwQixFQUFFO1FBQ25DLHdEQUF3RDtRQUN4RCxFQUFFLENBQUMseUVBQXlFLEVBQUU7b0NBQ2pFLElBQUk7Z0JBQ2IsTUFBTSxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsV0FBVyxFQUFFLFVBQUMsU0FBUztvQkFDdkMsT0FBTyxLQUFLLENBQUMsd0JBQXdCLENBQUMsU0FBUyxFQUFFLElBQUksQ0FBQyxDQUFDO2dCQUN6RCxDQUFDLENBQUMsQ0FBQyxDQUFDO1lBQ04sQ0FBQztZQUpELEtBQW1CLFVBQXNCLEVBQXRCLEtBQUEsS0FBSyxDQUFDLGdCQUFnQixFQUF0QixjQUFzQixFQUF0QixJQUFzQjtnQkFBcEMsSUFBTSxJQUFJLFNBQUE7d0JBQUosSUFBSTthQUlkO1FBQ0gsQ0FBQyxDQUFDLENBQUM7UUFFSCxnRkFBZ0Y7UUFFaEYsTUFBTSxDQUFDLE9BQU8sQ0FBQyxLQUFLLENBQUMsd0JBQXdCLENBQUMsWUFBWSxFQUFFLE1BQU0sQ0FBQyxDQUFDLENBQUM7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QUUsNEJBQTRCLENBQUMsQ0FBQztZQUUzRCxVQUFVLEdBQUcscUJBQXFCLENBQUMsT0FBTyxDQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQztZQUNwRCxNQUFNLENBQUMsU0FBUyxDQUFDLFVBQVUsRUFBRSw0QkFBNEIsQ0FBQyxDQUFDO1FBQzdELENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YXNzZXJ0fSBmcm9tICdjaGFpJztcbmltcG9ydCB7Q2hhbm5lbCwgU0NBTEVfQ0hBTk5FTFMsIFNjYWxlQ2hhbm5lbH0gZnJvbSAnLi4vc3JjL2NoYW5uZWwnO1xuaW1wb3J0ICogYXMgc2NhbGUgZnJvbSAnLi4vc3JjL3NjYWxlJztcbmltcG9ydCB7XG4gIGNoYW5uZWxTdXBwb3J0U2NhbGVUeXBlLFxuICBDT05USU5VT1VTX1RPX0NPTlRJTlVPVVNfU0NBTEVTLCBnZXRTdXBwb3J0ZWRTY2FsZVR5cGUsXG4gIFNDQUxFX1RZUEVTLFxuICBTY2FsZVR5cGVcbn0gZnJvbSAnLi4vc3JjL3NjYWxlJztcbmltcG9ydCB7VHlwZX0gZnJvbSAnLi4vc3JjL3R5cGUnO1xuaW1wb3J0IHtzb21lLCB3aXRob3V0fSBmcm9tICcuLi9zcmMvdXRpbCc7XG5cbmRlc2NyaWJlKCdzY2FsZScsICgpID0+IHtcbiAgZGVzY3JpYmUoJ3NjYWxlVHlwZVN1cHBvcnRQcm9wZXJ0eScsICgpID0+IHtcbiAgICAvLyBNYWtlIHN1cmUgd2UgYWx3YXlzIGVkaXQgdGhpcyB3aGVuIHdlIGFkZCBuZXcgY2hhbm5lbFxuICAgIGl0KCdzaG91bGQgaGF2ZSBhdCBsZWFzdCBvbmUgc3VwcG9ydGVkIHNjYWxlIHR5cGVzIGZvciBhbGwgc2NhbGUgcHJvcGVydGllcycsICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgcHJvcCBvZiBzY2FsZS5TQ0FMRV9QUk9QRVJUSUVTKSB7XG4gICAgICAgIGFzc2VydChzb21lKHNjYWxlLlNDQUxFX1RZUEVTLCAoc2NhbGVUeXBlKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHNjYWxlLnNjYWxlVHlwZVN1cHBvcnRQcm9wZXJ0eShzY2FsZVR5cGUsIHByb3ApO1xuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBUT0RPOiB3cml0ZSBtb3JlIHRlc3QgYmxpbmRseSAoRG9uJ3QgbG9vayBhdCBvdXIgY29kZSwganVzdCBsb29rIGF0IEQzIGNvZGUuKVxuXG4gICAgYXNzZXJ0LmlzRmFsc2Uoc2NhbGUuc2NhbGVUeXBlU3VwcG9ydFByb3BlcnR5KCdiaW4tbGluZWFyJywgJ3plcm8nKSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdzY2FsZVR5cGVzJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgZWl0aGVyIGhhc0NvbnRpbnVvdXNEb21haW4gb3IgaGFzRGlzY3JldGVEb21haW4nLCAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHNjYWxlVHlwZSBvZiBzY2FsZS5TQ0FMRV9UWVBFUykge1xuICAgICAgICBhc3NlcnQoc2NhbGUuaGFzQ29udGludW91c0RvbWFpbihzY2FsZVR5cGUpICE9PSBzY2FsZS5oYXNEaXNjcmV0ZURvbWFpbihzY2FsZVR5cGUpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cblxuICBkZXNjcmliZSgnY2hhbm5lbFN1cHBvcnRTY2FsZVR5cGUnLCAoKSA9PiB7XG4gICAgLy8gTWFrZSBzdXJlIHdlIGFsd2F5cyBlZGl0IHRoaXMgd2hlbiB3ZSBhZGQgbmV3IGNoYW5uZWxcbiAgICBpdCgnc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIHN1cHBvcnRlZCBzY2FsZSB0eXBlcyBmb3IgYWxsIGNoYW5uZWxzIHdpdGggc2NhbGUnLCAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgU0NBTEVfQ0hBTk5FTFMpIHtcbiAgICAgICAgYXNzZXJ0KHNvbWUoU0NBTEVfVFlQRVMsIChzY2FsZVR5cGUpID0+IHtcbiAgICAgICAgICByZXR1cm4gY2hhbm5lbFN1cHBvcnRTY2FsZVR5cGUoY2hhbm5lbCwgc2NhbGVUeXBlKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLy8gTWFrZSBzdXJlIHdlIGFsd2F5cyBlZGl0IHRoaXMgd2hlbiB3ZSBhZGQgbmV3IHNjYWxlIHR5cGVcbiAgICBpdCgnc2hvdWxkIGhhdmUgYXQgbGVhc3Qgb25lIHN1cHBvcnRlZCBjaGFubmVsIGZvciBhbGwgc2NhbGUgdHlwZXMnLCAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHNjYWxlVHlwZSBvZiBTQ0FMRV9UWVBFUykge1xuICAgICAgICBhc3NlcnQoc29tZShTQ0FMRV9DSEFOTkVMUywgKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICByZXR1cm4gY2hhbm5lbFN1cHBvcnRTY2FsZVR5cGUoY2hhbm5lbCwgc2NhbGVUeXBlKTtcbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3NoYXBlIHNob3VsZCBzdXBwb3J0IG9ubHkgb3JkaW5hbCcsICgpID0+IHtcbiAgICAgIGFzc2VydChjaGFubmVsU3VwcG9ydFNjYWxlVHlwZSgnc2hhcGUnLCAnb3JkaW5hbCcpKTtcbiAgICAgIGNvbnN0IG5vbk9yZGluYWwgPSB3aXRob3V0PFNjYWxlVHlwZT4oU0NBTEVfVFlQRVMsIFsnb3JkaW5hbCddKTtcbiAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIG5vbk9yZGluYWwpIHtcbiAgICAgICAgYXNzZXJ0KCFjaGFubmVsU3VwcG9ydFNjYWxlVHlwZSgnc2hhcGUnLCBzY2FsZVR5cGUpKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdjb2xvciBzaG91bGQgc3VwcG9ydCBhbGwgc2NhbGUgdHlwZXMgZXhjZXB0IGJhbmQnLCAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IHNjYWxlVHlwZSBvZiBTQ0FMRV9UWVBFUykge1xuICAgICAgICBhc3NlcnQuZXF1YWwoY2hhbm5lbFN1cHBvcnRTY2FsZVR5cGUoJ2NvbG9yJywgc2NhbGVUeXBlKSwgc2NhbGVUeXBlICE9PSAnYmFuZCcpO1xuICAgICAgfVxuICAgIH0pO1xuXG5cbiAgICBpdCgneCwgeSwgc2l6ZSwgb3BhY2l0eSBzaG91bGQgc3VwcG9ydCBhbGwgY29udGludW91cyBzY2FsZSB0eXBlIGFzIHdlbGwgYXMgYmFuZCBhbmQgcG9pbnQnLCAoKSA9PiB7XG4gICAgICAvLyB4LHkgc2hvdWxkIHVzZSBlaXRoZXIgYmFuZCBvciBwb2ludCBmb3Igb3JkaW5hbCBpbnB1dFxuICAgICAgY29uc3Qgc2NhbGVUeXBlcyA9IFsuLi5DT05USU5VT1VTX1RPX0NPTlRJTlVPVVNfU0NBTEVTLCBTY2FsZVR5cGUuQkFORCwgU2NhbGVUeXBlLlBPSU5UXTtcblxuICAgICAgZm9yIChjb25zdCBjaGFubmVsIG9mIFsneCcsICd5JywgJ3NpemUnLCAnb3BhY2l0eSddIGFzIFNjYWxlQ2hhbm5lbFtdKSB7XG4gICAgICAgIGFzc2VydCghY2hhbm5lbFN1cHBvcnRTY2FsZVR5cGUoY2hhbm5lbCwgJ29yZGluYWwnKSk7XG4gICAgICAgIGFzc2VydCghY2hhbm5lbFN1cHBvcnRTY2FsZVR5cGUoY2hhbm5lbCwgJ3NlcXVlbnRpYWwnKSk7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIHNjYWxlVHlwZXMpIHtcbiAgICAgICAgICBhc3NlcnQoY2hhbm5lbFN1cHBvcnRTY2FsZVR5cGUoY2hhbm5lbCwgc2NhbGVUeXBlKSwgYEVycm9yOiAke2NoYW5uZWx9LCAke3NjYWxlVHlwZX1gKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnZ2V0U3VwcG9ydGVkU2NhbGVUeXBlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIGNvcnJlY3Qgc2NhbGUgdHlwZXMgZm9yIHF1YW50aXRhdGl2ZSBwb3NpdGlvbmFsIGNoYW5uZWxzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdHlwZSA9IFR5cGUuUVVBTlRJVEFUSVZFO1xuICAgICAgY29uc3QgcG9zaXRpb25hbFNjYWxlVHlwZXMgPSBbU2NhbGVUeXBlLkxJTkVBUiwgU2NhbGVUeXBlLkxPRywgU2NhbGVUeXBlLlBPVywgU2NhbGVUeXBlLlNRUlRdO1xuXG4gICAgICAvLyB4IGNoYW5uZWxcbiAgICAgIGxldCBzY2FsZVR5cGVzID0gZ2V0U3VwcG9ydGVkU2NhbGVUeXBlKENoYW5uZWwuWCwgdHlwZSk7XG4gICAgICBhc3NlcnQuZGVlcEVxdWFsKHBvc2l0aW9uYWxTY2FsZVR5cGVzLCBzY2FsZVR5cGVzKTtcblxuICAgICAgLy8geSBjaGFubmVsXG4gICAgICBzY2FsZVR5cGVzID0gZ2V0U3VwcG9ydGVkU2NhbGVUeXBlKENoYW5uZWwuWSwgVHlwZS5RVUFOVElUQVRJVkUpO1xuICAgICAgYXNzZXJ0LmRlZXBFcXVhbChzY2FsZVR5cGVzLCBwb3NpdGlvbmFsU2NhbGVUeXBlcyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBjb3JyZWN0IHNjYWxlIHR5cGVzIGZvciBxdWFudGl0YXRpdmUgcG9zaXRpb25hbCBjaGFubmVscyB3aXRoIGJpbicsICgpID0+IHtcbiAgICAgIGNvbnN0IHR5cGUgPSBUeXBlLlFVQU5USVRBVElWRTtcbiAgICAgIGNvbnN0IHBvc2l0aW9uYWxTY2FsZVR5cGVzQmlubmVkID0gW1NjYWxlVHlwZS5MSU5FQVIsIFNjYWxlVHlwZS5CSU5fTElORUFSXTtcblxuICAgICAgLy8geCBjaGFubmVsXG4gICAgICBsZXQgc2NhbGVUeXBlcyA9IGdldFN1cHBvcnRlZFNjYWxlVHlwZShDaGFubmVsLlgsIHR5cGUsIHRydWUpO1xuICAgICAgYXNzZXJ0LmRlZXBFcXVhbChzY2FsZVR5cGVzLCBwb3NpdGlvbmFsU2NhbGVUeXBlc0Jpbm5lZCk7XG5cbiAgICAgIC8vIHkgY2hhbm5lbFxuICAgICAgc2NhbGVUeXBlcyA9IGdldFN1cHBvcnRlZFNjYWxlVHlwZShDaGFubmVsLlksIHR5cGUsIHRydWUpO1xuICAgICAgYXNzZXJ0LmRlZXBFcXVhbChzY2FsZVR5cGVzLCBwb3NpdGlvbmFsU2NhbGVUeXBlc0Jpbm5lZCk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBjb3JyZWN0IHNjYWxlIHR5cGVzIGZvciBub21pbmFsIHBvc2l0aW9uYWwgY2hhbm5lbHMnLCAoKSA9PiB7XG4gICAgICBjb25zdCB0eXBlID0gVHlwZS5OT01JTkFMO1xuICAgICAgY29uc3Qgbm9taW5hbFBvc2l0aW9uYWxTY2FsZVR5cGVzID0gW1NjYWxlVHlwZS5QT0lOVCwgU2NhbGVUeXBlLkJBTkRdO1xuXG4gICAgICBsZXQgc2NhbGVUeXBlcyA9IGdldFN1cHBvcnRlZFNjYWxlVHlwZShDaGFubmVsLlgsIHR5cGUpO1xuICAgICAgYXNzZXJ0LmRlZXBFcXVhbChzY2FsZVR5cGVzLCBub21pbmFsUG9zaXRpb25hbFNjYWxlVHlwZXMpO1xuXG4gICAgICBzY2FsZVR5cGVzID0gZ2V0U3VwcG9ydGVkU2NhbGVUeXBlKENoYW5uZWwuWSwgdHlwZSk7XG4gICAgICBhc3NlcnQuZGVlcEVxdWFsKHNjYWxlVHlwZXMsIG5vbWluYWxQb3NpdGlvbmFsU2NhbGVUeXBlcyk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBjb3JyZWN0IHNjYWxlIHR5cGVzIGZvciB0ZW1wb3JhbCBwb3NpdGlvbmFsIGNoYW5uZWxzJywgKCkgPT4ge1xuICAgICAgY29uc3QgdHlwZSA9IFR5cGUuVEVNUE9SQUw7XG4gICAgICBjb25zdCB0ZW1wb3JhbFBvc2l0aW9uYWxTY2FsZVR5cGVzID0gW1NjYWxlVHlwZS5USU1FLCBTY2FsZVR5cGUuVVRDXTtcblxuICAgICAgbGV0IHNjYWxlVHlwZXMgPSBnZXRTdXBwb3J0ZWRTY2FsZVR5cGUoQ2hhbm5lbC5YLCB0eXBlKTtcbiAgICAgIGFzc2VydC5kZWVwRXF1YWwoc2NhbGVUeXBlcywgdGVtcG9yYWxQb3NpdGlvbmFsU2NhbGVUeXBlcyk7XG5cbiAgICAgIHNjYWxlVHlwZXMgPSBnZXRTdXBwb3J0ZWRTY2FsZVR5cGUoQ2hhbm5lbC5ZLCB0eXBlKTtcbiAgICAgIGFzc2VydC5kZWVwRXF1YWwoc2NhbGVUeXBlcywgdGVtcG9yYWxQb3NpdGlvbmFsU2NhbGVUeXBlcyk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXX0=