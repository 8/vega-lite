import * as tslib_1 from "tslib";
import { assert } from 'chai';
import { AncestorParse } from '../../../src/compile/data';
import { DataFlowNode } from '../../../src/compile/data/dataflow';
import { ParseNode } from '../../../src/compile/data/formatparse';
import { parseTransformArray } from '../../../src/compile/data/parse';
import { parseUnitModel } from '../../util';
describe('compile/data/filter', function () {
    it('should create parse for filtered fields', function () {
        var model = parseUnitModel({
            'data': { 'url': 'a.json' },
            'transform': [
                { 'filter': { 'field': 'a', 'equal': { year: 2000 } } },
                { 'filter': { 'field': 'b', 'oneOf': ['a', 'b'] } },
                { 'filter': { 'field': 'c', 'range': [{ year: 2000 }, { year: 2001 }] } },
                { 'filter': { 'field': 'd', 'range': [1, 2] } }
            ],
            'mark': 'point',
            encoding: {}
        });
        var parse = {};
        // extract the parse from the parse nodes that were generated along with the filter nodes
        var root = new DataFlowNode(null);
        parseTransformArray(root, model, new AncestorParse());
        var node = root.children[0];
        while (node.numChildren() > 0) {
            if (node instanceof ParseNode) {
                parse = tslib_1.__assign({}, parse, node.parse);
            }
            assert.equal(node.numChildren(), 1);
            node = node.children[0];
        }
        assert.deepEqual(parse, {
            a: 'date',
            b: 'string',
            c: 'date',
            d: 'number'
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlsdGVyLnRlc3QuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi90ZXN0L2NvbXBpbGUvZGF0YS9maWx0ZXIudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiO0FBQUEsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUM1QixPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sMkJBQTJCLENBQUM7QUFDeEQsT0FBTyxFQUFDLFlBQVksRUFBQyxNQUFNLG9DQUFvQyxDQUFDO0FBQ2hFLE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSx1Q0FBdUMsQ0FBQztBQUNoRSxPQUFPLEVBQUMsbUJBQW1CLEVBQUMsTUFBTSxpQ0FBaUMsQ0FBQztBQUVwRSxPQUFPLEVBQUMsY0FBYyxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBRTFDLFFBQVEsQ0FBQyxxQkFBcUIsRUFBRTtJQUM5QixFQUFFLENBQUMseUNBQXlDLEVBQUU7UUFDNUMsSUFBTSxLQUFLLEdBQUcsY0FBYyxDQUFDO1lBQzNCLE1BQU0sRUFBRSxFQUFDLEtBQUssRUFBRSxRQUFRLEVBQUM7WUFDekIsV0FBVyxFQUFFO2dCQUNYLEVBQUMsUUFBUSxFQUFFLEVBQUMsT0FBTyxFQUFFLEdBQUcsRUFBRSxPQUFPLEVBQUUsRUFBQyxJQUFJLEVBQUUsSUFBSSxFQUFDLEVBQUMsRUFBQztnQkFDakQsRUFBQyxRQUFRLEVBQUUsRUFBQyxPQUFPLEVBQUUsR0FBRyxFQUFFLE9BQU8sRUFBRSxDQUFDLEdBQUcsRUFBRSxHQUFHLENBQUMsRUFBQyxFQUFDO2dCQUMvQyxFQUFDLFFBQVEsRUFBRSxFQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsRUFBQyxJQUFJLEVBQUUsSUFBSSxFQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUUsSUFBSSxFQUFDLENBQUMsRUFBQyxFQUFDO2dCQUNqRSxFQUFDLFFBQVEsRUFBRSxFQUFDLE9BQU8sRUFBRSxHQUFHLEVBQUUsT0FBTyxFQUFFLENBQUMsQ0FBQyxFQUFFLENBQUMsQ0FBQyxFQUFDLEVBQUM7YUFDNUM7WUFDRCxNQUFNLEVBQUUsT0FBTztZQUNmLFFBQVEsRUFBRSxFQUFFO1NBQ2IsQ0FBQyxDQUFDO1FBRUgsSUFBSSxLQUFLLEdBQWlCLEVBQUUsQ0FBQztRQUU3Qix5RkFBeUY7UUFDekYsSUFBTSxJQUFJLEdBQUcsSUFBSSxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDcEMsbUJBQW1CLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxJQUFJLGFBQWEsRUFBRSxDQUFDLENBQUM7UUFDdEQsSUFBSSxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztRQUU1QixPQUFPLElBQUksQ0FBQyxXQUFXLEVBQUUsR0FBRyxDQUFDLEVBQUU7WUFDN0IsSUFBSSxJQUFJLFlBQVksU0FBUyxFQUFFO2dCQUM3QixLQUFLLHdCQUFPLEtBQUssRUFBSyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7YUFDbkM7WUFDRCxNQUFNLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxXQUFXLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FBQztZQUNwQyxJQUFJLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxDQUFDLENBQUMsQ0FBQztTQUN6QjtRQUVELE1BQU0sQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFO1lBQ3RCLENBQUMsRUFBRSxNQUFNO1lBQ1QsQ0FBQyxFQUFFLFFBQVE7WUFDWCxDQUFDLEVBQUUsTUFBTTtZQUNULENBQUMsRUFBRSxRQUFRO1NBQ1osQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7YXNzZXJ0fSBmcm9tICdjaGFpJztcbmltcG9ydCB7QW5jZXN0b3JQYXJzZX0gZnJvbSAnLi4vLi4vLi4vc3JjL2NvbXBpbGUvZGF0YSc7XG5pbXBvcnQge0RhdGFGbG93Tm9kZX0gZnJvbSAnLi4vLi4vLi4vc3JjL2NvbXBpbGUvZGF0YS9kYXRhZmxvdyc7XG5pbXBvcnQge1BhcnNlTm9kZX0gZnJvbSAnLi4vLi4vLi4vc3JjL2NvbXBpbGUvZGF0YS9mb3JtYXRwYXJzZSc7XG5pbXBvcnQge3BhcnNlVHJhbnNmb3JtQXJyYXl9IGZyb20gJy4uLy4uLy4uL3NyYy9jb21waWxlL2RhdGEvcGFyc2UnO1xuaW1wb3J0IHtEaWN0fSBmcm9tICcuLi8uLi8uLi9zcmMvdXRpbCc7XG5pbXBvcnQge3BhcnNlVW5pdE1vZGVsfSBmcm9tICcuLi8uLi91dGlsJztcblxuZGVzY3JpYmUoJ2NvbXBpbGUvZGF0YS9maWx0ZXInLCAoKSA9PiB7XG4gIGl0KCdzaG91bGQgY3JlYXRlIHBhcnNlIGZvciBmaWx0ZXJlZCBmaWVsZHMnLCAoKSA9PiB7XG4gICAgY29uc3QgbW9kZWwgPSBwYXJzZVVuaXRNb2RlbCh7XG4gICAgICAnZGF0YSc6IHsndXJsJzogJ2EuanNvbid9LFxuICAgICAgJ3RyYW5zZm9ybSc6IFtcbiAgICAgICAgeydmaWx0ZXInOiB7J2ZpZWxkJzogJ2EnLCAnZXF1YWwnOiB7eWVhcjogMjAwMH19fSxcbiAgICAgICAgeydmaWx0ZXInOiB7J2ZpZWxkJzogJ2InLCAnb25lT2YnOiBbJ2EnLCAnYiddfX0sXG4gICAgICAgIHsnZmlsdGVyJzogeydmaWVsZCc6ICdjJywgJ3JhbmdlJzogW3t5ZWFyOiAyMDAwfSwge3llYXI6IDIwMDF9XX19LFxuICAgICAgICB7J2ZpbHRlcic6IHsnZmllbGQnOiAnZCcsICdyYW5nZSc6IFsxLCAyXX19XG4gICAgICBdLFxuICAgICAgJ21hcmsnOiAncG9pbnQnLFxuICAgICAgZW5jb2Rpbmc6IHt9XG4gICAgfSk7XG5cbiAgICBsZXQgcGFyc2U6IERpY3Q8c3RyaW5nPiA9IHt9O1xuXG4gICAgLy8gZXh0cmFjdCB0aGUgcGFyc2UgZnJvbSB0aGUgcGFyc2Ugbm9kZXMgdGhhdCB3ZXJlIGdlbmVyYXRlZCBhbG9uZyB3aXRoIHRoZSBmaWx0ZXIgbm9kZXNcbiAgICBjb25zdCByb290ID0gbmV3IERhdGFGbG93Tm9kZShudWxsKTtcbiAgICBwYXJzZVRyYW5zZm9ybUFycmF5KHJvb3QsIG1vZGVsLCBuZXcgQW5jZXN0b3JQYXJzZSgpKTtcbiAgICBsZXQgbm9kZSA9IHJvb3QuY2hpbGRyZW5bMF07XG5cbiAgICB3aGlsZSAobm9kZS5udW1DaGlsZHJlbigpID4gMCkge1xuICAgICAgaWYgKG5vZGUgaW5zdGFuY2VvZiBQYXJzZU5vZGUpIHtcbiAgICAgICAgcGFyc2UgPSB7Li4ucGFyc2UsIC4uLm5vZGUucGFyc2V9O1xuICAgICAgfVxuICAgICAgYXNzZXJ0LmVxdWFsKG5vZGUubnVtQ2hpbGRyZW4oKSwgMSk7XG4gICAgICBub2RlID0gbm9kZS5jaGlsZHJlblswXTtcbiAgICB9XG5cbiAgICBhc3NlcnQuZGVlcEVxdWFsKHBhcnNlLCB7XG4gICAgICBhOiAnZGF0ZScsXG4gICAgICBiOiAnc3RyaW5nJyxcbiAgICAgIGM6ICdkYXRlJyxcbiAgICAgIGQ6ICdudW1iZXInXG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXX0=