/* tslint:disable:quotemark */
import { assert } from 'chai';
import { parseRangeForChannel } from '../../../src/compile/scale/range';
import { makeExplicit, makeImplicit } from '../../../src/compile/split';
import { defaultConfig } from '../../../src/config';
import * as log from '../../../src/log';
import { CONTINUOUS_TO_CONTINUOUS_SCALES, DISCRETE_DOMAIN_SCALES } from '../../../src/scale';
import { NOMINAL, ORDINAL, QUANTITATIVE } from '../../../src/type';
describe('compile/scale', function () {
    describe('parseRange()', function () {
        describe('position', function () {
            it('should return [0, plot_width] for x-continuous scales by default.', function () {
                for (var _i = 0, CONTINUOUS_TO_CONTINUOUS_SCALES_1 = CONTINUOUS_TO_CONTINUOUS_SCALES; _i < CONTINUOUS_TO_CONTINUOUS_SCALES_1.length; _i++) {
                    var scaleType = CONTINUOUS_TO_CONTINUOUS_SCALES_1[_i];
                    assert.deepEqual(parseRangeForChannel('x', scaleType, QUANTITATIVE, {}, defaultConfig, true, 'point', false, 'plot_width', []), makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should return [plot_height,0] for y-continuous scales by default.', function () {
                for (var _i = 0, CONTINUOUS_TO_CONTINUOUS_SCALES_2 = CONTINUOUS_TO_CONTINUOUS_SCALES; _i < CONTINUOUS_TO_CONTINUOUS_SCALES_2.length; _i++) {
                    var scaleType = CONTINUOUS_TO_CONTINUOUS_SCALES_2[_i];
                    assert.deepEqual(parseRangeForChannel('y', scaleType, QUANTITATIVE, {}, defaultConfig, true, 'point', false, 'plot_height', []), makeImplicit([{ signal: 'plot_height' }, 0]));
                }
            });
            it('should return [0, plot_height] for y-discrete scales with height by default.', function () {
                for (var _i = 0, DISCRETE_DOMAIN_SCALES_1 = DISCRETE_DOMAIN_SCALES; _i < DISCRETE_DOMAIN_SCALES_1.length; _i++) {
                    var scaleType = DISCRETE_DOMAIN_SCALES_1[_i];
                    assert.deepEqual(parseRangeForChannel('y', scaleType, QUANTITATIVE, {}, defaultConfig, true, 'point', true, 'plot_height', []), makeImplicit([0, { signal: 'plot_height' }]));
                }
            });
            it('should support custom range.', log.wrap(function (localLogger) {
                assert.deepEqual(parseRangeForChannel('x', 'linear', QUANTITATIVE, { range: [0, 100] }, defaultConfig, true, 'point', false, 'plot_width', []), makeExplicit([0, 100]));
                assert.deepEqual(localLogger.warns.length, 0);
            }));
            it('should return config.scale.rangeStep for band/point scales by default.', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    assert.deepEqual(parseRangeForChannel('x', scaleType, NOMINAL, {}, defaultConfig, undefined, 'point', false, 'plot_width', []), makeImplicit({ step: 21 }));
                }
            });
            it('should return config.scale.textXRangeStep by default for text mark\'s x band/point scales.', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    assert.deepEqual(parseRangeForChannel('x', scaleType, NOMINAL, {}, { scale: { textXRangeStep: 55 } }, undefined, 'text', false, 'plot_width', []), makeImplicit({ step: 55 }));
                }
            });
            it('should return specified rangeStep if topLevelSize is undefined for band/point scales', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    assert.deepEqual(parseRangeForChannel('x', scaleType, NOMINAL, { rangeStep: 23 }, defaultConfig, undefined, 'text', false, 'plot_width', []), makeExplicit({ step: 23 }));
                }
            });
            it('should drop rangeStep if topLevelSize is specified for band/point scales', log.wrap(function (localLogger) {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    assert.deepEqual(parseRangeForChannel('x', scaleType, NOMINAL, { rangeStep: 23 }, defaultConfig, undefined, 'text', true, 'plot_width', []), makeImplicit([0, { signal: 'plot_width' }]));
                }
                assert.equal(localLogger.warns[0], log.message.rangeStepDropped('x'));
            }));
            it('should return default topLevelSize if rangeStep is null for band/point scales', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    assert.deepEqual(parseRangeForChannel('x', scaleType, NOMINAL, { rangeStep: null }, defaultConfig, undefined, 'text', false, 'plot_width', []), makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should return default topLevelSize if rangeStep config is null', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    assert.deepEqual(parseRangeForChannel('x', scaleType, NOMINAL, {}, { view: { width: 200 }, scale: { rangeStep: null } }, undefined, 'point', false, 'plot_width', []), makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should return default topLevelSize for text if textXRangeStep config is null', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    assert.deepEqual(parseRangeForChannel('x', scaleType, NOMINAL, {}, { view: { width: 200 }, scale: { textXRangeStep: null } }, undefined, 'text', false, 'plot_width', []), makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should drop rangeStep for continuous scales', function () {
                var _loop_1 = function (scaleType) {
                    log.wrap(function (localLogger) {
                        assert.deepEqual(parseRangeForChannel('x', scaleType, QUANTITATIVE, { rangeStep: 23 }, defaultConfig, undefined, 'text', true, 'plot_width', []), makeImplicit([0, { signal: 'plot_width' }]));
                        assert.equal(localLogger.warns[0], log.message.scalePropertyNotWorkWithScaleType(scaleType, 'rangeStep', 'x'));
                    })();
                };
                for (var _i = 0, CONTINUOUS_TO_CONTINUOUS_SCALES_3 = CONTINUOUS_TO_CONTINUOUS_SCALES; _i < CONTINUOUS_TO_CONTINUOUS_SCALES_3.length; _i++) {
                    var scaleType = CONTINUOUS_TO_CONTINUOUS_SCALES_3[_i];
                    _loop_1(scaleType);
                }
            });
        });
        describe('color', function () {
            it('should use the specified scheme for a nominal color field.', function () {
                assert.deepEqual(parseRangeForChannel('color', 'ordinal', NOMINAL, { scheme: 'warm' }, defaultConfig, undefined, 'point', false, 'plot_width', []), makeExplicit({ scheme: 'warm' }));
            });
            it('should use the specified scheme with extent for a nominal color field.', function () {
                assert.deepEqual(parseRangeForChannel('color', 'ordinal', NOMINAL, { scheme: { name: 'warm', extent: [0.2, 1] } }, defaultConfig, undefined, 'point', false, 'plot_width', []), makeExplicit({ scheme: 'warm', extent: [0.2, 1] }));
            });
            it('should use the specified range for a nominal color field.', function () {
                assert.deepEqual(parseRangeForChannel('color', 'ordinal', NOMINAL, { range: ['red', 'green', 'blue'] }, defaultConfig, undefined, 'point', false, 'plot_width', []), makeExplicit(['red', 'green', 'blue']));
            });
            it('should use default category range in Vega for a nominal color field.', function () {
                assert.deepEqual(parseRangeForChannel('color', 'ordinal', NOMINAL, {}, defaultConfig, undefined, 'point', false, 'plot_width', []), makeImplicit('category'));
            });
            it('should use default ordinal range in Vega for an ordinal color field.', function () {
                assert.deepEqual(parseRangeForChannel('color', 'ordinal', ORDINAL, {}, defaultConfig, undefined, 'point', false, 'plot_width', []), makeImplicit('ordinal'));
            });
            it('should use default ramp range in Vega for a temporal/quantitative color field.', function () {
                assert.deepEqual(parseRangeForChannel('color', 'sequential', QUANTITATIVE, {}, defaultConfig, undefined, 'point', false, 'plot_width', []), makeImplicit('ramp'));
            });
            it('should use the specified scheme with count for a quantitative color field.', function () {
                assert.deepEqual(parseRangeForChannel('color', 'ordinal', QUANTITATIVE, { scheme: { name: 'viridis', count: 3 } }, defaultConfig, undefined, 'point', false, 'plot_width', []), makeExplicit({ scheme: 'viridis', count: 3 }));
            });
        });
        describe('opacity', function () {
            it('should use default opacityRange as opacity\'s scale range.', function () {
                assert.deepEqual(parseRangeForChannel('opacity', 'linear', QUANTITATIVE, {}, defaultConfig, undefined, 'point', false, 'plot_width', []), makeImplicit([defaultConfig.scale.minOpacity, defaultConfig.scale.maxOpacity]));
            });
        });
        describe('size', function () {
            describe('bar', function () {
                it('should return [minBandSize, maxBandSize] if both are specified', function () {
                    var config = {
                        scale: { minBandSize: 2, maxBandSize: 9 }
                    };
                    assert.deepEqual(parseRangeForChannel('size', 'linear', QUANTITATIVE, {}, config, undefined, 'bar', false, 'plot_width', []), makeImplicit([2, 9]));
                });
                it('should return [continuousBandSize, xRangeStep-1] by default since min/maxSize config are not specified', function () {
                    assert.deepEqual(parseRangeForChannel('size', 'linear', QUANTITATIVE, {}, defaultConfig, undefined, 'bar', false, 'plot_width', []), makeImplicit([2, defaultConfig.scale.rangeStep - 1]));
                });
            });
            describe('tick', function () {
                it('should return [minBandSize, maxBandSize] if both are specified', function () {
                    var config = {
                        scale: { minBandSize: 4, maxBandSize: 9 }
                    };
                    assert.deepEqual(parseRangeForChannel('size', 'linear', QUANTITATIVE, {}, config, undefined, 'tick', false, 'plot_width', []), makeImplicit([4, 9]));
                });
                it('should return [(default)minBandSize, rangeStep-1] by default since maxSize config is not specified', function () {
                    assert.deepEqual(parseRangeForChannel('size', 'linear', QUANTITATIVE, {}, defaultConfig, undefined, 'tick', false, 'plot_width', []), makeImplicit([defaultConfig.scale.minBandSize, defaultConfig.scale.rangeStep - 1]));
                });
            });
            describe('text', function () {
                it('should return [minFontSize, maxFontSize]', function () {
                    assert.deepEqual(parseRangeForChannel('size', 'linear', QUANTITATIVE, {}, defaultConfig, undefined, 'text', false, 'plot_width', []), makeImplicit([defaultConfig.scale.minFontSize, defaultConfig.scale.maxFontSize]));
                });
            });
            describe('rule', function () {
                it('should return [minStrokeWidth, maxStrokeWidth]', function () {
                    assert.deepEqual(parseRangeForChannel('size', 'linear', QUANTITATIVE, {}, defaultConfig, undefined, 'rule', false, 'plot_width', []), makeImplicit([defaultConfig.scale.minStrokeWidth, defaultConfig.scale.maxStrokeWidth]));
                });
            });
            describe('point, square, circle', function () {
                it('should return [minSize, maxSize]', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        var config = {
                            scale: {
                                minSize: 5,
                                maxSize: 25
                            }
                        };
                        assert.deepEqual(parseRangeForChannel('size', 'linear', QUANTITATIVE, {}, config, undefined, m, false, 'plot_width', []), makeImplicit([5, 25]));
                    }
                });
                it('should return [0, (minBandSize-2)^2] if both x and y are discrete and size is quantitative (thus use zero=true, by default)', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        assert.deepEqual(parseRangeForChannel('size', 'linear', QUANTITATIVE, {}, defaultConfig, true, m, false, 'plot_width', [11, 13] // xyRangeSteps
                        ), makeImplicit([0, 81]));
                    }
                });
                it('should return [9, (minBandSize-2)^2] if both x and y are discrete and size is not quantitative (thus use zero=false, by default)', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        assert.deepEqual(parseRangeForChannel('size', 'linear', QUANTITATIVE, {}, defaultConfig, false, m, false, 'plot_width', [11, 13] // xyRangeSteps
                        ), makeImplicit([9, 81]));
                    }
                });
                it('should return [9, (minBandSize-2)^2] if both x and y are discrete and size is quantitative but use zero=false', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        assert.deepEqual(parseRangeForChannel('size', 'linear', QUANTITATIVE, {}, defaultConfig, false, m, false, 'plot_width', [11, 13] // xyRangeSteps
                        ), makeImplicit([9, 81]));
                    }
                });
                it('should return [0, (xRangeStep-2)^2] if x is discrete and y is continuous and size is quantitative (thus use zero=true, by default)', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        assert.deepEqual(parseRangeForChannel('size', 'linear', QUANTITATIVE, {}, defaultConfig, true, m, false, 'plot_width', [11] // xyRangeSteps only have one value
                        ), makeImplicit([0, 81]));
                    }
                });
            });
        });
        describe('shape', function () {
            it('should use default symbol range in Vega as shape\'s scale range.', function () {
                assert.deepEqual(parseRangeForChannel('shape', 'ordinal', QUANTITATIVE, {}, defaultConfig, undefined, 'point', false, 'plot_width', []), makeImplicit('symbol'));
            });
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Rlc3QvY29tcGlsZS9zY2FsZS9yYW5nZS50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLDhCQUE4QjtBQUU5QixPQUFPLEVBQUMsTUFBTSxFQUFDLE1BQU0sTUFBTSxDQUFDO0FBRTVCLE9BQU8sRUFBQyxvQkFBb0IsRUFBQyxNQUFNLGtDQUFrQyxDQUFDO0FBQ3RFLE9BQU8sRUFBQyxZQUFZLEVBQUUsWUFBWSxFQUFDLE1BQU0sNEJBQTRCLENBQUM7QUFDdEUsT0FBTyxFQUFDLGFBQWEsRUFBQyxNQUFNLHFCQUFxQixDQUFDO0FBQ2xELE9BQU8sS0FBSyxHQUFHLE1BQU0sa0JBQWtCLENBQUM7QUFFeEMsT0FBTyxFQUFDLCtCQUErQixFQUFFLHNCQUFzQixFQUFZLE1BQU0sb0JBQW9CLENBQUM7QUFDdEcsT0FBTyxFQUFDLE9BQU8sRUFBRSxPQUFPLEVBQUUsWUFBWSxFQUFDLE1BQU0sbUJBQW1CLENBQUM7QUFFakUsUUFBUSxDQUFDLGVBQWUsRUFBRTtJQUN4QixRQUFRLENBQUMsY0FBYyxFQUFFO1FBQ3ZCLFFBQVEsQ0FBQyxVQUFVLEVBQUU7WUFDbkIsRUFBRSxDQUFDLG1FQUFtRSxFQUFFO2dCQUN0RSxLQUF3QixVQUErQixFQUEvQixtRUFBK0IsRUFBL0IsNkNBQStCLEVBQS9CLElBQStCO29CQUFsRCxJQUFNLFNBQVMsd0NBQUE7b0JBQ2xCLE1BQU0sQ0FBQyxTQUFTLENBQ2Qsb0JBQW9CLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsRUFBRSxFQUFFLGFBQWEsRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsRUFBRSxDQUFDLEVBQzdHLFlBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFDLE1BQU0sRUFBRSxZQUFZLEVBQUMsQ0FBQyxDQUFDLENBQzFDLENBQUM7aUJBQ0g7WUFDSCxD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LENBQUMsU0FBUyxDQUNkLG9CQUFvQixDQUFDLE1BQU0sRUFBRSxRQUFRLEVBQUUsWUFBWSxFQUFFLEVBQUUsRUFBRSxhQUFhLEVBQUUsSUFBSSxFQUFFLENBQUMsRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUNsRyxDQUFDLEVBQUUsQ0FBQyxDQUFDLG1DQUFtQzt5QkFDekMsRUFDRCxZQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FDdEIsQ0FBQztxQkFDSDtnQkFDSCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCxRQUFRLENBQUMsT0FBTyxFQUFFO1lBQ2hCLEVBQUUsQ0FBQyxrRUFBa0UsRUFBRTtnQkFDckUsTUFBTSxDQUFDLFNBQVMsQ0FDZCxvQkFBb0IsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLFlBQVksRUFBRSxFQUFFLEVBQUUsYUFBYSxFQUFFLFNBQVMsRUFBRSxPQUFPLEVBQUUsS0FBSyxFQUFFLFlBQVksRUFBRSxFQUFFLENBQUMsRUFDdEgsWUFBWSxDQUFDLFFBQVEsQ0FBQyxDQUN2QixDQUFDO1lBQ0osQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZTpxdW90ZW1hcmsgKi9cblxuaW1wb3J0IHthc3NlcnR9IGZyb20gJ2NoYWknO1xuXG5pbXBvcnQge3BhcnNlUmFuZ2VGb3JDaGFubmVsfSBmcm9tICcuLi8uLi8uLi9zcmMvY29tcGlsZS9zY2FsZS9yYW5nZSc7XG5pbXBvcnQge21ha2VFeHBsaWNpdCwgbWFrZUltcGxpY2l0fSBmcm9tICcuLi8uLi8uLi9zcmMvY29tcGlsZS9zcGxpdCc7XG5pbXBvcnQge2RlZmF1bHRDb25maWd9IGZyb20gJy4uLy4uLy4uL3NyYy9jb25maWcnO1xuaW1wb3J0ICogYXMgbG9nIGZyb20gJy4uLy4uLy4uL3NyYy9sb2cnO1xuaW1wb3J0IHtNYXJrfSBmcm9tICcuLi8uLi8uLi9zcmMvbWFyayc7XG5pbXBvcnQge0NPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMsIERJU0NSRVRFX0RPTUFJTl9TQ0FMRVMsIFNjYWxlVHlwZX0gZnJvbSAnLi4vLi4vLi4vc3JjL3NjYWxlJztcbmltcG9ydCB7Tk9NSU5BTCwgT1JESU5BTCwgUVVBTlRJVEFUSVZFfSBmcm9tICcuLi8uLi8uLi9zcmMvdHlwZSc7XG5cbmRlc2NyaWJlKCdjb21waWxlL3NjYWxlJywgKCkgPT4ge1xuICBkZXNjcmliZSgncGFyc2VSYW5nZSgpJywgZnVuY3Rpb24oKSB7XG4gICAgZGVzY3JpYmUoJ3Bvc2l0aW9uJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gWzAsIHBsb3Rfd2lkdGhdIGZvciB4LWNvbnRpbnVvdXMgc2NhbGVzIGJ5IGRlZmF1bHQuJywgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHNjYWxlVHlwZSBvZiBDT05USU5VT1VTX1RPX0NPTlRJTlVPVVNfU0NBTEVTKSB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB0cnVlLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoWzAsIHtzaWduYWw6ICdwbG90X3dpZHRoJ31dKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBbcGxvdF9oZWlnaHQsMF0gZm9yIHktY29udGludW91cyBzY2FsZXMgYnkgZGVmYXVsdC4nLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIENPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMpIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3knLCBzY2FsZVR5cGUsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHRydWUsICdwb2ludCcsIGZhbHNlLCAncGxvdF9oZWlnaHQnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoW3tzaWduYWw6ICdwbG90X2hlaWdodCd9LCAwXSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gWzAsIHBsb3RfaGVpZ2h0XSBmb3IgeS1kaXNjcmV0ZSBzY2FsZXMgd2l0aCBoZWlnaHQgYnkgZGVmYXVsdC4nLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIERJU0NSRVRFX0RPTUFJTl9TQ0FMRVMpIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3knLCBzY2FsZVR5cGUsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHRydWUsICdwb2ludCcsIHRydWUsICdwbG90X2hlaWdodCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbMCwge3NpZ25hbDogJ3Bsb3RfaGVpZ2h0J31dKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHN1cHBvcnQgY3VzdG9tIHJhbmdlLicsIGxvZy53cmFwKChsb2NhbExvZ2dlcikgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4JywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge3JhbmdlOiBbMCwgMTAwXX0sIGRlZmF1bHRDb25maWcsIHRydWUsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlRXhwbGljaXQoWzAsIDEwMF0pXG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwobG9jYWxMb2dnZXIud2FybnMubGVuZ3RoLCAwKTtcbiAgICAgIH0pKTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gY29uZmlnLnNjYWxlLnJhbmdlU3RlcCBmb3IgYmFuZC9wb2ludCBzY2FsZXMgYnkgZGVmYXVsdC4nLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIFsncG9pbnQnLCAnYmFuZCddIGFzIFNjYWxlVHlwZVtdKSB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBOT01JTkFMLCB7fSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoe3N0ZXA6IDIxfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gY29uZmlnLnNjYWxlLnRleHRYUmFuZ2VTdGVwIGJ5IGRlZmF1bHQgZm9yIHRleHQgbWFya1xcJ3MgeCBiYW5kL3BvaW50IHNjYWxlcy4nLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIFsncG9pbnQnLCAnYmFuZCddIGFzIFNjYWxlVHlwZVtdKSB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBOT01JTkFMLCB7fSwge3NjYWxlOiB7dGV4dFhSYW5nZVN0ZXA6IDU1fX0sIHVuZGVmaW5lZCwgJ3RleHQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoe3N0ZXA6IDU1fSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gc3BlY2lmaWVkIHJhbmdlU3RlcCBpZiB0b3BMZXZlbFNpemUgaXMgdW5kZWZpbmVkIGZvciBiYW5kL3BvaW50IHNjYWxlcycsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgWydwb2ludCcsICdiYW5kJ10gYXMgU2NhbGVUeXBlW10pIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3gnLCBzY2FsZVR5cGUsIE5PTUlOQUwsIHtyYW5nZVN0ZXA6IDIzfSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAndGV4dCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VFeHBsaWNpdCh7c3RlcDogMjN9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGRyb3AgcmFuZ2VTdGVwIGlmIHRvcExldmVsU2l6ZSBpcyBzcGVjaWZpZWQgZm9yIGJhbmQvcG9pbnQgc2NhbGVzJywgbG9nLndyYXAoKGxvY2FsTG9nZ2VyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIFsncG9pbnQnLCAnYmFuZCddIGFzIFNjYWxlVHlwZVtdKSB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBOT01JTkFMLCB7cmFuZ2VTdGVwOiAyM30sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3RleHQnLCB0cnVlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbMCwge3NpZ25hbDogJ3Bsb3Rfd2lkdGgnfV0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQuZXF1YWwobG9jYWxMb2dnZXIud2FybnNbMF0sIGxvZy5tZXNzYWdlLnJhbmdlU3RlcERyb3BwZWQoJ3gnKSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGRlZmF1bHQgdG9wTGV2ZWxTaXplIGlmIHJhbmdlU3RlcCBpcyBudWxsIGZvciBiYW5kL3BvaW50IHNjYWxlcycsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgWydwb2ludCcsICdiYW5kJ10gYXMgU2NhbGVUeXBlW10pIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3gnLCBzY2FsZVR5cGUsIE5PTUlOQUwsIHtyYW5nZVN0ZXA6IG51bGx9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICd0ZXh0JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFswLCB7c2lnbmFsOiAncGxvdF93aWR0aCd9XSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZGVmYXVsdCB0b3BMZXZlbFNpemUgaWYgcmFuZ2VTdGVwIGNvbmZpZyBpcyBudWxsJywgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHNjYWxlVHlwZSBvZiBbJ3BvaW50JywgJ2JhbmQnXSBhcyBTY2FsZVR5cGVbXSkge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgneCcsIHNjYWxlVHlwZSwgTk9NSU5BTCwge30sIHt2aWV3OiB7d2lkdGg6IDIwMH0sIHNjYWxlOiB7cmFuZ2VTdGVwOiBudWxsfX0sIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFswLCB7c2lnbmFsOiAncGxvdF93aWR0aCd9XSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZGVmYXVsdCB0b3BMZXZlbFNpemUgZm9yIHRleHQgaWYgdGV4dFhSYW5nZVN0ZXAgY29uZmlnIGlzIG51bGwnLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIFsncG9pbnQnLCAnYmFuZCddIGFzIFNjYWxlVHlwZVtdKSB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBOT01JTkFMLCB7fSwge3ZpZXc6IHt3aWR0aDogMjAwfSwgc2NhbGU6IHt0ZXh0WFJhbmdlU3RlcDogbnVsbH19LCB1bmRlZmluZWQsICd0ZXh0JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFswLCB7c2lnbmFsOiAncGxvdF93aWR0aCd9XSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBkcm9wIHJhbmdlU3RlcCBmb3IgY29udGludW91cyBzY2FsZXMnLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIENPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMpIHtcbiAgICAgICAgICBsb2cud3JhcCgobG9jYWxMb2dnZXIpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBRVUFOVElUQVRJVkUsIHtyYW5nZVN0ZXA6IDIzfSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAndGV4dCcsIHRydWUsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgICBtYWtlSW1wbGljaXQoWzAsIHtzaWduYWw6ICdwbG90X3dpZHRoJ31dKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChsb2NhbExvZ2dlci53YXJuc1swXSwgbG9nLm1lc3NhZ2Uuc2NhbGVQcm9wZXJ0eU5vdFdvcmtXaXRoU2NhbGVUeXBlKHNjYWxlVHlwZSwgJ3JhbmdlU3RlcCcsICd4JykpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NvbG9yJywgZnVuY3Rpb24oKSB7XG4gICAgICBpdCgnc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWVkIHNjaGVtZSBmb3IgYSBub21pbmFsIGNvbG9yIGZpZWxkLicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnY29sb3InLCAnb3JkaW5hbCcsIE5PTUlOQUwsIHtzY2hlbWU6ICd3YXJtJ30sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgIG1ha2VFeHBsaWNpdCh7c2NoZW1lOiAnd2FybSd9KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdXNlIHRoZSBzcGVjaWZpZWQgc2NoZW1lIHdpdGggZXh0ZW50IGZvciBhIG5vbWluYWwgY29sb3IgZmllbGQuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdjb2xvcicsICdvcmRpbmFsJywgTk9NSU5BTCwge3NjaGVtZToge25hbWU6ICd3YXJtJywgZXh0ZW50OiBbMC4yLCAxXX19LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlRXhwbGljaXQoe3NjaGVtZTogJ3dhcm0nLCBleHRlbnQ6IFswLjIsIDFdfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWVkIHJhbmdlIGZvciBhIG5vbWluYWwgY29sb3IgZmllbGQuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdjb2xvcicsICdvcmRpbmFsJywgTk9NSU5BTCwge3JhbmdlOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ119LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlRXhwbGljaXQoWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgY2F0ZWdvcnkgcmFuZ2UgaW4gVmVnYSBmb3IgYSBub21pbmFsIGNvbG9yIGZpZWxkLicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnY29sb3InLCAnb3JkaW5hbCcsIE5PTUlOQUwsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlSW1wbGljaXQoJ2NhdGVnb3J5JylcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IG9yZGluYWwgcmFuZ2UgaW4gVmVnYSBmb3IgYW4gb3JkaW5hbCBjb2xvciBmaWVsZC4nLCAoKSA9PiB7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ2NvbG9yJywgJ29yZGluYWwnLCBPUkRJTkFMLCB7fSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgbWFrZUltcGxpY2l0KCdvcmRpbmFsJylcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IHJhbXAgcmFuZ2UgaW4gVmVnYSBmb3IgYSB0ZW1wb3JhbC9xdWFudGl0YXRpdmUgY29sb3IgZmllbGQuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdjb2xvcicsICdzZXF1ZW50aWFsJywgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgbWFrZUltcGxpY2l0KCdyYW1wJylcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWVkIHNjaGVtZSB3aXRoIGNvdW50IGZvciBhIHF1YW50aXRhdGl2ZSBjb2xvciBmaWVsZC4nLCAoKSA9PiB7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ2NvbG9yJywgJ29yZGluYWwnLCBRVUFOVElUQVRJVkUsIHtzY2hlbWU6IHtuYW1lOiAndmlyaWRpcycsIGNvdW50OiAzfX0sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgIG1ha2VFeHBsaWNpdCh7c2NoZW1lOiAndmlyaWRpcycsIGNvdW50OiAzfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ29wYWNpdHknLCBmdW5jdGlvbigpIHtcbiAgICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgb3BhY2l0eVJhbmdlIGFzIG9wYWNpdHlcXCdzIHNjYWxlIHJhbmdlLicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnb3BhY2l0eScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlSW1wbGljaXQoW2RlZmF1bHRDb25maWcuc2NhbGUubWluT3BhY2l0eSwgZGVmYXVsdENvbmZpZy5zY2FsZS5tYXhPcGFjaXR5XSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3NpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGRlc2NyaWJlKCdiYXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gW21pbkJhbmRTaXplLCBtYXhCYW5kU2l6ZV0gaWYgYm90aCBhcmUgc3BlY2lmaWVkJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHNjYWxlOiB7bWluQmFuZFNpemU6IDIsIG1heEJhbmRTaXplOiA5fVxuICAgICAgICAgIH07XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaXplJywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGNvbmZpZywgdW5kZWZpbmVkLCAnYmFyJywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFsyLCA5XSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbY29udGludW91c0JhbmRTaXplLCB4UmFuZ2VTdGVwLTFdIGJ5IGRlZmF1bHQgc2luY2UgbWluL21heFNpemUgY29uZmlnIGFyZSBub3Qgc3BlY2lmaWVkJywgKCkgPT4ge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdiYXInLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoWzIsIGRlZmF1bHRDb25maWcuc2NhbGUucmFuZ2VTdGVwIC0gMV0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3RpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gW21pbkJhbmRTaXplLCBtYXhCYW5kU2l6ZV0gaWYgYm90aCBhcmUgc3BlY2lmaWVkJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHNjYWxlOiB7bWluQmFuZFNpemU6IDQsIG1heEJhbmRTaXplOiA5fVxuICAgICAgICAgIH07XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaXplJywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGNvbmZpZywgdW5kZWZpbmVkLCAndGljaycsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbNCwgOV0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gWyhkZWZhdWx0KW1pbkJhbmRTaXplLCByYW5nZVN0ZXAtMV0gYnkgZGVmYXVsdCBzaW5jZSBtYXhTaXplIGNvbmZpZyBpcyBub3Qgc3BlY2lmaWVkJywgKCkgPT4ge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICd0aWNrJywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFtkZWZhdWx0Q29uZmlnLnNjYWxlLm1pbkJhbmRTaXplLCBkZWZhdWx0Q29uZmlnLnNjYWxlLnJhbmdlU3RlcCAtIDFdKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCd0ZXh0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFttaW5Gb250U2l6ZSwgbWF4Rm9udFNpemVdJywgKCkgPT4ge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICd0ZXh0JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFtkZWZhdWx0Q29uZmlnLnNjYWxlLm1pbkZvbnRTaXplLCBkZWZhdWx0Q29uZmlnLnNjYWxlLm1heEZvbnRTaXplXSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgncnVsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbbWluU3Ryb2tlV2lkdGgsIG1heFN0cm9rZVdpZHRoXScsICgpID0+IHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3NpemUnLCAnbGluZWFyJywgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAncnVsZScsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbZGVmYXVsdENvbmZpZy5zY2FsZS5taW5TdHJva2VXaWR0aCwgZGVmYXVsdENvbmZpZy5zY2FsZS5tYXhTdHJva2VXaWR0aF0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3BvaW50LCBzcXVhcmUsIGNpcmNsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbbWluU2l6ZSwgbWF4U2l6ZV0nLCAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBtIG9mIFsncG9pbnQnLCAnc3F1YXJlJywgJ2NpcmNsZSddIGFzIE1hcmtbXSkge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgICBzY2FsZToge1xuICAgICAgICAgICAgICAgIG1pblNpemU6IDUsXG4gICAgICAgICAgICAgICAgbWF4U2l6ZTogMjVcblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBjb25maWcsIHVuZGVmaW5lZCwgbSwgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgICBtYWtlSW1wbGljaXQoWzUsIDI1XSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbMCwgKG1pbkJhbmRTaXplLTIpXjJdIGlmIGJvdGggeCBhbmQgeSBhcmUgZGlzY3JldGUgYW5kIHNpemUgaXMgcXVhbnRpdGF0aXZlICh0aHVzIHVzZSB6ZXJvPXRydWUsIGJ5IGRlZmF1bHQpJywgKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgbSBvZiBbJ3BvaW50JywgJ3NxdWFyZScsICdjaXJjbGUnXSBhcyBNYXJrW10pIHtcbiAgICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaXplJywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHRydWUsIG0sIGZhbHNlLCAncGxvdF93aWR0aCcsXG4gICAgICAgICAgICAgICAgWzExLCAxM10gLy8geHlSYW5nZVN0ZXBzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbMCwgODFdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFs5LCAobWluQmFuZFNpemUtMileMl0gaWYgYm90aCB4IGFuZCB5IGFyZSBkaXNjcmV0ZSBhbmQgc2l6ZSBpcyBub3QgcXVhbnRpdGF0aXZlICh0aHVzIHVzZSB6ZXJvPWZhbHNlLCBieSBkZWZhdWx0KScsICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG0gb2YgWydwb2ludCcsICdzcXVhcmUnLCAnY2lyY2xlJ10gYXMgTWFya1tdKSB7XG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCBmYWxzZSwgbSwgZmFsc2UsICdwbG90X3dpZHRoJyxcbiAgICAgICAgICAgICAgICBbMTEsIDEzXSAvLyB4eVJhbmdlU3RlcHNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbWFrZUltcGxpY2l0KFs5LCA4MV0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gWzksIChtaW5CYW5kU2l6ZS0yKV4yXSBpZiBib3RoIHggYW5kIHkgYXJlIGRpc2NyZXRlIGFuZCBzaXplIGlzIHF1YW50aXRhdGl2ZSBidXQgdXNlIHplcm89ZmFsc2UnLCAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBtIG9mIFsncG9pbnQnLCAnc3F1YXJlJywgJ2NpcmNsZSddIGFzIE1hcmtbXSkge1xuICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3NpemUnLCAnbGluZWFyJywgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgZmFsc2UsIG0sIGZhbHNlLCAncGxvdF93aWR0aCcsXG4gICAgICAgICAgICAgICAgWzExLCAxM10gLy8geHlSYW5nZVN0ZXBzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbOSwgODFdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFswLCAoeFJhbmdlU3RlcC0yKV4yXSBpZiB4IGlzIGRpc2NyZXRlIGFuZCB5IGlzIGNvbnRpbnVvdXMgYW5kIHNpemUgaXMgcXVhbnRpdGF0aXZlICh0aHVzIHVzZSB6ZXJvPXRydWUsIGJ5IGRlZmF1bHQpJywgKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtIG9mIFsncG9pbnQnLCAnc3F1YXJlJywgJ2NpcmNsZSddIGFzIE1hcmtbXSkge1xuICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3NpemUnLCAnbGluZWFyJywgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgdHJ1ZSwgbSwgZmFsc2UsICdwbG90X3dpZHRoJyxcbiAgICAgICAgICAgICAgICBbMTFdIC8vIHh5UmFuZ2VTdGVwcyBvbmx5IGhhdmUgb25lIHZhbHVlXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbMCwgODFdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnc2hhcGUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgc3ltYm9sIHJhbmdlIGluIFZlZ2EgYXMgc2hhcGVcXCdzIHNjYWxlIHJhbmdlLicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2hhcGUnLCAnb3JkaW5hbCcsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgIG1ha2VJbXBsaWNpdCgnc3ltYm9sJylcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19