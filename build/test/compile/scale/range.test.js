"use strict";
/* tslint:disable:quotemark */
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var range_1 = require("../../../src/compile/scale/range");
var split_1 = require("../../../src/compile/split");
var config_1 = require("../../../src/config");
var log = require("../../../src/log");
var scale_1 = require("../../../src/scale");
var type_1 = require("../../../src/type");
describe('compile/scale', function () {
    describe('parseRange()', function () {
        describe('position', function () {
            it('should return [0, plot_width] for x-continuous scales by default.', function () {
                for (var _i = 0, CONTINUOUS_TO_CONTINUOUS_SCALES_1 = scale_1.CONTINUOUS_TO_CONTINUOUS_SCALES; _i < CONTINUOUS_TO_CONTINUOUS_SCALES_1.length; _i++) {
                    var scaleType = CONTINUOUS_TO_CONTINUOUS_SCALES_1[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.QUANTITATIVE, {}, config_1.defaultConfig, true, 'point', false, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should return [plot_height,0] for y-continuous scales by default.', function () {
                for (var _i = 0, CONTINUOUS_TO_CONTINUOUS_SCALES_2 = scale_1.CONTINUOUS_TO_CONTINUOUS_SCALES; _i < CONTINUOUS_TO_CONTINUOUS_SCALES_2.length; _i++) {
                    var scaleType = CONTINUOUS_TO_CONTINUOUS_SCALES_2[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('y', scaleType, type_1.QUANTITATIVE, {}, config_1.defaultConfig, true, 'point', false, 'plot_height', []), split_1.makeImplicit([{ signal: 'plot_height' }, 0]));
                }
            });
            it('should return [0, plot_height] for y-discrete scales with height by default.', function () {
                for (var _i = 0, DISCRETE_DOMAIN_SCALES_1 = scale_1.DISCRETE_DOMAIN_SCALES; _i < DISCRETE_DOMAIN_SCALES_1.length; _i++) {
                    var scaleType = DISCRETE_DOMAIN_SCALES_1[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('y', scaleType, type_1.QUANTITATIVE, {}, config_1.defaultConfig, true, 'point', true, 'plot_height', []), split_1.makeImplicit([0, { signal: 'plot_height' }]));
                }
            });
            it('should support custom range.', log.wrap(function (localLogger) {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', 'linear', type_1.QUANTITATIVE, { range: [0, 100] }, config_1.defaultConfig, true, 'point', false, 'plot_width', []), split_1.makeExplicit([0, 100]));
                chai_1.assert.deepEqual(localLogger.warns.length, 0);
            }));
            it('should return config.scale.rangeStep for band/point scales by default.', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit({ step: 21 }));
                }
            });
            it('should return config.scale.textXRangeStep by default for text mark\'s x band/point scales.', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, {}, { scale: { textXRangeStep: 55 } }, undefined, 'text', false, 'plot_width', []), split_1.makeImplicit({ step: 55 }));
                }
            });
            it('should return specified rangeStep if topLevelSize is undefined for band/point scales', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, { rangeStep: 23 }, config_1.defaultConfig, undefined, 'text', false, 'plot_width', []), split_1.makeExplicit({ step: 23 }));
                }
            });
            it('should drop rangeStep if topLevelSize is specified for band/point scales', log.wrap(function (localLogger) {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, { rangeStep: 23 }, config_1.defaultConfig, undefined, 'text', true, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                }
                chai_1.assert.equal(localLogger.warns[0], log.message.rangeStepDropped('x'));
            }));
            it('should return default topLevelSize if rangeStep is null for band/point scales', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, { rangeStep: null }, config_1.defaultConfig, undefined, 'text', false, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should return default topLevelSize if rangeStep config is null', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, {}, { view: { width: 200 }, scale: { rangeStep: null } }, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should return default topLevelSize for text if textXRangeStep config is null', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, {}, { view: { width: 200 }, scale: { textXRangeStep: null } }, undefined, 'text', false, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should drop rangeStep for continuous scales', function () {
                var _loop_1 = function (scaleType) {
                    log.wrap(function (localLogger) {
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.QUANTITATIVE, { rangeStep: 23 }, config_1.defaultConfig, undefined, 'text', true, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                        chai_1.assert.equal(localLogger.warns[0], log.message.scalePropertyNotWorkWithScaleType(scaleType, 'rangeStep', 'x'));
                    })();
                };
                for (var _i = 0, CONTINUOUS_TO_CONTINUOUS_SCALES_3 = scale_1.CONTINUOUS_TO_CONTINUOUS_SCALES; _i < CONTINUOUS_TO_CONTINUOUS_SCALES_3.length; _i++) {
                    var scaleType = CONTINUOUS_TO_CONTINUOUS_SCALES_3[_i];
                    _loop_1(scaleType);
                }
            });
        });
        describe('color', function () {
            it('should use the specified scheme for a nominal color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.NOMINAL, { scheme: 'warm' }, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeExplicit({ scheme: 'warm' }));
            });
            it('should use the specified scheme with extent for a nominal color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.NOMINAL, { scheme: { name: 'warm', extent: [0.2, 1] } }, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeExplicit({ scheme: 'warm', extent: [0.2, 1] }));
            });
            it('should use the specified range for a nominal color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.NOMINAL, { range: ['red', 'green', 'blue'] }, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeExplicit(['red', 'green', 'blue']));
            });
            it('should use default category range in Vega for a nominal color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.NOMINAL, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit('category'));
            });
            it('should use default ordinal range in Vega for an ordinal color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.ORDINAL, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit('ordinal'));
            });
            it('should use default ramp range in Vega for a temporal/quantitative color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'sequential', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit('ramp'));
            });
            it('should use the specified scheme with count for a quantitative color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.QUANTITATIVE, { scheme: { name: 'viridis', count: 3 } }, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeExplicit({ scheme: 'viridis', count: 3 }));
            });
        });
        describe('opacity', function () {
            it('should use default opacityRange as opacity\'s scale range.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('opacity', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit([config_1.defaultConfig.scale.minOpacity, config_1.defaultConfig.scale.maxOpacity]));
            });
        });
        describe('size', function () {
            describe('bar', function () {
                it('should return [minBandSize, maxBandSize] if both are specified', function () {
                    var config = {
                        scale: { minBandSize: 2, maxBandSize: 9 }
                    };
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config, undefined, 'bar', false, 'plot_width', []), split_1.makeImplicit([2, 9]));
                });
                it('should return [continuousBandSize, xRangeStep-1] by default since min/maxSize config are not specified', function () {
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'bar', false, 'plot_width', []), split_1.makeImplicit([2, config_1.defaultConfig.scale.rangeStep - 1]));
                });
            });
            describe('tick', function () {
                it('should return [minBandSize, maxBandSize] if both are specified', function () {
                    var config = {
                        scale: { minBandSize: 4, maxBandSize: 9 }
                    };
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config, undefined, 'tick', false, 'plot_width', []), split_1.makeImplicit([4, 9]));
                });
                it('should return [(default)minBandSize, rangeStep-1] by default since maxSize config is not specified', function () {
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'tick', false, 'plot_width', []), split_1.makeImplicit([config_1.defaultConfig.scale.minBandSize, config_1.defaultConfig.scale.rangeStep - 1]));
                });
            });
            describe('text', function () {
                it('should return [minFontSize, maxFontSize]', function () {
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'text', false, 'plot_width', []), split_1.makeImplicit([config_1.defaultConfig.scale.minFontSize, config_1.defaultConfig.scale.maxFontSize]));
                });
            });
            describe('rule', function () {
                it('should return [minStrokeWidth, maxStrokeWidth]', function () {
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'rule', false, 'plot_width', []), split_1.makeImplicit([config_1.defaultConfig.scale.minStrokeWidth, config_1.defaultConfig.scale.maxStrokeWidth]));
                });
            });
            describe('point, square, circle', function () {
                it('should return [minSize, maxSize]', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        var config = {
                            scale: {
                                minSize: 5,
                                maxSize: 25
                            }
                        };
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config, undefined, m, false, 'plot_width', []), split_1.makeImplicit([5, 25]));
                    }
                });
                it('should return [0, (minBandSize-2)^2] if both x and y are discrete and size is quantitative (thus use zero=true, by default)', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, true, m, false, 'plot_width', [11, 13] // xyRangeSteps
                        ), split_1.makeImplicit([0, 81]));
                    }
                });
                it('should return [9, (minBandSize-2)^2] if both x and y are discrete and size is not quantitative (thus use zero=false, by default)', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, false, m, false, 'plot_width', [11, 13] // xyRangeSteps
                        ), split_1.makeImplicit([9, 81]));
                    }
                });
                it('should return [9, (minBandSize-2)^2] if both x and y are discrete and size is quantitative but use zero=false', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, false, m, false, 'plot_width', [11, 13] // xyRangeSteps
                        ), split_1.makeImplicit([9, 81]));
                    }
                });
                it('should return [0, (xRangeStep-2)^2] if x is discrete and y is continuous and size is quantitative (thus use zero=true, by default)', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, true, m, false, 'plot_width', [11] // xyRangeSteps only have one value
                        ), split_1.makeImplicit([0, 81]));
                    }
                });
            });
        });
        describe('shape', function () {
            it('should use default symbol range in Vega as shape\'s scale range.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('shape', 'ordinal', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit('symbol'));
            });
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Rlc3QvY29tcGlsZS9zY2FsZS9yYW5nZS50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSw4QkFBOEI7O0FBRTlCLDZCQUE0QjtBQUU1QiwwREFBc0U7QUFDdEUsb0RBQXNFO0FBQ3RFLDhDQUFrRDtBQUNsRCxzQ0FBd0M7QUFFeEMsNENBQXNHO0FBQ3RHLDBDQUFpRTtBQUVqRSxRQUFRLENBQUMsZUFBZSxFQUFFO0lBQ3hCLFFBQVEsQ0FBQyxjQUFjLEVBQUU7UUFDdkIsUUFBUSxDQUFDLFVBQVUsRUFBRTtZQUNuQixFQUFFLENBQUMsbUVBQW1FLEVBQUU7Z0JBQ3RFLEtBQXdCLFVBQStCLEVBQS9CLG9DQUFBLHVDQUErQixFQUEvQiw2Q0FBK0IsRUFBL0IsSUFBK0I7b0JBQWxELElBQU0sU0FBUyx3Q0FBQTtvQkFDbEIsYUFBTSxDQUFDLFNBQVMsQ0FDZCw0QkFBb0IsQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLG1CQUFZLEVBQUUsRUFBRSxFQUFFLHNCQUFhLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLEVBQUUsQ0FBQyxFQUM3RyxvQkFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUMsTUFBTSxFQUFFLFlBQVksRUFBQyxDQUFDLENBQUMsQ0FDMUMsQ0FBQztpQkFDSDtZQUNILENBQUMsQ0FBQyxDQUFDO1lBRUgsRUFBRSxDQUFDLG1FQUFtRSxFQUFFO2dCQUN0RSxLQUF3QixVQUErQixFQUEvQixvQ0FBQSx1Q0FBK0IsRUFBL0IsNkNBQStCLEVBQS9CLElBQStCO29CQUFsRCxJQUFNLFNBQVMsd0NBQUE7b0JBQ2xCLGFBQU0sQ0FBQyxTQUFTLENBQ2QsNEJBQW9CLENBQUMsR0FBRyxFQUFFLFNBQVMsRUFBRSxtQkFBWSxFQUFFLEVBQUUsRUFBRSxzQkFBYSxFQUFFLElBQUksRUFBRSxPQUFPLEVBQUUs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Q0FBbUM7eUJBQ3pDLEVBQ0Qsb0JBQVksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUN0QixDQUFDO3FCQUNIO2dCQUNILENBQUMsQ0FBQyxDQUFDO1lBQ0wsQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztRQUVILFFBQVEsQ0FBQyxPQUFPLEVBQUU7WUFDaEIsRUFBRSxDQUFDLGtFQUFrRSxFQUFFO2dCQUNyRSxhQUFNLENBQUMsU0FBUyxDQUNkLDRCQUFvQixDQUFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsbUJBQVksRUFBRSxFQUFFLEVBQUUsc0JBQWEsRUFBRSxTQUFTLEVBQUUsT0FBTyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQUUsRUFBRSxDQUFDLEVBQ3RILG9CQUFZLENBQUMsUUFBUSxDQUFDLENBQ3ZCLENBQUM7WUFDSixDQUFDLENBQUMsQ0FBQztRQUNMLENBQUMsQ0FBQyxDQUFDO0lBQ0wsQ0FBQyxDQUFDLENBQUM7QUFDTCxDQUFDLENBQUMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qIHRzbGludDpkaXNhYmxlOnF1b3RlbWFyayAqL1xuXG5pbXBvcnQge2Fzc2VydH0gZnJvbSAnY2hhaSc7XG5cbmltcG9ydCB7cGFyc2VSYW5nZUZvckNoYW5uZWx9IGZyb20gJy4uLy4uLy4uL3NyYy9jb21waWxlL3NjYWxlL3JhbmdlJztcbmltcG9ydCB7bWFrZUV4cGxpY2l0LCBtYWtlSW1wbGljaXR9IGZyb20gJy4uLy4uLy4uL3NyYy9jb21waWxlL3NwbGl0JztcbmltcG9ydCB7ZGVmYXVsdENvbmZpZ30gZnJvbSAnLi4vLi4vLi4vc3JjL2NvbmZpZyc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnLi4vLi4vLi4vc3JjL2xvZyc7XG5pbXBvcnQge01hcmt9IGZyb20gJy4uLy4uLy4uL3NyYy9tYXJrJztcbmltcG9ydCB7Q09OVElOVU9VU19UT19DT05USU5VT1VTX1NDQUxFUywgRElTQ1JFVEVfRE9NQUlOX1NDQUxFUywgU2NhbGVUeXBlfSBmcm9tICcuLi8uLi8uLi9zcmMvc2NhbGUnO1xuaW1wb3J0IHtOT01JTkFMLCBPUkRJTkFMLCBRVUFOVElUQVRJVkV9IGZyb20gJy4uLy4uLy4uL3NyYy90eXBlJztcblxuZGVzY3JpYmUoJ2NvbXBpbGUvc2NhbGUnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCdwYXJzZVJhbmdlKCknLCBmdW5jdGlvbigpIHtcbiAgICBkZXNjcmliZSgncG9zaXRpb24nLCAoKSA9PiB7XG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBbMCwgcGxvdF93aWR0aF0gZm9yIHgtY29udGludW91cyBzY2FsZXMgYnkgZGVmYXVsdC4nLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIENPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMpIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3gnLCBzY2FsZVR5cGUsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHRydWUsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbMCwge3NpZ25hbDogJ3Bsb3Rfd2lkdGgnfV0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFtwbG90X2hlaWdodCwwXSBmb3IgeS1jb250aW51b3VzIHNjYWxlcyBieSBkZWZhdWx0LicsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgQ09OVElOVU9VU19UT19DT05USU5VT1VTX1NDQUxFUykge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgneScsIHNjYWxlVHlwZSwgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgdHJ1ZSwgJ3BvaW50JywgZmFsc2UsICdwbG90X2hlaWdodCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbe3NpZ25hbDogJ3Bsb3RfaGVpZ2h0J30sIDBdKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBbMCwgcGxvdF9oZWlnaHRdIGZvciB5LWRpc2NyZXRlIHNjYWxlcyB3aXRoIGhlaWdodCBieSBkZWZhdWx0LicsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgRElTQ1JFVEVfRE9NQUlOX1NDQUxFUykge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgneScsIHNjYWxlVHlwZSwgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgdHJ1ZSwgJ3BvaW50JywgdHJ1ZSwgJ3Bsb3RfaGVpZ2h0JywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFswLCB7c2lnbmFsOiAncGxvdF9oZWlnaHQnfV0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgc3VwcG9ydCBjdXN0b20gcmFuZ2UuJywgbG9nLndyYXAoKGxvY2FsTG9nZ2VyKSA9PiB7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3gnLCAnbGluZWFyJywgUVVBTlRJVEFUSVZFLCB7cmFuZ2U6IFswLCAxMDBdfSwgZGVmYXVsdENvbmZpZywgdHJ1ZSwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgIG1ha2VFeHBsaWNpdChbMCwgMTAwXSlcbiAgICAgICAgKTtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChsb2NhbExvZ2dlci53YXJucy5sZW5ndGgsIDApO1xuICAgICAgfSkpO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBjb25maWcuc2NhbGUucmFuZ2VTdGVwIGZvciBiYW5kL3BvaW50IHNjYWxlcyBieSBkZWZhdWx0LicsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgWydwb2ludCcsICdiYW5kJ10gYXMgU2NhbGVUeXBlW10pIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3gnLCBzY2FsZVR5cGUsIE5PTUlOQUwsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdCh7c3RlcDogMjF9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBjb25maWcuc2NhbGUudGV4dFhSYW5nZVN0ZXAgYnkgZGVmYXVsdCBmb3IgdGV4dCBtYXJrXFwncyB4IGJhbmQvcG9pbnQgc2NhbGVzLicsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgWydwb2ludCcsICdiYW5kJ10gYXMgU2NhbGVUeXBlW10pIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3gnLCBzY2FsZVR5cGUsIE5PTUlOQUwsIHt9LCB7c2NhbGU6IHt0ZXh0WFJhbmdlU3RlcDogNTV9fSwgdW5kZWZpbmVkLCAndGV4dCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdCh7c3RlcDogNTV9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBzcGVjaWZpZWQgcmFuZ2VTdGVwIGlmIHRvcExldmVsU2l6ZSBpcyB1bmRlZmluZWQgZm9yIGJhbmQvcG9pbnQgc2NhbGVzJywgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHNjYWxlVHlwZSBvZiBbJ3BvaW50JywgJ2JhbmQnXSBhcyBTY2FsZVR5cGVbXSkge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgneCcsIHNjYWxlVHlwZSwgTk9NSU5BTCwge3JhbmdlU3RlcDogMjN9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICd0ZXh0JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUV4cGxpY2l0KHtzdGVwOiAyM30pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgZHJvcCByYW5nZVN0ZXAgaWYgdG9wTGV2ZWxTaXplIGlzIHNwZWNpZmllZCBmb3IgYmFuZC9wb2ludCBzY2FsZXMnLCBsb2cud3JhcCgobG9jYWxMb2dnZXIpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgWydwb2ludCcsICdiYW5kJ10gYXMgU2NhbGVUeXBlW10pIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3gnLCBzY2FsZVR5cGUsIE5PTUlOQUwsIHtyYW5nZVN0ZXA6IDIzfSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAndGV4dCcsIHRydWUsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFswLCB7c2lnbmFsOiAncGxvdF93aWR0aCd9XSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIGFzc2VydC5lcXVhbChsb2NhbExvZ2dlci53YXJuc1swXSwgbG9nLm1lc3NhZ2UucmFuZ2VTdGVwRHJvcHBlZCgneCcpKTtcbiAgICAgIH0pKTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZGVmYXVsdCB0b3BMZXZlbFNpemUgaWYgcmFuZ2VTdGVwIGlzIG51bGwgZm9yIGJhbmQvcG9pbnQgc2NhbGVzJywgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHNjYWxlVHlwZSBvZiBbJ3BvaW50JywgJ2JhbmQnXSBhcyBTY2FsZVR5cGVbXSkge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgneCcsIHNjYWxlVHlwZSwgTk9NSU5BTCwge3JhbmdlU3RlcDogbnVsbH0sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3RleHQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoWzAsIHtzaWduYWw6ICdwbG90X3dpZHRoJ31dKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBkZWZhdWx0IHRvcExldmVsU2l6ZSBpZiByYW5nZVN0ZXAgY29uZmlnIGlzIG51bGwnLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIFsncG9pbnQnLCAnYmFuZCddIGFzIFNjYWxlVHlwZVtdKSB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBOT01JTkFMLCB7fSwge3ZpZXc6IHt3aWR0aDogMjAwfSwgc2NhbGU6IHtyYW5nZVN0ZXA6IG51bGx9fSwgdW5kZWZpbmVkLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoWzAsIHtzaWduYWw6ICdwbG90X3dpZHRoJ31dKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBkZWZhdWx0IHRvcExldmVsU2l6ZSBmb3IgdGV4dCBpZiB0ZXh0WFJhbmdlU3RlcCBjb25maWcgaXMgbnVsbCcsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgWydwb2ludCcsICdiYW5kJ10gYXMgU2NhbGVUeXBlW10pIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3gnLCBzY2FsZVR5cGUsIE5PTUlOQUwsIHt9LCB7dmlldzoge3dpZHRoOiAyMDB9LCBzY2FsZToge3RleHRYUmFuZ2VTdGVwOiBudWxsfX0sIHVuZGVmaW5lZCwgJ3RleHQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoWzAsIHtzaWduYWw6ICdwbG90X3dpZHRoJ31dKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGRyb3AgcmFuZ2VTdGVwIGZvciBjb250aW51b3VzIHNjYWxlcycsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgQ09OVElOVU9VU19UT19DT05USU5VT1VTX1NDQUxFUykge1xuICAgICAgICAgIGxvZy53cmFwKChsb2NhbExvZ2dlcikgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3gnLCBzY2FsZVR5cGUsIFFVQU5USVRBVElWRSwge3JhbmdlU3RlcDogMjN9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICd0ZXh0JywgdHJ1ZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbMCwge3NpZ25hbDogJ3Bsb3Rfd2lkdGgnfV0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKGxvY2FsTG9nZ2VyLndhcm5zWzBdLCBsb2cubWVzc2FnZS5zY2FsZVByb3BlcnR5Tm90V29ya1dpdGhTY2FsZVR5cGUoc2NhbGVUeXBlLCAncmFuZ2VTdGVwJywgJ3gnKSk7XG4gICAgICAgICAgfSkoKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnY29sb3InLCBmdW5jdGlvbigpIHtcbiAgICAgIGl0KCdzaG91bGQgdXNlIHRoZSBzcGVjaWZpZWQgc2NoZW1lIGZvciBhIG5vbWluYWwgY29sb3IgZmllbGQuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdjb2xvcicsICdvcmRpbmFsJywgTk9NSU5BTCwge3NjaGVtZTogJ3dhcm0nfSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgbWFrZUV4cGxpY2l0KHtzY2hlbWU6ICd3YXJtJ30pXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCB1c2UgdGhlIHNwZWNpZmllZCBzY2hlbWUgd2l0aCBleHRlbnQgZm9yIGEgbm9taW5hbCBjb2xvciBmaWVsZC4nLCAoKSA9PiB7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ2NvbG9yJywgJ29yZGluYWwnLCBOT01JTkFMLCB7c2NoZW1lOiB7bmFtZTogJ3dhcm0nLCBleHRlbnQ6IFswLjIsIDFdfX0sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgIG1ha2VFeHBsaWNpdCh7c2NoZW1lOiAnd2FybScsIGV4dGVudDogWzAuMiwgMV19KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdXNlIHRoZSBzcGVjaWZpZWQgcmFuZ2UgZm9yIGEgbm9taW5hbCBjb2xvciBmaWVsZC4nLCAoKSA9PiB7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ2NvbG9yJywgJ29yZGluYWwnLCBOT01JTkFMLCB7cmFuZ2U6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXX0sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgIG1ha2VFeHBsaWNpdChbJ3JlZCcsICdncmVlbicsICdibHVlJ10pXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCB1c2UgZGVmYXVsdCBjYXRlZ29yeSByYW5nZSBpbiBWZWdhIGZvciBhIG5vbWluYWwgY29sb3IgZmllbGQuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdjb2xvcicsICdvcmRpbmFsJywgTk9NSU5BTCwge30sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgIG1ha2VJbXBsaWNpdCgnY2F0ZWdvcnknKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgb3JkaW5hbCByYW5nZSBpbiBWZWdhIGZvciBhbiBvcmRpbmFsIGNvbG9yIGZpZWxkLicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnY29sb3InLCAnb3JkaW5hbCcsIE9SRElOQUwsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlSW1wbGljaXQoJ29yZGluYWwnKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgcmFtcCByYW5nZSBpbiBWZWdhIGZvciBhIHRlbXBvcmFsL3F1YW50aXRhdGl2ZSBjb2xvciBmaWVsZC4nLCAoKSA9PiB7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ2NvbG9yJywgJ3NlcXVlbnRpYWwnLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlSW1wbGljaXQoJ3JhbXAnKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdXNlIHRoZSBzcGVjaWZpZWQgc2NoZW1lIHdpdGggY291bnQgZm9yIGEgcXVhbnRpdGF0aXZlIGNvbG9yIGZpZWxkLicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnY29sb3InLCAnb3JkaW5hbCcsIFFVQU5USVRBVElWRSwge3NjaGVtZToge25hbWU6ICd2aXJpZGlzJywgY291bnQ6IDN9fSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgbWFrZUV4cGxpY2l0KHtzY2hlbWU6ICd2aXJpZGlzJywgY291bnQ6IDN9KVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnb3BhY2l0eScsIGZ1bmN0aW9uKCkge1xuICAgICAgaXQoJ3Nob3VsZCB1c2UgZGVmYXVsdCBvcGFjaXR5UmFuZ2UgYXMgb3BhY2l0eVxcJ3Mgc2NhbGUgcmFuZ2UuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdvcGFjaXR5JywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgIG1ha2VJbXBsaWNpdChbZGVmYXVsdENvbmZpZy5zY2FsZS5taW5PcGFjaXR5LCBkZWZhdWx0Q29uZmlnLnNjYWxlLm1heE9wYWNpdHldKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnc2l6ZScsIGZ1bmN0aW9uKCkge1xuICAgICAgZGVzY3JpYmUoJ2JhcicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbbWluQmFuZFNpemUsIG1heEJhbmRTaXplXSBpZiBib3RoIGFyZSBzcGVjaWZpZWQnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgc2NhbGU6IHttaW5CYW5kU2l6ZTogMiwgbWF4QmFuZFNpemU6IDl9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3NpemUnLCAnbGluZWFyJywgUVVBTlRJVEFUSVZFLCB7fSwgY29uZmlnLCB1bmRlZmluZWQsICdiYXInLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoWzIsIDldKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFtjb250aW51b3VzQmFuZFNpemUsIHhSYW5nZVN0ZXAtMV0gYnkgZGVmYXVsdCBzaW5jZSBtaW4vbWF4U2l6ZSBjb25maWcgYXJlIG5vdCBzcGVjaWZpZWQnLCAoKSA9PiB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaXplJywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ2JhcicsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbMiwgZGVmYXVsdENvbmZpZy5zY2FsZS5yYW5nZVN0ZXAgLSAxXSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgndGljaycsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbbWluQmFuZFNpemUsIG1heEJhbmRTaXplXSBpZiBib3RoIGFyZSBzcGVjaWZpZWQnLCAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgc2NhbGU6IHttaW5CYW5kU2l6ZTogNCwgbWF4QmFuZFNpemU6IDl9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3NpemUnLCAnbGluZWFyJywgUVVBTlRJVEFUSVZFLCB7fSwgY29uZmlnLCB1bmRlZmluZWQsICd0aWNrJywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFs0LCA5XSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbKGRlZmF1bHQpbWluQmFuZFNpemUsIHJhbmdlU3RlcC0xXSBieSBkZWZhdWx0IHNpbmNlIG1heFNpemUgY29uZmlnIGlzIG5vdCBzcGVjaWZpZWQnLCAoKSA9PiB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaXplJywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3RpY2snLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoW2RlZmF1bHRDb25maWcuc2NhbGUubWluQmFuZFNpemUsIGRlZmF1bHRDb25maWcuc2NhbGUucmFuZ2VTdGVwIC0gMV0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3RleHQnLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gW21pbkZvbnRTaXplLCBtYXhGb250U2l6ZV0nLCAoKSA9PiB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaXplJywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3RleHQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoW2RlZmF1bHRDb25maWcuc2NhbGUubWluRm9udFNpemUsIGRlZmF1bHRDb25maWcuc2NhbGUubWF4Rm9udFNpemVdKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCdydWxlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFttaW5TdHJva2VXaWR0aCwgbWF4U3Ryb2tlV2lkdGhdJywgKCkgPT4ge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdydWxlJywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFtkZWZhdWx0Q29uZmlnLnNjYWxlLm1pblN0cm9rZVdpZHRoLCBkZWZhdWx0Q29uZmlnLnNjYWxlLm1heFN0cm9rZVdpZHRoXSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgncG9pbnQsIHNxdWFyZSwgY2lyY2xlJywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFttaW5TaXplLCBtYXhTaXplXScsICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG0gb2YgWydwb2ludCcsICdzcXVhcmUnLCAnY2lyY2xlJ10gYXMgTWFya1tdKSB7XG4gICAgICAgICAgICBjb25zdCBjb25maWcgPSB7XG4gICAgICAgICAgICAgIHNjYWxlOiB7XG4gICAgICAgICAgICAgICAgbWluU2l6ZTogNSxcbiAgICAgICAgICAgICAgICBtYXhTaXplOiAyNVxuXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG5cbiAgICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaXplJywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGNvbmZpZywgdW5kZWZpbmVkLCBtLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbNSwgMjVdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFswLCAobWluQmFuZFNpemUtMileMl0gaWYgYm90aCB4IGFuZCB5IGFyZSBkaXNjcmV0ZSBhbmQgc2l6ZSBpcyBxdWFudGl0YXRpdmUgKHRodXMgdXNlIHplcm89dHJ1ZSwgYnkgZGVmYXVsdCknLCAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBtIG9mIFsncG9pbnQnLCAnc3F1YXJlJywgJ2NpcmNsZSddIGFzIE1hcmtbXSkge1xuICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3NpemUnLCAnbGluZWFyJywgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgdHJ1ZSwgbSwgZmFsc2UsICdwbG90X3dpZHRoJyxcbiAgICAgICAgICAgICAgICBbMTEsIDEzXSAvLyB4eVJhbmdlU3RlcHNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbWFrZUltcGxpY2l0KFswLCA4MV0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gWzksIChtaW5CYW5kU2l6ZS0yKV4yXSBpZiBib3RoIHggYW5kIHkgYXJlIGRpc2NyZXRlIGFuZCBzaXplIGlzIG5vdCBxdWFudGl0YXRpdmUgKHRodXMgdXNlIHplcm89ZmFsc2UsIGJ5IGRlZmF1bHQpJywgKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgbSBvZiBbJ3BvaW50JywgJ3NxdWFyZScsICdjaXJjbGUnXSBhcyBNYXJrW10pIHtcbiAgICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaXplJywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIGZhbHNlLCBtLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLFxuICAgICAgICAgICAgICAgIFsxMSwgMTNdIC8vIHh5UmFuZ2VTdGVwc1xuICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICBtYWtlSW1wbGljaXQoWzksIDgxXSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbOSwgKG1pbkJhbmRTaXplLTIpXjJdIGlmIGJvdGggeCBhbmQgeSBhcmUgZGlzY3JldGUgYW5kIHNpemUgaXMgcXVhbnRpdGF0aXZlIGJ1dCB1c2UgemVybz1mYWxzZScsICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG0gb2YgWydwb2ludCcsICdzcXVhcmUnLCAnY2lyY2xlJ10gYXMgTWFya1tdKSB7XG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCBmYWxzZSwgbSwgZmFsc2UsICdwbG90X3dpZHRoJyxcbiAgICAgICAgICAgICAgICBbMTEsIDEzXSAvLyB4eVJhbmdlU3RlcHNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbWFrZUltcGxpY2l0KFs5LCA4MV0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gWzAsICh4UmFuZ2VTdGVwLTIpXjJdIGlmIHggaXMgZGlzY3JldGUgYW5kIHkgaXMgY29udGludW91cyBhbmQgc2l6ZSBpcyBxdWFudGl0YXRpdmUgKHRodXMgdXNlIHplcm89dHJ1ZSwgYnkgZGVmYXVsdCknLCAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG0gb2YgWydwb2ludCcsICdzcXVhcmUnLCAnY2lyY2xlJ10gYXMgTWFya1tdKSB7XG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB0cnVlLCBtLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLFxuICAgICAgICAgICAgICAgIFsxMV0gLy8geHlSYW5nZVN0ZXBzIG9ubHkgaGF2ZSBvbmUgdmFsdWVcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbWFrZUltcGxpY2l0KFswLCA4MV0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCdzaGFwZScsIGZ1bmN0aW9uKCkge1xuICAgICAgaXQoJ3Nob3VsZCB1c2UgZGVmYXVsdCBzeW1ib2wgcmFuZ2UgaW4gVmVnYSBhcyBzaGFwZVxcJ3Mgc2NhbGUgcmFuZ2UuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaGFwZScsICdvcmRpbmFsJywgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgbWFrZUltcGxpY2l0KCdzeW1ib2wnKVxuICAgICAgICApO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xufSk7XG4iXX0=