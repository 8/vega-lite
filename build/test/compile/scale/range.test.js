"use strict";
/* tslint:disable:quotemark */
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var chai_1 = require("chai");
var range_1 = require("../../../src/compile/scale/range");
var split_1 = require("../../../src/compile/split");
var config_1 = require("../../../src/config");
var log = tslib_1.__importStar(require("../../../src/log"));
var scale_1 = require("../../../src/scale");
var type_1 = require("../../../src/type");
describe('compile/scale', function () {
    describe('parseRange()', function () {
        describe('position', function () {
            it('should return [0, plot_width] for x-continuous scales by default.', function () {
                for (var _i = 0, CONTINUOUS_TO_CONTINUOUS_SCALES_1 = scale_1.CONTINUOUS_TO_CONTINUOUS_SCALES; _i < CONTINUOUS_TO_CONTINUOUS_SCALES_1.length; _i++) {
                    var scaleType = CONTINUOUS_TO_CONTINUOUS_SCALES_1[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.QUANTITATIVE, {}, config_1.defaultConfig, true, 'point', false, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should return [plot_height,0] for y-continuous scales by default.', function () {
                for (var _i = 0, CONTINUOUS_TO_CONTINUOUS_SCALES_2 = scale_1.CONTINUOUS_TO_CONTINUOUS_SCALES; _i < CONTINUOUS_TO_CONTINUOUS_SCALES_2.length; _i++) {
                    var scaleType = CONTINUOUS_TO_CONTINUOUS_SCALES_2[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('y', scaleType, type_1.QUANTITATIVE, {}, config_1.defaultConfig, true, 'point', false, 'plot_height', []), split_1.makeImplicit([{ signal: 'plot_height' }, 0]));
                }
            });
            it('should return [0, plot_height] for y-discrete scales with height by default.', function () {
                for (var _i = 0, DISCRETE_DOMAIN_SCALES_1 = scale_1.DISCRETE_DOMAIN_SCALES; _i < DISCRETE_DOMAIN_SCALES_1.length; _i++) {
                    var scaleType = DISCRETE_DOMAIN_SCALES_1[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('y', scaleType, type_1.QUANTITATIVE, {}, config_1.defaultConfig, true, 'point', true, 'plot_height', []), split_1.makeImplicit([0, { signal: 'plot_height' }]));
                }
            });
            it('should support custom range.', log.wrap(function (localLogger) {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', 'linear', type_1.QUANTITATIVE, { range: [0, 100] }, config_1.defaultConfig, true, 'point', false, 'plot_width', []), split_1.makeExplicit([0, 100]));
                chai_1.assert.deepEqual(localLogger.warns.length, 0);
            }));
            it('should return config.scale.rangeStep for band/point scales by default.', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit({ step: 21 }));
                }
            });
            it('should return config.scale.textXRangeStep by default for text mark\'s x band/point scales.', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, {}, { scale: { textXRangeStep: 55 } }, undefined, 'text', false, 'plot_width', []), split_1.makeImplicit({ step: 55 }));
                }
            });
            it('should return specified rangeStep if topLevelSize is undefined for band/point scales', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, { rangeStep: 23 }, config_1.defaultConfig, undefined, 'text', false, 'plot_width', []), split_1.makeExplicit({ step: 23 }));
                }
            });
            it('should drop rangeStep if topLevelSize is specified for band/point scales', log.wrap(function (localLogger) {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, { rangeStep: 23 }, config_1.defaultConfig, undefined, 'text', true, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                }
                chai_1.assert.equal(localLogger.warns[0], log.message.rangeStepDropped('x'));
            }));
            it('should return default topLevelSize if rangeStep is null for band/point scales', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, { rangeStep: null }, config_1.defaultConfig, undefined, 'text', false, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should return default topLevelSize if rangeStep config is null', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, {}, { view: { width: 200 }, scale: { rangeStep: null } }, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should return default topLevelSize for text if textXRangeStep config is null', function () {
                for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                    var scaleType = _a[_i];
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.NOMINAL, {}, { view: { width: 200 }, scale: { textXRangeStep: null } }, undefined, 'text', false, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                }
            });
            it('should drop rangeStep for continuous scales', function () {
                var _loop_1 = function (scaleType) {
                    log.wrap(function (localLogger) {
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('x', scaleType, type_1.QUANTITATIVE, { rangeStep: 23 }, config_1.defaultConfig, undefined, 'text', true, 'plot_width', []), split_1.makeImplicit([0, { signal: 'plot_width' }]));
                        chai_1.assert.equal(localLogger.warns[0], log.message.scalePropertyNotWorkWithScaleType(scaleType, 'rangeStep', 'x'));
                    })();
                };
                for (var _i = 0, CONTINUOUS_TO_CONTINUOUS_SCALES_3 = scale_1.CONTINUOUS_TO_CONTINUOUS_SCALES; _i < CONTINUOUS_TO_CONTINUOUS_SCALES_3.length; _i++) {
                    var scaleType = CONTINUOUS_TO_CONTINUOUS_SCALES_3[_i];
                    _loop_1(scaleType);
                }
            });
        });
        describe('color', function () {
            it('should use the specified scheme for a nominal color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.NOMINAL, { scheme: 'warm' }, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeExplicit({ scheme: 'warm' }));
            });
            it('should use the specified scheme with extent for a nominal color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.NOMINAL, { scheme: { name: 'warm', extent: [0.2, 1] } }, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeExplicit({ scheme: 'warm', extent: [0.2, 1] }));
            });
            it('should use the specified range for a nominal color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.NOMINAL, { range: ['red', 'green', 'blue'] }, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeExplicit(['red', 'green', 'blue']));
            });
            it('should use default category range in Vega for a nominal color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.NOMINAL, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit('category'));
            });
            it('should use default ordinal range in Vega for an ordinal color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.ORDINAL, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit('ordinal'));
            });
            it('should use default ramp range in Vega for a temporal/quantitative color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'sequential', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit('ramp'));
            });
            it('should use the specified scheme with count for a quantitative color field.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('color', 'ordinal', type_1.QUANTITATIVE, { scheme: { name: 'viridis', count: 3 } }, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeExplicit({ scheme: 'viridis', count: 3 }));
            });
        });
        describe('opacity', function () {
            it('should use default opacityRange as opacity\'s scale range.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('opacity', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit([config_1.defaultConfig.scale.minOpacity, config_1.defaultConfig.scale.maxOpacity]));
            });
        });
        describe('size', function () {
            describe('bar', function () {
                it('should return [minBandSize, maxBandSize] if both are specified', function () {
                    var config = {
                        scale: { minBandSize: 2, maxBandSize: 9 }
                    };
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config, undefined, 'bar', false, 'plot_width', []), split_1.makeImplicit([2, 9]));
                });
                it('should return [continuousBandSize, xRangeStep-1] by default since min/maxSize config are not specified', function () {
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'bar', false, 'plot_width', []), split_1.makeImplicit([2, config_1.defaultConfig.scale.rangeStep - 1]));
                });
            });
            describe('tick', function () {
                it('should return [minBandSize, maxBandSize] if both are specified', function () {
                    var config = {
                        scale: { minBandSize: 4, maxBandSize: 9 }
                    };
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config, undefined, 'tick', false, 'plot_width', []), split_1.makeImplicit([4, 9]));
                });
                it('should return [(default)minBandSize, rangeStep-1] by default since maxSize config is not specified', function () {
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'tick', false, 'plot_width', []), split_1.makeImplicit([config_1.defaultConfig.scale.minBandSize, config_1.defaultConfig.scale.rangeStep - 1]));
                });
            });
            describe('text', function () {
                it('should return [minFontSize, maxFontSize]', function () {
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'text', false, 'plot_width', []), split_1.makeImplicit([config_1.defaultConfig.scale.minFontSize, config_1.defaultConfig.scale.maxFontSize]));
                });
            });
            describe('rule', function () {
                it('should return [minStrokeWidth, maxStrokeWidth]', function () {
                    chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'rule', false, 'plot_width', []), split_1.makeImplicit([config_1.defaultConfig.scale.minStrokeWidth, config_1.defaultConfig.scale.maxStrokeWidth]));
                });
            });
            describe('point, square, circle', function () {
                it('should return [minSize, maxSize]', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        var config = {
                            scale: {
                                minSize: 5,
                                maxSize: 25
                            }
                        };
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config, undefined, m, false, 'plot_width', []), split_1.makeImplicit([5, 25]));
                    }
                });
                it('should return [0, (minBandSize-2)^2] if both x and y are discrete and size is quantitative (thus use zero=true, by default)', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, true, m, false, 'plot_width', [11, 13] // xyRangeSteps
                        ), split_1.makeImplicit([0, 81]));
                    }
                });
                it('should return [9, (minBandSize-2)^2] if both x and y are discrete and size is not quantitative (thus use zero=false, by default)', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, false, m, false, 'plot_width', [11, 13] // xyRangeSteps
                        ), split_1.makeImplicit([9, 81]));
                    }
                });
                it('should return [9, (minBandSize-2)^2] if both x and y are discrete and size is quantitative but use zero=false', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, false, m, false, 'plot_width', [11, 13] // xyRangeSteps
                        ), split_1.makeImplicit([9, 81]));
                    }
                });
                it('should return [0, (xRangeStep-2)^2] if x is discrete and y is continuous and size is quantitative (thus use zero=true, by default)', function () {
                    for (var _i = 0, _a = ['point', 'square', 'circle']; _i < _a.length; _i++) {
                        var m = _a[_i];
                        chai_1.assert.deepEqual(range_1.parseRangeForChannel('size', 'linear', type_1.QUANTITATIVE, {}, config_1.defaultConfig, true, m, false, 'plot_width', [11] // xyRangeSteps only have one value
                        ), split_1.makeImplicit([0, 81]));
                    }
                });
            });
        });
        describe('shape', function () {
            it('should use default symbol range in Vega as shape\'s scale range.', function () {
                chai_1.assert.deepEqual(range_1.parseRangeForChannel('shape', 'ordinal', type_1.QUANTITATIVE, {}, config_1.defaultConfig, undefined, 'point', false, 'plot_width', []), split_1.makeImplicit('symbol'));
            });
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UudGVzdC5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uLy4uLy4uL3Rlc3QvY29tcGlsZS9zY2FsZS9yYW5nZS50ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSw4QkFBOEI7OztBQUU5Qiw2QkFBNEI7QUFFNUIsMERBQXNFO0FBQ3RFLG9EQUFzRTtBQUN0RSw4Q0FBa0Q7QUFDbEQsNERBQXdDO0FBRXhDLDRDQUFzRztBQUN0RywwQ0FBaUU7QUFFakUsUUFBUSxDQUFDLGVBQWUsRUFBRTtJQUN4QixRQUFRLENBQUMsY0FBYyxFQUFFO1FBQ3ZCLFFBQVEsQ0FBQyxVQUFVLEVBQUU7WUFDbkIsRUFBRSxDQUFDLG1FQUFtRSxFQUFFO2dCQUN0RSxLQUF3QixVQUErQixFQUEvQixvQ0FBQSx1Q0FBK0IsRUFBL0IsNkNBQStCLEVBQS9CLElBQStCLEVBQUU7b0JBQXBELElBQU0sU0FBUyx3Q0FBQTtvQkFDbEIsYUFBTSxDQUFDLFNBQVMsQ0FDZCw0QkFBb0IsQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLG1CQUFZLEVBQUUsRUFBRSxFQUFFLHNCQUFhLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLEVBQUUsQ0FBQyxFQUM3RyxvQkFBWSxDQUFDLENBQUMsQ0FBQyxFQUFFLEVBQUMsTUFBTSxFQUFFLFlBQVksRUFBQyxDQUFDLENBQUMsQ0FDMUMsQ0FBQztpQkFDSDtZQUNILENBQUMsQ0FBQyxDQUFDO1lBRUgsRUFBRSxDQUFDLG1FQUFtRSxFQUFFO2dCQUN0RSxLQUF3QixVQUErQixFQUEvQixvQ0FBQSx1Q0FBK0IsRUFBL0IsNkNBQStCLEVBQS9CLElBQStCLEVBQUU7b0JBQXBELElBQU0sU0FBUyx3Q0FBQTtvQkFDbEIsYUFBTSxDQUFDLFNBQVMsQ0FDZCw0QkFBb0IsQ0FBQyxHQUFHLEVBQUUsU0FBUyxFQUFFLG1CQUFZLEVBQUUsRUFBRSxFQUFFLHNCQUFhLEVBQUUsSUFBSSxFQUFF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QUUsc0JBQWEsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLEtBQUssRUFBRSxZQUFZLEVBQ2xHLENBQUMsRUFBRSxDQUFDLENBQUMsbUNBQW1DO3lCQUN6QyxFQUNELG9CQUFZLENBQUMsQ0FBQyxDQUFDLEVBQUUsRUFBRSxDQUFDLENBQUMsQ0FDdEIsQ0FBQztxQkFDSDtnQkFDSCxDQUFDLENBQUMsQ0FBQztZQUNMLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7UUFFSCxRQUFRLENBQUMsT0FBTyxFQUFFO1lBQ2hCLEVBQUUsQ0FBQyxrRUFBa0UsRUFBRTtnQkFDckUsYUFBTSxDQUFDLFNBQVMsQ0FDZCw0QkFBb0IsQ0FBQyxPQUFPLEVBQUUsU0FBUyxFQUFFLG1CQUFZLEVBQUUsRUFBRSxFQUFFLHNCQUFhLEVBQUUsU0FBUyxFQUFFLE9BQU8sRUFBRSxLQUFLLEVBQUUsWUFBWSxFQUFFLEVBQUUsQ0FBQyxFQUN0SCxvQkFBWSxDQUFDLFFBQVEsQ0FBQyxDQUN2QixDQUFDO1lBQ0osQ0FBQyxDQUFDLENBQUM7UUFDTCxDQUFDLENBQUMsQ0FBQztJQUNMLENBQUMsQ0FBQyxDQUFDO0FBQ0wsQ0FBQyxDQUFDLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvKiB0c2xpbnQ6ZGlzYWJsZTpxdW90ZW1hcmsgKi9cblxuaW1wb3J0IHthc3NlcnR9IGZyb20gJ2NoYWknO1xuXG5pbXBvcnQge3BhcnNlUmFuZ2VGb3JDaGFubmVsfSBmcm9tICcuLi8uLi8uLi9zcmMvY29tcGlsZS9zY2FsZS9yYW5nZSc7XG5pbXBvcnQge21ha2VFeHBsaWNpdCwgbWFrZUltcGxpY2l0fSBmcm9tICcuLi8uLi8uLi9zcmMvY29tcGlsZS9zcGxpdCc7XG5pbXBvcnQge2RlZmF1bHRDb25maWd9IGZyb20gJy4uLy4uLy4uL3NyYy9jb25maWcnO1xuaW1wb3J0ICogYXMgbG9nIGZyb20gJy4uLy4uLy4uL3NyYy9sb2cnO1xuaW1wb3J0IHtNYXJrfSBmcm9tICcuLi8uLi8uLi9zcmMvbWFyayc7XG5pbXBvcnQge0NPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMsIERJU0NSRVRFX0RPTUFJTl9TQ0FMRVMsIFNjYWxlVHlwZX0gZnJvbSAnLi4vLi4vLi4vc3JjL3NjYWxlJztcbmltcG9ydCB7Tk9NSU5BTCwgT1JESU5BTCwgUVVBTlRJVEFUSVZFfSBmcm9tICcuLi8uLi8uLi9zcmMvdHlwZSc7XG5cbmRlc2NyaWJlKCdjb21waWxlL3NjYWxlJywgKCkgPT4ge1xuICBkZXNjcmliZSgncGFyc2VSYW5nZSgpJywgZnVuY3Rpb24oKSB7XG4gICAgZGVzY3JpYmUoJ3Bvc2l0aW9uJywgKCkgPT4ge1xuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gWzAsIHBsb3Rfd2lkdGhdIGZvciB4LWNvbnRpbnVvdXMgc2NhbGVzIGJ5IGRlZmF1bHQuJywgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHNjYWxlVHlwZSBvZiBDT05USU5VT1VTX1RPX0NPTlRJTlVPVVNfU0NBTEVTKSB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB0cnVlLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoWzAsIHtzaWduYWw6ICdwbG90X3dpZHRoJ31dKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBbcGxvdF9oZWlnaHQsMF0gZm9yIHktY29udGludW91cyBzY2FsZXMgYnkgZGVmYXVsdC4nLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIENPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMpIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3knLCBzY2FsZVR5cGUsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHRydWUsICdwb2ludCcsIGZhbHNlLCAncGxvdF9oZWlnaHQnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoW3tzaWduYWw6ICdwbG90X2hlaWdodCd9LCAwXSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gWzAsIHBsb3RfaGVpZ2h0XSBmb3IgeS1kaXNjcmV0ZSBzY2FsZXMgd2l0aCBoZWlnaHQgYnkgZGVmYXVsdC4nLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIERJU0NSRVRFX0RPTUFJTl9TQ0FMRVMpIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3knLCBzY2FsZVR5cGUsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHRydWUsICdwb2ludCcsIHRydWUsICdwbG90X2hlaWdodCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbMCwge3NpZ25hbDogJ3Bsb3RfaGVpZ2h0J31dKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHN1cHBvcnQgY3VzdG9tIHJhbmdlLicsIGxvZy53cmFwKChsb2NhbExvZ2dlcikgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4JywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge3JhbmdlOiBbMCwgMTAwXX0sIGRlZmF1bHRDb25maWcsIHRydWUsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlRXhwbGljaXQoWzAsIDEwMF0pXG4gICAgICAgICk7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwobG9jYWxMb2dnZXIud2FybnMubGVuZ3RoLCAwKTtcbiAgICAgIH0pKTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gY29uZmlnLnNjYWxlLnJhbmdlU3RlcCBmb3IgYmFuZC9wb2ludCBzY2FsZXMgYnkgZGVmYXVsdC4nLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIFsncG9pbnQnLCAnYmFuZCddIGFzIFNjYWxlVHlwZVtdKSB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBOT01JTkFMLCB7fSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoe3N0ZXA6IDIxfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gY29uZmlnLnNjYWxlLnRleHRYUmFuZ2VTdGVwIGJ5IGRlZmF1bHQgZm9yIHRleHQgbWFya1xcJ3MgeCBiYW5kL3BvaW50IHNjYWxlcy4nLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIFsncG9pbnQnLCAnYmFuZCddIGFzIFNjYWxlVHlwZVtdKSB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBOT01JTkFMLCB7fSwge3NjYWxlOiB7dGV4dFhSYW5nZVN0ZXA6IDU1fX0sIHVuZGVmaW5lZCwgJ3RleHQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoe3N0ZXA6IDU1fSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gc3BlY2lmaWVkIHJhbmdlU3RlcCBpZiB0b3BMZXZlbFNpemUgaXMgdW5kZWZpbmVkIGZvciBiYW5kL3BvaW50IHNjYWxlcycsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgWydwb2ludCcsICdiYW5kJ10gYXMgU2NhbGVUeXBlW10pIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3gnLCBzY2FsZVR5cGUsIE5PTUlOQUwsIHtyYW5nZVN0ZXA6IDIzfSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAndGV4dCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VFeHBsaWNpdCh7c3RlcDogMjN9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIGRyb3AgcmFuZ2VTdGVwIGlmIHRvcExldmVsU2l6ZSBpcyBzcGVjaWZpZWQgZm9yIGJhbmQvcG9pbnQgc2NhbGVzJywgbG9nLndyYXAoKGxvY2FsTG9nZ2VyKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIFsncG9pbnQnLCAnYmFuZCddIGFzIFNjYWxlVHlwZVtdKSB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBOT01JTkFMLCB7cmFuZ2VTdGVwOiAyM30sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3RleHQnLCB0cnVlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbMCwge3NpZ25hbDogJ3Bsb3Rfd2lkdGgnfV0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBhc3NlcnQuZXF1YWwobG9jYWxMb2dnZXIud2FybnNbMF0sIGxvZy5tZXNzYWdlLnJhbmdlU3RlcERyb3BwZWQoJ3gnKSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGRlZmF1bHQgdG9wTGV2ZWxTaXplIGlmIHJhbmdlU3RlcCBpcyBudWxsIGZvciBiYW5kL3BvaW50IHNjYWxlcycsICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgWydwb2ludCcsICdiYW5kJ10gYXMgU2NhbGVUeXBlW10pIHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3gnLCBzY2FsZVR5cGUsIE5PTUlOQUwsIHtyYW5nZVN0ZXA6IG51bGx9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICd0ZXh0JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFswLCB7c2lnbmFsOiAncGxvdF93aWR0aCd9XSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZGVmYXVsdCB0b3BMZXZlbFNpemUgaWYgcmFuZ2VTdGVwIGNvbmZpZyBpcyBudWxsJywgKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IHNjYWxlVHlwZSBvZiBbJ3BvaW50JywgJ2JhbmQnXSBhcyBTY2FsZVR5cGVbXSkge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgneCcsIHNjYWxlVHlwZSwgTk9NSU5BTCwge30sIHt2aWV3OiB7d2lkdGg6IDIwMH0sIHNjYWxlOiB7cmFuZ2VTdGVwOiBudWxsfX0sIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFswLCB7c2lnbmFsOiAncGxvdF93aWR0aCd9XSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZGVmYXVsdCB0b3BMZXZlbFNpemUgZm9yIHRleHQgaWYgdGV4dFhSYW5nZVN0ZXAgY29uZmlnIGlzIG51bGwnLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIFsncG9pbnQnLCAnYmFuZCddIGFzIFNjYWxlVHlwZVtdKSB7XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBOT01JTkFMLCB7fSwge3ZpZXc6IHt3aWR0aDogMjAwfSwgc2NhbGU6IHt0ZXh0WFJhbmdlU3RlcDogbnVsbH19LCB1bmRlZmluZWQsICd0ZXh0JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFswLCB7c2lnbmFsOiAncGxvdF93aWR0aCd9XSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCBkcm9wIHJhbmdlU3RlcCBmb3IgY29udGludW91cyBzY2FsZXMnLCAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgc2NhbGVUeXBlIG9mIENPTlRJTlVPVVNfVE9fQ09OVElOVU9VU19TQ0FMRVMpIHtcbiAgICAgICAgICBsb2cud3JhcCgobG9jYWxMb2dnZXIpID0+IHtcbiAgICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCd4Jywgc2NhbGVUeXBlLCBRVUFOVElUQVRJVkUsIHtyYW5nZVN0ZXA6IDIzfSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAndGV4dCcsIHRydWUsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgICBtYWtlSW1wbGljaXQoWzAsIHtzaWduYWw6ICdwbG90X3dpZHRoJ31dKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbChsb2NhbExvZ2dlci53YXJuc1swXSwgbG9nLm1lc3NhZ2Uuc2NhbGVQcm9wZXJ0eU5vdFdvcmtXaXRoU2NhbGVUeXBlKHNjYWxlVHlwZSwgJ3JhbmdlU3RlcCcsICd4JykpO1xuICAgICAgICAgIH0pKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2NvbG9yJywgZnVuY3Rpb24oKSB7XG4gICAgICBpdCgnc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWVkIHNjaGVtZSBmb3IgYSBub21pbmFsIGNvbG9yIGZpZWxkLicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnY29sb3InLCAnb3JkaW5hbCcsIE5PTUlOQUwsIHtzY2hlbWU6ICd3YXJtJ30sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgIG1ha2VFeHBsaWNpdCh7c2NoZW1lOiAnd2FybSd9KVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdXNlIHRoZSBzcGVjaWZpZWQgc2NoZW1lIHdpdGggZXh0ZW50IGZvciBhIG5vbWluYWwgY29sb3IgZmllbGQuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdjb2xvcicsICdvcmRpbmFsJywgTk9NSU5BTCwge3NjaGVtZToge25hbWU6ICd3YXJtJywgZXh0ZW50OiBbMC4yLCAxXX19LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlRXhwbGljaXQoe3NjaGVtZTogJ3dhcm0nLCBleHRlbnQ6IFswLjIsIDFdfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWVkIHJhbmdlIGZvciBhIG5vbWluYWwgY29sb3IgZmllbGQuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdjb2xvcicsICdvcmRpbmFsJywgTk9NSU5BTCwge3JhbmdlOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ119LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlRXhwbGljaXQoWydyZWQnLCAnZ3JlZW4nLCAnYmx1ZSddKVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgY2F0ZWdvcnkgcmFuZ2UgaW4gVmVnYSBmb3IgYSBub21pbmFsIGNvbG9yIGZpZWxkLicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnY29sb3InLCAnb3JkaW5hbCcsIE5PTUlOQUwsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlSW1wbGljaXQoJ2NhdGVnb3J5JylcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IG9yZGluYWwgcmFuZ2UgaW4gVmVnYSBmb3IgYW4gb3JkaW5hbCBjb2xvciBmaWVsZC4nLCAoKSA9PiB7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ2NvbG9yJywgJ29yZGluYWwnLCBPUkRJTkFMLCB7fSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgbWFrZUltcGxpY2l0KCdvcmRpbmFsJylcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHVzZSBkZWZhdWx0IHJhbXAgcmFuZ2UgaW4gVmVnYSBmb3IgYSB0ZW1wb3JhbC9xdWFudGl0YXRpdmUgY29sb3IgZmllbGQuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdjb2xvcicsICdzZXF1ZW50aWFsJywgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAncG9pbnQnLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgbWFrZUltcGxpY2l0KCdyYW1wJylcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHVzZSB0aGUgc3BlY2lmaWVkIHNjaGVtZSB3aXRoIGNvdW50IGZvciBhIHF1YW50aXRhdGl2ZSBjb2xvciBmaWVsZC4nLCAoKSA9PiB7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ2NvbG9yJywgJ29yZGluYWwnLCBRVUFOVElUQVRJVkUsIHtzY2hlbWU6IHtuYW1lOiAndmlyaWRpcycsIGNvdW50OiAzfX0sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgIG1ha2VFeHBsaWNpdCh7c2NoZW1lOiAndmlyaWRpcycsIGNvdW50OiAzfSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ29wYWNpdHknLCBmdW5jdGlvbigpIHtcbiAgICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgb3BhY2l0eVJhbmdlIGFzIG9wYWNpdHlcXCdzIHNjYWxlIHJhbmdlLicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnb3BhY2l0eScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdwb2ludCcsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICBtYWtlSW1wbGljaXQoW2RlZmF1bHRDb25maWcuc2NhbGUubWluT3BhY2l0eSwgZGVmYXVsdENvbmZpZy5zY2FsZS5tYXhPcGFjaXR5XSlcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ3NpemUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGRlc2NyaWJlKCdiYXInLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gW21pbkJhbmRTaXplLCBtYXhCYW5kU2l6ZV0gaWYgYm90aCBhcmUgc3BlY2lmaWVkJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHNjYWxlOiB7bWluQmFuZFNpemU6IDIsIG1heEJhbmRTaXplOiA5fVxuICAgICAgICAgIH07XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaXplJywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGNvbmZpZywgdW5kZWZpbmVkLCAnYmFyJywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFsyLCA5XSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbY29udGludW91c0JhbmRTaXplLCB4UmFuZ2VTdGVwLTFdIGJ5IGRlZmF1bHQgc2luY2UgbWluL21heFNpemUgY29uZmlnIGFyZSBub3Qgc3BlY2lmaWVkJywgKCkgPT4ge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICdiYXInLCBmYWxzZSwgJ3Bsb3Rfd2lkdGgnLCBbXSksXG4gICAgICAgICAgICBtYWtlSW1wbGljaXQoWzIsIGRlZmF1bHRDb25maWcuc2NhbGUucmFuZ2VTdGVwIC0gMV0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3RpY2snLCBmdW5jdGlvbigpIHtcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gW21pbkJhbmRTaXplLCBtYXhCYW5kU2l6ZV0gaWYgYm90aCBhcmUgc3BlY2lmaWVkJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IHtcbiAgICAgICAgICAgIHNjYWxlOiB7bWluQmFuZFNpemU6IDQsIG1heEJhbmRTaXplOiA5fVxuICAgICAgICAgIH07XG4gICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaXplJywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGNvbmZpZywgdW5kZWZpbmVkLCAndGljaycsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbNCwgOV0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gWyhkZWZhdWx0KW1pbkJhbmRTaXplLCByYW5nZVN0ZXAtMV0gYnkgZGVmYXVsdCBzaW5jZSBtYXhTaXplIGNvbmZpZyBpcyBub3Qgc3BlY2lmaWVkJywgKCkgPT4ge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICd0aWNrJywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFtkZWZhdWx0Q29uZmlnLnNjYWxlLm1pbkJhbmRTaXplLCBkZWZhdWx0Q29uZmlnLnNjYWxlLnJhbmdlU3RlcCAtIDFdKVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCd0ZXh0JywgZnVuY3Rpb24oKSB7XG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFttaW5Gb250U2l6ZSwgbWF4Rm9udFNpemVdJywgKCkgPT4ge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCB1bmRlZmluZWQsICd0ZXh0JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgbWFrZUltcGxpY2l0KFtkZWZhdWx0Q29uZmlnLnNjYWxlLm1pbkZvbnRTaXplLCBkZWZhdWx0Q29uZmlnLnNjYWxlLm1heEZvbnRTaXplXSlcbiAgICAgICAgICApO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuXG4gICAgICBkZXNjcmliZSgncnVsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbbWluU3Ryb2tlV2lkdGgsIG1heFN0cm9rZVdpZHRoXScsICgpID0+IHtcbiAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3NpemUnLCAnbGluZWFyJywgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgdW5kZWZpbmVkLCAncnVsZScsIGZhbHNlLCAncGxvdF93aWR0aCcsIFtdKSxcbiAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbZGVmYXVsdENvbmZpZy5zY2FsZS5taW5TdHJva2VXaWR0aCwgZGVmYXVsdENvbmZpZy5zY2FsZS5tYXhTdHJva2VXaWR0aF0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ3BvaW50LCBzcXVhcmUsIGNpcmNsZScsIGZ1bmN0aW9uKCkge1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbbWluU2l6ZSwgbWF4U2l6ZV0nLCAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBtIG9mIFsncG9pbnQnLCAnc3F1YXJlJywgJ2NpcmNsZSddIGFzIE1hcmtbXSkge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0ge1xuICAgICAgICAgICAgICBzY2FsZToge1xuICAgICAgICAgICAgICAgIG1pblNpemU6IDUsXG4gICAgICAgICAgICAgICAgbWF4U2l6ZTogMjVcblxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBjb25maWcsIHVuZGVmaW5lZCwgbSwgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgICAgICBtYWtlSW1wbGljaXQoWzUsIDI1XSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBbMCwgKG1pbkJhbmRTaXplLTIpXjJdIGlmIGJvdGggeCBhbmQgeSBhcmUgZGlzY3JldGUgYW5kIHNpemUgaXMgcXVhbnRpdGF0aXZlICh0aHVzIHVzZSB6ZXJvPXRydWUsIGJ5IGRlZmF1bHQpJywgKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgbSBvZiBbJ3BvaW50JywgJ3NxdWFyZScsICdjaXJjbGUnXSBhcyBNYXJrW10pIHtcbiAgICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICAgIHBhcnNlUmFuZ2VGb3JDaGFubmVsKCdzaXplJywgJ2xpbmVhcicsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHRydWUsIG0sIGZhbHNlLCAncGxvdF93aWR0aCcsXG4gICAgICAgICAgICAgICAgWzExLCAxM10gLy8geHlSYW5nZVN0ZXBzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbMCwgODFdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFs5LCAobWluQmFuZFNpemUtMileMl0gaWYgYm90aCB4IGFuZCB5IGFyZSBkaXNjcmV0ZSBhbmQgc2l6ZSBpcyBub3QgcXVhbnRpdGF0aXZlICh0aHVzIHVzZSB6ZXJvPWZhbHNlLCBieSBkZWZhdWx0KScsICgpID0+IHtcbiAgICAgICAgICBmb3IgKGNvbnN0IG0gb2YgWydwb2ludCcsICdzcXVhcmUnLCAnY2lyY2xlJ10gYXMgTWFya1tdKSB7XG4gICAgICAgICAgICBhc3NlcnQuZGVlcEVxdWFsKFxuICAgICAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2l6ZScsICdsaW5lYXInLCBRVUFOVElUQVRJVkUsIHt9LCBkZWZhdWx0Q29uZmlnLCBmYWxzZSwgbSwgZmFsc2UsICdwbG90X3dpZHRoJyxcbiAgICAgICAgICAgICAgICBbMTEsIDEzXSAvLyB4eVJhbmdlU3RlcHNcbiAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgbWFrZUltcGxpY2l0KFs5LCA4MV0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gWzksIChtaW5CYW5kU2l6ZS0yKV4yXSBpZiBib3RoIHggYW5kIHkgYXJlIGRpc2NyZXRlIGFuZCBzaXplIGlzIHF1YW50aXRhdGl2ZSBidXQgdXNlIHplcm89ZmFsc2UnLCAoKSA9PiB7XG4gICAgICAgICAgZm9yIChjb25zdCBtIG9mIFsncG9pbnQnLCAnc3F1YXJlJywgJ2NpcmNsZSddIGFzIE1hcmtbXSkge1xuICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3NpemUnLCAnbGluZWFyJywgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgZmFsc2UsIG0sIGZhbHNlLCAncGxvdF93aWR0aCcsXG4gICAgICAgICAgICAgICAgWzExLCAxM10gLy8geHlSYW5nZVN0ZXBzXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbOSwgODFdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIFswLCAoeFJhbmdlU3RlcC0yKV4yXSBpZiB4IGlzIGRpc2NyZXRlIGFuZCB5IGlzIGNvbnRpbnVvdXMgYW5kIHNpemUgaXMgcXVhbnRpdGF0aXZlICh0aHVzIHVzZSB6ZXJvPXRydWUsIGJ5IGRlZmF1bHQpJywgKCkgPT4ge1xuICAgICAgICAgICAgZm9yIChjb25zdCBtIG9mIFsncG9pbnQnLCAnc3F1YXJlJywgJ2NpcmNsZSddIGFzIE1hcmtbXSkge1xuICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgICAgcGFyc2VSYW5nZUZvckNoYW5uZWwoJ3NpemUnLCAnbGluZWFyJywgUVVBTlRJVEFUSVZFLCB7fSwgZGVmYXVsdENvbmZpZywgdHJ1ZSwgbSwgZmFsc2UsICdwbG90X3dpZHRoJyxcbiAgICAgICAgICAgICAgICBbMTFdIC8vIHh5UmFuZ2VTdGVwcyBvbmx5IGhhdmUgb25lIHZhbHVlXG4gICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgIG1ha2VJbXBsaWNpdChbMCwgODFdKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBkZXNjcmliZSgnc2hhcGUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGl0KCdzaG91bGQgdXNlIGRlZmF1bHQgc3ltYm9sIHJhbmdlIGluIFZlZ2EgYXMgc2hhcGVcXCdzIHNjYWxlIHJhbmdlLicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICBwYXJzZVJhbmdlRm9yQ2hhbm5lbCgnc2hhcGUnLCAnb3JkaW5hbCcsIFFVQU5USVRBVElWRSwge30sIGRlZmF1bHRDb25maWcsIHVuZGVmaW5lZCwgJ3BvaW50JywgZmFsc2UsICdwbG90X3dpZHRoJywgW10pLFxuICAgICAgICAgIG1ha2VJbXBsaWNpdCgnc3ltYm9sJylcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19