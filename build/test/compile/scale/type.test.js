"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var chai_1 = require("chai");
var channel_1 = require("../../../src/channel");
var type_1 = require("../../../src/compile/scale/type");
var config_1 = require("../../../src/config");
var log = require("../../../src/log");
var mark_1 = require("../../../src/mark");
var scale_1 = require("../../../src/scale");
var timeunit_1 = require("../../../src/timeunit");
var type_2 = require("../../../src/type");
var util = require("../../../src/util");
var defaultScaleConfig = config_1.defaultConfig.scale;
describe('compile/scale', function () {
    describe('type()', function () {
        it('should return null for channel without scale', function () {
            chai_1.assert.deepEqual(type_1.scaleType(undefined, 'detail', { type: 'temporal', timeUnit: 'yearmonth' }, 'point', defaultScaleConfig), null);
        });
        it('should show warning if users try to override the scale and use bin', log.wrap(function (localLogger) {
            chai_1.assert.deepEqual(type_1.scaleType('point', 'color', { type: 'quantitative', bin: true }, 'point', defaultScaleConfig), scale_1.ScaleType.BIN_ORDINAL);
            chai_1.assert.equal(localLogger.warns[0], log.message.scaleTypeNotWorkWithFieldDef(scale_1.ScaleType.POINT, scale_1.ScaleType.BIN_ORDINAL));
        }));
        describe('nominal/ordinal', function () {
            describe('color', function () {
                it('should return ordinal scale for nominal data by default.', function () {
                    chai_1.assert.equal(type_1.scaleType(undefined, 'color', { type: 'nominal' }, 'point', defaultScaleConfig), scale_1.ScaleType.ORDINAL);
                });
                it('should return ordinal scale for ordinal data.', function () {
                    chai_1.assert.equal(type_1.scaleType(undefined, 'color', { type: 'nominal' }, 'point', defaultScaleConfig), scale_1.ScaleType.ORDINAL);
                });
            });
            describe('discrete channel (shape)', function () {
                it('should return ordinal for nominal field', function () {
                    chai_1.assert.deepEqual(type_1.scaleType(undefined, 'shape', { type: 'nominal' }, 'point', defaultScaleConfig), scale_1.ScaleType.ORDINAL);
                });
                it('should return ordinal even if other type is specified', log.wrap(function (localLogger) {
                    [scale_1.ScaleType.LINEAR, scale_1.ScaleType.BAND, scale_1.ScaleType.POINT].forEach(function (badScaleType) {
                        chai_1.assert.deepEqual(type_1.scaleType(badScaleType, 'shape', { type: 'nominal' }, 'point', defaultScaleConfig), scale_1.ScaleType.ORDINAL);
                        var warns = localLogger.warns;
                        chai_1.assert.equal(warns[warns.length - 1], log.message.scaleTypeNotWorkWithChannel('shape', badScaleType, 'ordinal'));
                    });
                }));
                it('should return ordinal for an ordinal field and throw a warning.', log.wrap(function (localLogger) {
                    chai_1.assert.deepEqual(type_1.scaleType(undefined, 'shape', { type: 'ordinal' }, 'point', defaultScaleConfig), scale_1.ScaleType.ORDINAL);
                    chai_1.assert.equal(localLogger.warns[0], log.message.discreteChannelCannotEncode('shape', 'ordinal'));
                }));
            });
            describe('continuous', function () {
                it('should return point scale for ordinal X,Y for marks others than rect, rule, and bar', function () {
                    mark_1.PRIMITIVE_MARKS.forEach(function (mark) {
                        if (util.contains(['bar', 'rule', 'rect'], mark)) {
                            return;
                        }
                        [type_2.ORDINAL, type_2.NOMINAL].forEach(function (t) {
                            [channel_1.X, channel_1.Y].forEach(function (channel) {
                                chai_1.assert.equal(type_1.scaleType(undefined, channel, { type: t }, mark, defaultScaleConfig), scale_1.ScaleType.POINT);
                            });
                        });
                    });
                });
                it('should return band scale for ordinal X,Y when mark is rect, rule, bar', function () {
                    [type_2.ORDINAL, type_2.NOMINAL].forEach(function (t) {
                        [channel_1.X, channel_1.Y].forEach(function (channel) {
                            ['bar', 'rule', 'rect'].forEach(function (mark) {
                                chai_1.assert.equal(type_1.scaleType(undefined, channel, { type: t }, 'rect', defaultScaleConfig), scale_1.ScaleType.BAND);
                            });
                        });
                    });
                });
                it('should return point scale for X,Y when mark is point', function () {
                    [type_2.ORDINAL, type_2.NOMINAL].forEach(function (t) {
                        [channel_1.X, channel_1.Y].forEach(function (channel) {
                            chai_1.assert.equal(type_1.scaleType(undefined, channel, { type: t }, 'point', defaultScaleConfig), scale_1.ScaleType.POINT);
                        });
                    });
                });
                it('should return point scale for X,Y when mark is point when ORDINAL SCALE TYPE is specified and throw warning', log.wrap(function (localLogger) {
                    [type_2.ORDINAL, type_2.NOMINAL].forEach(function (t) {
                        [channel_1.X, channel_1.Y].forEach(function (channel) {
                            chai_1.assert.equal(type_1.scaleType('ordinal', channel, { type: t }, 'point', defaultScaleConfig), scale_1.ScaleType.POINT);
                            var warns = localLogger.warns;
                            chai_1.assert.equal(warns[warns.length - 1], log.message.scaleTypeNotWorkWithChannel(channel, 'ordinal', 'point'));
                        });
                    });
                }));
                it('should return point scale for ordinal/nominal fields for continuous channels other than x and y.', function () {
                    var OTHER_CONTINUOUS_CHANNELS = channel_1.SCALE_CHANNELS.filter(function (c) { return channel_1.rangeType(c) === 'continuous' && !util.contains([channel_1.X, channel_1.Y], c); });
                    mark_1.PRIMITIVE_MARKS.forEach(function (mark) {
                        [type_2.ORDINAL, type_2.NOMINAL].forEach(function (t) {
                            OTHER_CONTINUOUS_CHANNELS.forEach(function (channel) {
                                chai_1.assert.equal(type_1.scaleType(undefined, channel, { type: t }, mark, defaultScaleConfig), scale_1.ScaleType.POINT, channel + ", " + mark + ", " + t + " " + type_1.scaleType(undefined, channel, { type: t }, mark, defaultScaleConfig));
                            });
                        });
                    });
                });
            });
        });
        describe('temporal', function () {
            it('should return sequential scale for temporal color field by default.', function () {
                chai_1.assert.equal(type_1.scaleType(undefined, 'color', { type: 'temporal' }, 'point', defaultScaleConfig), scale_1.ScaleType.SEQUENTIAL);
            });
            it('should return ordinal for temporal field and throw a warning.', log.wrap(function (localLogger) {
                chai_1.assert.deepEqual(type_1.scaleType(undefined, 'shape', { type: 'temporal', timeUnit: 'yearmonth' }, 'point', defaultScaleConfig), scale_1.ScaleType.ORDINAL);
                chai_1.assert.equal(localLogger.warns[0], log.message.discreteChannelCannotEncode('shape', 'temporal'));
            }));
            it('should return time for all time units.', function () {
                for (var _i = 0, TIMEUNITS_1 = timeunit_1.TIMEUNITS; _i < TIMEUNITS_1.length; _i++) {
                    var timeUnit = TIMEUNITS_1[_i];
                    chai_1.assert.deepEqual(type_1.scaleType(undefined, channel_1.Y, { type: 'temporal', timeUnit: timeUnit }, 'point', defaultScaleConfig), scale_1.ScaleType.TIME);
                }
            });
        });
        describe('quantitative', function () {
            it('should return sequential scale for quantitative color field by default.', function () {
                chai_1.assert.equal(type_1.scaleType(undefined, 'color', { type: 'quantitative' }, 'point', defaultScaleConfig), scale_1.ScaleType.SEQUENTIAL);
            });
            it('should return ordinal bin scale for quantitative color field with binning.', function () {
                chai_1.assert.equal(type_1.scaleType(undefined, 'color', { type: 'quantitative', bin: true }, 'point', defaultScaleConfig), scale_1.ScaleType.BIN_ORDINAL);
            });
            it('should return ordinal for encoding quantitative field with a discrete channel and throw a warning.', log.wrap(function (localLogger) {
                chai_1.assert.deepEqual(type_1.scaleType(undefined, 'shape', { type: 'quantitative' }, 'point', defaultScaleConfig), scale_1.ScaleType.ORDINAL);
                chai_1.assert.equal(localLogger.warns[0], log.message.discreteChannelCannotEncode('shape', 'quantitative'));
            }));
            it('should return linear scale for quantitative by default.', function () {
                chai_1.assert.equal(type_1.scaleType(undefined, 'x', { type: 'quantitative' }, 'point', defaultScaleConfig), scale_1.ScaleType.LINEAR);
            });
            it('should return bin linear scale for quantitative by default.', function () {
                chai_1.assert.equal(type_1.scaleType(undefined, 'opacity', { type: 'quantitative', bin: true }, 'point', defaultScaleConfig), scale_1.ScaleType.BIN_LINEAR);
            });
            it('should return linear scale for quantitative x and y.', function () {
                chai_1.assert.equal(type_1.scaleType(undefined, 'x', { type: 'quantitative', bin: true }, 'point', defaultScaleConfig), scale_1.ScaleType.LINEAR);
            });
        });
        describe('dataTypeMatchScaleType()', function () {
            it('should return specified value if datatype is ordinal or nominal and specified scale type is the ordinal or nominal', function () {
                chai_1.assert.equal(type_1.scaleType(scale_1.ScaleType.ORDINAL, 'shape', { type: 'ordinal' }, 'point', defaultScaleConfig), scale_1.ScaleType.ORDINAL);
            });
            it('should return default scale type if data type is temporal but specified scale type is not time or utc', function () {
                chai_1.assert.equal(type_1.scaleType(scale_1.ScaleType.LINEAR, 'x', { type: 'temporal', timeUnit: 'year' }, 'point', defaultScaleConfig), scale_1.ScaleType.TIME);
                chai_1.assert.equal(type_1.scaleType(scale_1.ScaleType.LINEAR, 'color', { type: 'temporal', timeUnit: 'year' }, 'point', defaultScaleConfig), scale_1.ScaleType.SEQUENTIAL);
            });
            it('should return time if data type is temporal but specified scale type is discrete', function () {
                chai_1.assert.equal(type_1.scaleType(scale_1.ScaleType.POINT, 'x', { type: 'temporal', timeUnit: 'year' }, 'point', defaultScaleConfig), scale_1.ScaleType.TIME);
            });
            it('should return default scale type if data type is temporal but specified scale type is time or utc or any discrete type', function () {
                chai_1.assert.equal(type_1.scaleType(scale_1.ScaleType.LINEAR, 'x', { type: 'temporal', timeUnit: 'year' }, 'point', defaultScaleConfig), scale_1.ScaleType.TIME);
            });
            it('should return default scale type if data type is quantative but scale type do not support quantative', function () {
                chai_1.assert.equal(type_1.scaleType(scale_1.ScaleType.TIME, 'color', { type: 'quantitative' }, 'point', defaultScaleConfig), scale_1.ScaleType.SEQUENTIAL);
            });
            it('should return default scale type if data type is quantative and scale type supports quantative', function () {
                chai_1.assert.equal(type_1.scaleType(scale_1.ScaleType.TIME, 'x', { type: 'quantitative' }, 'point', defaultScaleConfig), scale_1.ScaleType.LINEAR);
            });
            it('should return default scale type if data type is quantative and scale type supports quantative', function () {
                chai_1.assert.equal(type_1.scaleType(scale_1.ScaleType.TIME, 'x', { type: 'temporal' }, 'point', defaultScaleConfig), scale_1.ScaleType.TIME);
            });
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidHlwZS50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vdGVzdC9jb21waWxlL3NjYWxlL3R5cGUudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOztBQUFBLDZCQUE0QjtBQUM1QixnREFBcUU7QUFDckUsd0RBQTBEO0FBQzFELDhDQUFrRDtBQUNsRCxzQ0FBd0M7QUFDeEMsMENBQWtEO0FBQ2xELDRDQUE2QztBQUM3QyxrREFBZ0Q7QUFDaEQsMENBQW1EO0FBQ25ELHdDQUEwQztBQUUxQyxJQUFNLGtCQUFrQixHQUFHLHNCQUFhLENBQUMsS0FBSyxDQUFDO0FBRS9DLFFBQVEsQ0FBQyxlQUFlLEVBQUU7SUFDeEIsUUFBUSxDQUFDLFFBQVEsRUFBRTtRQUNqQixFQUFFLENBQUMsOENBQThDLEVBQUU7WUFDakQsYUFBTSxDQUFDLFNBQVMsQ0FDZCxnQkFBUyxDQUFDLFNBQVMsRUFBRSxRQUFRLEVBQUUsRUFBQyxJQUFJLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBRSxXQUFXLEVBQUMsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLENBQUMsRUFDdEcsSUFBSSxDQUNMLENBQUM7UUFDSixDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyxvRUFBb0UsRUFBRSxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQUMsV0FBVztZQUM1RixhQUFNLENBQUMsU0FBUyxDQUNkLGdCQUFTLENBQUMsT0FBTyxFQUFFLE9BQU8sRUFBRSxFQUFDLElBQUksRUFBRSxjQUFjLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBQyxFQUFFLE9BQU8sRUFBRSxrQkFBa0IsQ0FBQyxFQUMzRixpQkFBUyxDQUFDLFdBQVcsQ0FDdEIsQ0FBQztZQUNGLGFBQU0sQ0FBQyxLQUFLLENBQUMsV0FBVyxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxHQUFHLENBQUMsT0FBTyxDQUFDLDRCQUE0QixDQUFDLGlCQUFTLENBQUMsS0FBSyxFQUFFLGlCQUFTLENBQUMs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TSxDQUFDLEtBQUssQ0FDVixnQkFBUyxDQUFDLGlCQUFTLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxFQUFDLElBQUksRUFBRSxVQUFVLEVBQUMsRUFBRSxPQUFPLEVBQUUsa0JBQWtCLENBQUMsRUFDL0UsaUJBQVMsQ0FBQyxJQUFJLENBQ2YsQ0FBQztZQUNKLENBQUMsQ0FBQyxDQUFDO1FBQ0wsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHthc3NlcnR9IGZyb20gJ2NoYWknO1xuaW1wb3J0IHtyYW5nZVR5cGUsIFNDQUxFX0NIQU5ORUxTLCBYLCBZfSBmcm9tICcuLi8uLi8uLi9zcmMvY2hhbm5lbCc7XG5pbXBvcnQge3NjYWxlVHlwZX0gZnJvbSAnLi4vLi4vLi4vc3JjL2NvbXBpbGUvc2NhbGUvdHlwZSc7XG5pbXBvcnQge2RlZmF1bHRDb25maWd9IGZyb20gJy4uLy4uLy4uL3NyYy9jb25maWcnO1xuaW1wb3J0ICogYXMgbG9nIGZyb20gJy4uLy4uLy4uL3NyYy9sb2cnO1xuaW1wb3J0IHtQUklNSVRJVkVfTUFSS1N9IGZyb20gJy4uLy4uLy4uL3NyYy9tYXJrJztcbmltcG9ydCB7U2NhbGVUeXBlfSBmcm9tICcuLi8uLi8uLi9zcmMvc2NhbGUnO1xuaW1wb3J0IHtUSU1FVU5JVFN9IGZyb20gJy4uLy4uLy4uL3NyYy90aW1ldW5pdCc7XG5pbXBvcnQge05PTUlOQUwsIE9SRElOQUx9IGZyb20gJy4uLy4uLy4uL3NyYy90eXBlJztcbmltcG9ydCAqIGFzIHV0aWwgZnJvbSAnLi4vLi4vLi4vc3JjL3V0aWwnO1xuXG5jb25zdCBkZWZhdWx0U2NhbGVDb25maWcgPSBkZWZhdWx0Q29uZmlnLnNjYWxlO1xuXG5kZXNjcmliZSgnY29tcGlsZS9zY2FsZScsICgpID0+IHtcbiAgZGVzY3JpYmUoJ3R5cGUoKScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiBudWxsIGZvciBjaGFubmVsIHdpdGhvdXQgc2NhbGUnLCBmdW5jdGlvbigpIHtcbiAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgIHNjYWxlVHlwZSh1bmRlZmluZWQsICdkZXRhaWwnLCB7dHlwZTogJ3RlbXBvcmFsJywgdGltZVVuaXQ6ICd5ZWFybW9udGgnfSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSxcbiAgICAgICAgbnVsbFxuICAgICAgKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgc2hvdyB3YXJuaW5nIGlmIHVzZXJzIHRyeSB0byBvdmVycmlkZSB0aGUgc2NhbGUgYW5kIHVzZSBiaW4nLCBsb2cud3JhcCgobG9jYWxMb2dnZXIpID0+IHtcbiAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgIHNjYWxlVHlwZSgncG9pbnQnLCAnY29sb3InLCB7dHlwZTogJ3F1YW50aXRhdGl2ZScsIGJpbjogdHJ1ZX0sICdwb2ludCcsIGRlZmF1bHRTY2FsZUNvbmZpZyksXG4gICAgICAgIFNjYWxlVHlwZS5CSU5fT1JESU5BTFxuICAgICAgKTtcbiAgICAgIGFzc2VydC5lcXVhbChsb2NhbExvZ2dlci53YXJuc1swXSwgbG9nLm1lc3NhZ2Uuc2NhbGVUeXBlTm90V29ya1dpdGhGaWVsZERlZihTY2FsZVR5cGUuUE9JTlQsIFNjYWxlVHlwZS5CSU5fT1JESU5BTCkpO1xuICAgIH0pKTtcblxuICAgIGRlc2NyaWJlKCdub21pbmFsL29yZGluYWwnLCAoKSA9PiB7XG4gICAgICBkZXNjcmliZSgnY29sb3InLCAoKSA9PiB7XG4gICAgICAgIGl0KCdzaG91bGQgcmV0dXJuIG9yZGluYWwgc2NhbGUgZm9yIG5vbWluYWwgZGF0YSBieSBkZWZhdWx0LicsICgpID0+IHtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoXG4gICAgICAgICAgICBzY2FsZVR5cGUodW5kZWZpbmVkLCAnY29sb3InLCB7dHlwZTogJ25vbWluYWwnfSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSxcbiAgICAgICAgICAgIFNjYWxlVHlwZS5PUkRJTkFMXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gb3JkaW5hbCBzY2FsZSBmb3Igb3JkaW5hbCBkYXRhLicsICgpID0+IHtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwoXG4gICAgICAgICAgICBzY2FsZVR5cGUodW5kZWZpbmVkLCAnY29sb3InLCB7dHlwZTogJ25vbWluYWwnfSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSxcbiAgICAgICAgICAgIFNjYWxlVHlwZS5PUkRJTkFMXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcblxuICAgICAgZGVzY3JpYmUoJ2Rpc2NyZXRlIGNoYW5uZWwgKHNoYXBlKScsICgpID0+IHtcbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gb3JkaW5hbCBmb3Igbm9taW5hbCBmaWVsZCcsIGZ1bmN0aW9uKCkge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBzY2FsZVR5cGUodW5kZWZpbmVkLCAnc2hhcGUnLCB7dHlwZTogJ25vbWluYWwnfSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSxcbiAgICAgICAgICAgIFNjYWxlVHlwZS5PUkRJTkFMXG4gICAgICAgICAgKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gb3JkaW5hbCBldmVuIGlmIG90aGVyIHR5cGUgaXMgc3BlY2lmaWVkJywgbG9nLndyYXAoKGxvY2FsTG9nZ2VyKSA9PiB7XG4gICAgICAgICAgW1NjYWxlVHlwZS5MSU5FQVIsIFNjYWxlVHlwZS5CQU5ELCBTY2FsZVR5cGUuUE9JTlRdLmZvckVhY2goKGJhZFNjYWxlVHlwZSkgPT4ge1xuICAgICAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICAgICAgc2NhbGVUeXBlKGJhZFNjYWxlVHlwZSwgJ3NoYXBlJywge3R5cGU6ICdub21pbmFsJ30sICdwb2ludCcsIGRlZmF1bHRTY2FsZUNvbmZpZyksXG4gICAgICAgICAgICAgIFNjYWxlVHlwZS5PUkRJTkFMXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29uc3Qgd2FybnMgPSBsb2NhbExvZ2dlci53YXJucztcbiAgICAgICAgICAgIGFzc2VydC5lcXVhbCh3YXJuc1t3YXJucy5sZW5ndGgtMV0sIGxvZy5tZXNzYWdlLnNjYWxlVHlwZU5vdFdvcmtXaXRoQ2hhbm5lbCgnc2hhcGUnLCBiYWRTY2FsZVR5cGUsICdvcmRpbmFsJykpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gb3JkaW5hbCBmb3IgYW4gb3JkaW5hbCBmaWVsZCBhbmQgdGhyb3cgYSB3YXJuaW5nLicsIGxvZy53cmFwKChsb2NhbExvZ2dlcikgPT4ge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBzY2FsZVR5cGUodW5kZWZpbmVkLCAnc2hhcGUnLCB7dHlwZTogJ29yZGluYWwnfSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSxcbiAgICAgICAgICAgIFNjYWxlVHlwZS5PUkRJTkFMXG4gICAgICAgICAgKTtcbiAgICAgICAgICBhc3NlcnQuZXF1YWwobG9jYWxMb2dnZXIud2FybnNbMF0sIGxvZy5tZXNzYWdlLmRpc2NyZXRlQ2hhbm5lbENhbm5vdEVuY29kZSgnc2hhcGUnLCAnb3JkaW5hbCcpKTtcbiAgICAgICAgfSkpO1xuICAgICAgfSk7XG5cbiAgICAgIGRlc2NyaWJlKCdjb250aW51b3VzJywgKCkgPT4ge1xuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBwb2ludCBzY2FsZSBmb3Igb3JkaW5hbCBYLFkgZm9yIG1hcmtzIG90aGVycyB0aGFuIHJlY3QsIHJ1bGUsIGFuZCBiYXInLCAoKSA9PiB7XG4gICAgICAgICAgUFJJTUlUSVZFX01BUktTLmZvckVhY2goKG1hcmspID0+IHtcbiAgICAgICAgICAgIGlmICh1dGlsLmNvbnRhaW5zKFsnYmFyJywgJ3J1bGUnLCAncmVjdCddLCBtYXJrKSkge1xuICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIFtPUkRJTkFMLCBOT01JTkFMXS5mb3JFYWNoKCh0KSA9PiB7XG4gICAgICAgICAgICAgIFtYLCBZXS5mb3JFYWNoKChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKFxuICAgICAgICAgICAgICAgICAgc2NhbGVUeXBlKHVuZGVmaW5lZCwgY2hhbm5lbCwge3R5cGU6IHR9LCBtYXJrLCBkZWZhdWx0U2NhbGVDb25maWcpLFxuICAgICAgICAgICAgICAgICAgU2NhbGVUeXBlLlBPSU5UXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gYmFuZCBzY2FsZSBmb3Igb3JkaW5hbCBYLFkgd2hlbiBtYXJrIGlzIHJlY3QsIHJ1bGUsIGJhcicsICgpID0+IHtcbiAgICAgICAgICBbT1JESU5BTCwgTk9NSU5BTF0uZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgICAgW1gsIFldLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgICAgWydiYXInLCAncnVsZScsICdyZWN0J10uZm9yRWFjaCgobWFyaykgPT4ge1xuICAgICAgICAgICAgICAgIGFzc2VydC5lcXVhbChcbiAgICAgICAgICAgICAgICAgIHNjYWxlVHlwZSh1bmRlZmluZWQsIGNoYW5uZWwsIHt0eXBlOiB0fSwgJ3JlY3QnLCBkZWZhdWx0U2NhbGVDb25maWcpLFxuICAgICAgICAgICAgICAgICAgU2NhbGVUeXBlLkJBTkRcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBwb2ludCBzY2FsZSBmb3IgWCxZIHdoZW4gbWFyayBpcyBwb2ludCcsICgpID0+IHtcbiAgICAgICAgICBbT1JESU5BTCwgTk9NSU5BTF0uZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgICAgW1gsIFldLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNjYWxlVHlwZSh1bmRlZmluZWQsIGNoYW5uZWwsIHt0eXBlOiB0fSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSwgU2NhbGVUeXBlLlBPSU5UKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBwb2ludCBzY2FsZSBmb3IgWCxZIHdoZW4gbWFyayBpcyBwb2ludCB3aGVuIE9SRElOQUwgU0NBTEUgVFlQRSBpcyBzcGVjaWZpZWQgYW5kIHRocm93IHdhcm5pbmcnLCBsb2cud3JhcCgobG9jYWxMb2dnZXIpID0+IHtcbiAgICAgICAgICBbT1JESU5BTCwgTk9NSU5BTF0uZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgICAgW1gsIFldLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHNjYWxlVHlwZSgnb3JkaW5hbCcsIGNoYW5uZWwsIHt0eXBlOiB0fSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSwgU2NhbGVUeXBlLlBPSU5UKTtcbiAgICAgICAgICAgICAgY29uc3Qgd2FybnMgPSBsb2NhbExvZ2dlci53YXJucztcbiAgICAgICAgICAgICAgYXNzZXJ0LmVxdWFsKHdhcm5zW3dhcm5zLmxlbmd0aC0xXSwgbG9nLm1lc3NhZ2Uuc2NhbGVUeXBlTm90V29ya1dpdGhDaGFubmVsKGNoYW5uZWwsICdvcmRpbmFsJywgJ3BvaW50JykpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pKTtcblxuICAgICAgICBpdCgnc2hvdWxkIHJldHVybiBwb2ludCBzY2FsZSBmb3Igb3JkaW5hbC9ub21pbmFsIGZpZWxkcyBmb3IgY29udGludW91cyBjaGFubmVscyBvdGhlciB0aGFuIHggYW5kIHkuJywgKCkgPT4ge1xuICAgICAgICAgIGNvbnN0IE9USEVSX0NPTlRJTlVPVVNfQ0hBTk5FTFMgPSBTQ0FMRV9DSEFOTkVMUy5maWx0ZXIoKGMpID0+IHJhbmdlVHlwZShjKSA9PT0gJ2NvbnRpbnVvdXMnICYmICF1dGlsLmNvbnRhaW5zKFtYLCBZXSwgYykpO1xuICAgICAgICAgIFBSSU1JVElWRV9NQVJLUy5mb3JFYWNoKChtYXJrKSA9PiB7XG4gICAgICAgICAgICBbT1JESU5BTCwgTk9NSU5BTF0uZm9yRWFjaCgodCkgPT4ge1xuICAgICAgICAgICAgICBPVEhFUl9DT05USU5VT1VTX0NIQU5ORUxTLmZvckVhY2goKGNoYW5uZWwpID0+IHtcbiAgICAgICAgICAgICAgICBhc3NlcnQuZXF1YWwoXG4gICAgICAgICAgICAgICAgICBzY2FsZVR5cGUodW5kZWZpbmVkLCBjaGFubmVsLCB7dHlwZTogdH0sIG1hcmssIGRlZmF1bHRTY2FsZUNvbmZpZyksXG4gICAgICAgICAgICAgICAgICBTY2FsZVR5cGUuUE9JTlQsXG4gICAgICAgICAgICAgICAgICBgJHtjaGFubmVsfSwgJHttYXJrfSwgJHt0fSBgICsgc2NhbGVUeXBlKHVuZGVmaW5lZCwgY2hhbm5lbCwge3R5cGU6IHR9LCBtYXJrLCBkZWZhdWx0U2NhbGVDb25maWcpXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIGRlc2NyaWJlKCd0ZW1wb3JhbCcsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHNlcXVlbnRpYWwgc2NhbGUgZm9yIHRlbXBvcmFsIGNvbG9yIGZpZWxkIGJ5IGRlZmF1bHQuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZXF1YWwoXG4gICAgICAgICAgc2NhbGVUeXBlKHVuZGVmaW5lZCwgJ2NvbG9yJywge3R5cGU6ICd0ZW1wb3JhbCd9LCAncG9pbnQnLCBkZWZhdWx0U2NhbGVDb25maWcpLFxuICAgICAgICAgIFNjYWxlVHlwZS5TRVFVRU5USUFMXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gb3JkaW5hbCBmb3IgdGVtcG9yYWwgZmllbGQgYW5kIHRocm93IGEgd2FybmluZy4nLCBsb2cud3JhcCgobG9jYWxMb2dnZXIpID0+IHtcbiAgICAgICAgYXNzZXJ0LmRlZXBFcXVhbChcbiAgICAgICAgICBzY2FsZVR5cGUodW5kZWZpbmVkLCAnc2hhcGUnLCB7dHlwZTogJ3RlbXBvcmFsJywgdGltZVVuaXQ6ICd5ZWFybW9udGgnfSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSxcbiAgICAgICAgICBTY2FsZVR5cGUuT1JESU5BTFxuICAgICAgICApO1xuICAgICAgICBhc3NlcnQuZXF1YWwobG9jYWxMb2dnZXIud2FybnNbMF0sIGxvZy5tZXNzYWdlLmRpc2NyZXRlQ2hhbm5lbENhbm5vdEVuY29kZSgnc2hhcGUnLCAndGVtcG9yYWwnKSk7XG4gICAgICB9KSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHRpbWUgZm9yIGFsbCB0aW1lIHVuaXRzLicsIGZ1bmN0aW9uKCkge1xuICAgICAgICBmb3IgKGNvbnN0IHRpbWVVbml0IG9mIFRJTUVVTklUUykge1xuICAgICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgICBzY2FsZVR5cGUodW5kZWZpbmVkLCBZLCB7dHlwZTogJ3RlbXBvcmFsJywgdGltZVVuaXQ6IHRpbWVVbml0fSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSxcbiAgICAgICAgICAgIFNjYWxlVHlwZS5USU1FXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gICAgZGVzY3JpYmUoJ3F1YW50aXRhdGl2ZScsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHNlcXVlbnRpYWwgc2NhbGUgZm9yIHF1YW50aXRhdGl2ZSBjb2xvciBmaWVsZCBieSBkZWZhdWx0LicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKFxuICAgICAgICAgIHNjYWxlVHlwZSh1bmRlZmluZWQsICdjb2xvcicsIHt0eXBlOiAncXVhbnRpdGF0aXZlJ30sICdwb2ludCcsIGRlZmF1bHRTY2FsZUNvbmZpZyksXG4gICAgICAgICAgU2NhbGVUeXBlLlNFUVVFTlRJQUxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBvcmRpbmFsIGJpbiBzY2FsZSBmb3IgcXVhbnRpdGF0aXZlIGNvbG9yIGZpZWxkIHdpdGggYmlubmluZy4nLCAoKSA9PiB7XG4gICAgICAgIGFzc2VydC5lcXVhbChcbiAgICAgICAgICBzY2FsZVR5cGUodW5kZWZpbmVkLCAnY29sb3InLCB7dHlwZTogJ3F1YW50aXRhdGl2ZScsIGJpbjogdHJ1ZX0sICdwb2ludCcsIGRlZmF1bHRTY2FsZUNvbmZpZyksXG4gICAgICAgICAgU2NhbGVUeXBlLkJJTl9PUkRJTkFMXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gb3JkaW5hbCBmb3IgZW5jb2RpbmcgcXVhbnRpdGF0aXZlIGZpZWxkIHdpdGggYSBkaXNjcmV0ZSBjaGFubmVsIGFuZCB0aHJvdyBhIHdhcm5pbmcuJywgbG9nLndyYXAoKGxvY2FsTG9nZ2VyKSA9PiB7XG4gICAgICAgIGFzc2VydC5kZWVwRXF1YWwoXG4gICAgICAgICAgc2NhbGVUeXBlKHVuZGVmaW5lZCwgJ3NoYXBlJywge3R5cGU6ICdxdWFudGl0YXRpdmUnfSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSxcbiAgICAgICAgICBTY2FsZVR5cGUuT1JESU5BTFxuICAgICAgICApO1xuICAgICAgICBhc3NlcnQuZXF1YWwobG9jYWxMb2dnZXIud2FybnNbMF0sIGxvZy5tZXNzYWdlLmRpc2NyZXRlQ2hhbm5lbENhbm5vdEVuY29kZSgnc2hhcGUnLCAncXVhbnRpdGF0aXZlJykpO1xuICAgICAgfSkpO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBsaW5lYXIgc2NhbGUgZm9yIHF1YW50aXRhdGl2ZSBieSBkZWZhdWx0LicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKFxuICAgICAgICAgIHNjYWxlVHlwZSh1bmRlZmluZWQsICd4Jywge3R5cGU6ICdxdWFudGl0YXRpdmUnfSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSxcbiAgICAgICAgICBTY2FsZVR5cGUuTElORUFSXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gYmluIGxpbmVhciBzY2FsZSBmb3IgcXVhbnRpdGF0aXZlIGJ5IGRlZmF1bHQuJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZXF1YWwoXG4gICAgICAgICAgc2NhbGVUeXBlKHVuZGVmaW5lZCwgJ29wYWNpdHknLCB7dHlwZTogJ3F1YW50aXRhdGl2ZScsIGJpbjogdHJ1ZX0sICdwb2ludCcsIGRlZmF1bHRTY2FsZUNvbmZpZyksXG4gICAgICAgICAgU2NhbGVUeXBlLkJJTl9MSU5FQVJcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBsaW5lYXIgc2NhbGUgZm9yIHF1YW50aXRhdGl2ZSB4IGFuZCB5LicsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKFxuICAgICAgICAgIHNjYWxlVHlwZSh1bmRlZmluZWQsICd4Jywge3R5cGU6ICdxdWFudGl0YXRpdmUnLCBiaW46IHRydWV9LCAncG9pbnQnLCBkZWZhdWx0U2NhbGVDb25maWcpLFxuICAgICAgICAgIFNjYWxlVHlwZS5MSU5FQVJcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgZGVzY3JpYmUoJ2RhdGFUeXBlTWF0Y2hTY2FsZVR5cGUoKScsICgpID0+IHtcbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIHNwZWNpZmllZCB2YWx1ZSBpZiBkYXRhdHlwZSBpcyBvcmRpbmFsIG9yIG5vbWluYWwgYW5kIHNwZWNpZmllZCBzY2FsZSB0eXBlIGlzIHRoZSBvcmRpbmFsIG9yIG5vbWluYWwnLCAoKSA9PiB7XG4gICAgICAgIGFzc2VydC5lcXVhbChcbiAgICAgICAgICBzY2FsZVR5cGUoU2NhbGVUeXBlLk9SRElOQUwsICdzaGFwZScsIHt0eXBlOiAnb3JkaW5hbCd9LCAncG9pbnQnLCBkZWZhdWx0U2NhbGVDb25maWcpLFxuICAgICAgICAgIFNjYWxlVHlwZS5PUkRJTkFMXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZGVmYXVsdCBzY2FsZSB0eXBlIGlmIGRhdGEgdHlwZSBpcyB0ZW1wb3JhbCBidXQgc3BlY2lmaWVkIHNjYWxlIHR5cGUgaXMgbm90IHRpbWUgb3IgdXRjJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZXF1YWwoXG4gICAgICAgICAgc2NhbGVUeXBlKFNjYWxlVHlwZS5MSU5FQVIsICd4Jywge3R5cGU6ICd0ZW1wb3JhbCcsIHRpbWVVbml0OiAneWVhcid9LCAncG9pbnQnLCBkZWZhdWx0U2NhbGVDb25maWcpLFxuICAgICAgICAgIFNjYWxlVHlwZS5USU1FXG4gICAgICAgICk7XG5cbiAgICAgICAgYXNzZXJ0LmVxdWFsKFxuICAgICAgICAgIHNjYWxlVHlwZShTY2FsZVR5cGUuTElORUFSLCAnY29sb3InLCB7dHlwZTogJ3RlbXBvcmFsJywgdGltZVVuaXQ6ICd5ZWFyJ30sICdwb2ludCcsIGRlZmF1bHRTY2FsZUNvbmZpZyksXG4gICAgICAgICAgU2NhbGVUeXBlLlNFUVVFTlRJQUxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiB0aW1lIGlmIGRhdGEgdHlwZSBpcyB0ZW1wb3JhbCBidXQgc3BlY2lmaWVkIHNjYWxlIHR5cGUgaXMgZGlzY3JldGUnLCAoKSA9PiB7XG4gICAgICAgIGFzc2VydC5lcXVhbChcbiAgICAgICAgICBzY2FsZVR5cGUoU2NhbGVUeXBlLlBPSU5ULCAneCcsIHt0eXBlOiAndGVtcG9yYWwnLCB0aW1lVW5pdDogJ3llYXInfSwgJ3BvaW50JywgZGVmYXVsdFNjYWxlQ29uZmlnKSxcbiAgICAgICAgICBTY2FsZVR5cGUuVElNRVxuICAgICAgICApO1xuICAgICAgfSk7XG5cbiAgICAgIGl0KCdzaG91bGQgcmV0dXJuIGRlZmF1bHQgc2NhbGUgdHlwZSBpZiBkYXRhIHR5cGUgaXMgdGVtcG9yYWwgYnV0IHNwZWNpZmllZCBzY2FsZSB0eXBlIGlzIHRpbWUgb3IgdXRjIG9yIGFueSBkaXNjcmV0ZSB0eXBlJywgKCkgPT4ge1xuICAgICAgICBhc3NlcnQuZXF1YWwoXG4gICAgICAgICAgc2NhbGVUeXBlKFNjYWxlVHlwZS5MSU5FQVIsICd4Jywge3R5cGU6ICd0ZW1wb3JhbCcsIHRpbWVVbml0OiAneWVhcid9LCAncG9pbnQnLCBkZWZhdWx0U2NhbGVDb25maWcpLFxuICAgICAgICAgIFNjYWxlVHlwZS5USU1FXG4gICAgICAgICk7XG4gICAgICB9KTtcblxuICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gZGVmYXVsdCBzY2FsZSB0eXBlIGlmIGRhdGEgdHlwZSBpcyBxdWFudGF0aXZlIGJ1dCBzY2FsZSB0eXBlIGRvIG5vdCBzdXBwb3J0IHF1YW50YXRpdmUnLCAoKSA9PiB7XG4gICAgICAgIGFzc2VydC5lcXVhbChcbiAgICAgICAgICBzY2FsZVR5cGUoU2NhbGVUeXBlLlRJTUUsICdjb2xvcicsIHt0eXBlOiAncXVhbnRpdGF0aXZlJ30sICdwb2ludCcsIGRlZmF1bHRTY2FsZUNvbmZpZyksXG4gICAgICAgICAgU2NhbGVUeXBlLlNFUVVFTlRJQUxcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBkZWZhdWx0IHNjYWxlIHR5cGUgaWYgZGF0YSB0eXBlIGlzIHF1YW50YXRpdmUgYW5kIHNjYWxlIHR5cGUgc3VwcG9ydHMgcXVhbnRhdGl2ZScsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKFxuICAgICAgICAgIHNjYWxlVHlwZShTY2FsZVR5cGUuVElNRSwgJ3gnLCB7dHlwZTogJ3F1YW50aXRhdGl2ZSd9LCAncG9pbnQnLCBkZWZhdWx0U2NhbGVDb25maWcpLFxuICAgICAgICAgIFNjYWxlVHlwZS5MSU5FQVJcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBpdCgnc2hvdWxkIHJldHVybiBkZWZhdWx0IHNjYWxlIHR5cGUgaWYgZGF0YSB0eXBlIGlzIHF1YW50YXRpdmUgYW5kIHNjYWxlIHR5cGUgc3VwcG9ydHMgcXVhbnRhdGl2ZScsICgpID0+IHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKFxuICAgICAgICAgIHNjYWxlVHlwZShTY2FsZVR5cGUuVElNRSwgJ3gnLCB7dHlwZTogJ3RlbXBvcmFsJ30sICdwb2ludCcsIGRlZmF1bHRTY2FsZUNvbmZpZyksXG4gICAgICAgICAgU2NhbGVUeXBlLlRJTUVcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19