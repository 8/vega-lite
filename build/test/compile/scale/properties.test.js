/* tslint:disable:quotemark */
import { assert } from 'chai';
import { NONPOSITION_SCALE_CHANNELS } from '../../../src/channel';
import * as rules from '../../../src/compile/scale/properties';
import { AREA, BAR, LINE } from '../../../src/mark';
describe('compile/scale', function () {
    describe('nice', function () {
        it('should return nice for x and y.', function () {
            for (var _i = 0, _a = ['x', 'y']; _i < _a.length; _i++) {
                var c = _a[_i];
                assert.equal(rules.nice('linear', c, { type: 'quantitative' }), true);
            }
        });
        it('should not return nice for binned x and y.', function () {
            for (var _i = 0, _a = ['x', 'y']; _i < _a.length; _i++) {
                var c = _a[_i];
                assert.equal(rules.nice('linear', c, { type: 'quantitative', bin: true }), undefined);
            }
        });
        it('should not return nice for temporal x and y.', function () {
            for (var _i = 0, _a = ['x', 'y']; _i < _a.length; _i++) {
                var c = _a[_i];
                assert.equal(rules.nice('time', c, { type: 'temporal' }), undefined);
            }
        });
    });
    describe('padding', function () {
        it('should be pointPadding for point scale if channel is x or y and padding is not specified.', function () {
            for (var _i = 0, _a = ['x', 'y']; _i < _a.length; _i++) {
                var c = _a[_i];
                assert.equal(rules.padding(c, 'point', { pointPadding: 13 }, undefined, undefined, undefined), 13);
            }
        });
        it('should be continuousBandSize for linear x-scale of vertical bar.', function () {
            assert.equal(rules.padding('x', 'linear', {}, { field: 'date', type: 'temporal' }, { type: 'bar', orient: 'vertical' }, { continuousBandSize: 13 }), 13);
        });
        it('should be undefined for linear x-scale for binned field of vertical bar.', function () {
            assert.equal(rules.padding('x', 'linear', {}, { bin: true, field: 'date', type: 'temporal' }, { type: 'bar', orient: 'vertical' }, { continuousBandSize: 13 }), undefined);
        });
        it('should be continuousBandSize for linear y-scale of horizontal bar.', function () {
            assert.equal(rules.padding('y', 'linear', {}, { field: 'date', type: 'temporal' }, { type: 'bar', orient: 'horizontal' }, { continuousBandSize: 13 }), 13);
        });
    });
    describe('paddingInner', function () {
        it('should be undefined if padding is specified.', function () {
            assert.equal(rules.paddingInner(10, 'x', {}), undefined);
        });
        it('should be bandPaddingInner if channel is x or y and padding is not specified.', function () {
            assert.equal(rules.paddingInner(undefined, 'x', { bandPaddingInner: 15 }), 15);
            assert.equal(rules.paddingInner(undefined, 'y', { bandPaddingInner: 15 }), 15);
        });
        it('should be undefined for non-xy channels.', function () {
            for (var _i = 0, NONPOSITION_SCALE_CHANNELS_1 = NONPOSITION_SCALE_CHANNELS; _i < NONPOSITION_SCALE_CHANNELS_1.length; _i++) {
                var c = NONPOSITION_SCALE_CHANNELS_1[_i];
                assert.equal(rules.paddingInner(undefined, c, { bandPaddingInner: 15 }), undefined);
            }
        });
    });
    describe('paddingOuter', function () {
        it('should be undefined if padding is specified.', function () {
            for (var _i = 0, _a = ['point', 'band']; _i < _a.length; _i++) {
                var scaleType = _a[_i];
                assert.equal(rules.paddingOuter(10, 'x', scaleType, 0, {}), undefined);
            }
        });
        it('should be config.scale.bandPaddingOuter for band scale if channel is x or y and padding is not specified and config.scale.bandPaddingOuter.', function () {
            for (var _i = 0, _a = ['x', 'y']; _i < _a.length; _i++) {
                var c = _a[_i];
                assert.equal(rules.paddingOuter(undefined, c, 'band', 0, { bandPaddingOuter: 16 }), 16);
            }
        });
        it('should be paddingInner/2 for band scale if channel is x or y and padding is not specified and config.scale.bandPaddingOuter.', function () {
            for (var _i = 0, _a = ['x', 'y']; _i < _a.length; _i++) {
                var c = _a[_i];
                assert.equal(rules.paddingOuter(undefined, c, 'band', 10, {}), 5);
            }
        });
        it('should be undefined for non-xy channels.', function () {
            for (var _i = 0, NONPOSITION_SCALE_CHANNELS_2 = NONPOSITION_SCALE_CHANNELS; _i < NONPOSITION_SCALE_CHANNELS_2.length; _i++) {
                var c = NONPOSITION_SCALE_CHANNELS_2[_i];
                for (var _a = 0, _b = ['point', 'band']; _a < _b.length; _a++) {
                    var scaleType = _b[_a];
                    assert.equal(rules.paddingOuter(undefined, c, scaleType, 0, {}), undefined);
                }
            }
        });
    });
    describe('reverse', function () {
        it('should return true for a continuous scale with sort = "descending".', function () {
            assert.isTrue(rules.reverse('linear', 'descending'));
        });
        it('should return false for a discrete scale with sort = "descending".', function () {
            assert.isUndefined(rules.reverse('point', 'descending'));
        });
    });
    describe('zero', function () {
        it('should return true when mapping a quantitative field to x with scale.domain = "unaggregated"', function () {
            assert(rules.zero('x', { field: 'a', type: 'quantitative' }, 'unaggregated', { type: 'point' }));
        });
        it('should return true when mapping a quantitative field to size', function () {
            assert(rules.zero('size', { field: 'a', type: 'quantitative' }, undefined, { type: 'point' }));
        });
        it('should return false when mapping a ordinal field to size', function () {
            assert(!rules.zero('size', { field: 'a', type: 'ordinal' }, undefined, { type: 'point' }));
        });
        it('should return true when mapping a non-binned quantitative field to x/y of point', function () {
            for (var _i = 0, _a = ['x', 'y']; _i < _a.length; _i++) {
                var channel = _a[_i];
                assert(rules.zero(channel, { field: 'a', type: 'quantitative' }, undefined, { type: 'point' }));
            }
        });
        it('should return false when mapping a quantitative field to dimension axis of bar, line, and area', function () {
            for (var _i = 0, _a = [BAR, AREA, LINE]; _i < _a.length; _i++) {
                var mark = _a[_i];
                assert.isFalse(rules.zero('x', { field: 'a', type: 'quantitative' }, undefined, { type: mark, orient: 'vertical' }));
                assert.isFalse(rules.zero('y', { field: 'a', type: 'quantitative' }, undefined, { type: mark, orient: 'horizontal' }));
            }
        });
        it('should return false when mapping a binned quantitative field to x/y', function () {
            for (var _i = 0, _a = ['x', 'y']; _i < _a.length; _i++) {
                var channel = _a[_i];
                assert(!rules.zero(channel, { bin: true, field: 'a', type: 'quantitative' }, undefined, { type: 'point' }));
            }
        });
        it('should return false when mapping a non-binned quantitative field with custom domain to x/y', function () {
            for (var _i = 0, _a = ['x', 'y']; _i < _a.length; _i++) {
                var channel = _a[_i];
                assert(!rules.zero(channel, {
                    bin: true, field: 'a', type: 'quantitative'
                }, [3, 5], { type: 'point' }));
            }
        });
    });
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicHJvcGVydGllcy50ZXN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vdGVzdC9jb21waWxlL3NjYWxlL3Byb3BlcnRpZXMudGVzdC50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSw4QkFBOEI7QUFFOUIsT0FBTyxFQUFDLE1BQU0sRUFBQyxNQUFNLE1BQU0sQ0FBQztBQUU1QixPQUFPLEVBQVUsMEJBQTBCLEVBQUMsTUFBTSxzQkFBc0IsQ0FBQztBQUd6RSxPQUFPLEtBQUssS0FBSyxNQUFNLHVDQUF1QyxDQUFDO0FBQy9ELE9BQU8sRUFBQyxJQUFJLEVBQUUsR0FBRyxFQUFFLElBQUksRUFBQyxNQUFNLG1CQUFtQixDQUFDO0FBRWxELFFBQVEsQ0FBQyxlQUFlLEVBQUU7SUFDeEIsUUFBUSxDQUFDLE1BQU0sRUFBRTtRQUNmLEVBQUUsQ0FBQyxpQ0FBaUMsRUFBRTtZQUNwQyxLQUFnQixVQUF1QixFQUF2QixLQUFBLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBYyxFQUF2QixjQUF1QixFQUF2QixJQUF1QjtnQkFBbEMsSUFBTSxDQUFDLFNBQUE7Z0JBQ1YsTUFBTSxDQUFDLEtBQUssQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLFFBQVEsRUFBRSxDQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUUsY0FBYyxFQUFDLENBQUMsRUFBRSxJQUFJLENBQUMsQ0FBQzthQUNyRTtRQUNILENBQUMsQ0FBQyxDQUFDO1FBRUgsRUFBRSxDQUFDLDRDQUE0QyxFQUFFO1lBQy9DLEtBQWdCLFVBQXVCLEVBQXZCLEtBQUEsQ0FBQyxHQUFHLEVBQUUsR0FBRyxDQUFjLEVBQXZCLGNBQXVCLEVBQXZCLElBQXVCO2dCQUFsQyxJQUFNLENBQUMsU0FBQTtnQkFDVixNQUFNLENBQUMsS0FBSyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsUUFBUSxFQUFFLENBQUMsRUFBRSxFQUFDLElBQUksRUFBRSxjQUFjLEVBQUUsR0FBRyxFQUFFLElBQUksRUFB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QUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLGNBQWMsRUFBQyxFQUFFLFNBQVMsRUFBRSxFQUFDLElBQUksRUFBRSxPQUFPLEVBQUMsQ0FBQyxDQUFDLENBQUM7YUFDekc7UUFDSCxDQUFDLENBQUMsQ0FBQztRQUVILEVBQUUsQ0FBQyw0RkFBNEYsRUFBRTtZQUMvRixLQUFzQixVQUF1QixFQUF2QixLQUFBLENBQUMsR0FBRyxFQUFFLEdBQUcsQ0FBYyxFQUF2QixjQUF1QixFQUF2QixJQUF1QjtnQkFBeEMsSUFBTSxPQUFPLFNBQUE7Z0JBQ2hCLE1BQU0sQ0FBQyxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsT0FBTyxFQUFFO29CQUMxQixHQUFHLEVBQUUsSUFBSSxFQUFFLEtBQUssRUFBRSxHQUFHLEVBQUUsSUFBSSxFQUFFLGNBQWM7aUJBQzVDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsQ0FBQyxDQUFDLEVBQUUsRUFBQyxJQUFJLEVBQUUsT0FBTyxFQUFDLENBQUMsQ0FBQyxDQUFDO2FBQzlCO1FBQ0gsQ0FBQyxDQUFDLENBQUM7SUFDTCxDQUFDLENBQUMsQ0FBQztBQUNMLENBQUMsQ0FBQyxDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiLyogdHNsaW50OmRpc2FibGU6cXVvdGVtYXJrICovXG5cbmltcG9ydCB7YXNzZXJ0fSBmcm9tICdjaGFpJztcblxuaW1wb3J0IHtDaGFubmVsLCBOT05QT1NJVElPTl9TQ0FMRV9DSEFOTkVMU30gZnJvbSAnLi4vLi4vLi4vc3JjL2NoYW5uZWwnO1xuaW1wb3J0IHtTY2FsZVR5cGV9IGZyb20gJy4uLy4uLy4uL3NyYy9zY2FsZSc7XG5cbmltcG9ydCAqIGFzIHJ1bGVzIGZyb20gJy4uLy4uLy4uL3NyYy9jb21waWxlL3NjYWxlL3Byb3BlcnRpZXMnO1xuaW1wb3J0IHtBUkVBLCBCQVIsIExJTkV9IGZyb20gJy4uLy4uLy4uL3NyYy9tYXJrJztcblxuZGVzY3JpYmUoJ2NvbXBpbGUvc2NhbGUnLCAoKSA9PiB7XG4gIGRlc2NyaWJlKCduaWNlJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgcmV0dXJuIG5pY2UgZm9yIHggYW5kIHkuJywgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjIG9mIFsneCcsICd5J10gYXMgQ2hhbm5lbFtdKSB7XG4gICAgICAgIGFzc2VydC5lcXVhbChydWxlcy5uaWNlKCdsaW5lYXInLCBjLCB7dHlwZTogJ3F1YW50aXRhdGl2ZSd9KSwgdHJ1ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIG5vdCByZXR1cm4gbmljZSBmb3IgYmlubmVkIHggYW5kIHkuJywgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjIG9mIFsneCcsICd5J10gYXMgQ2hhbm5lbFtdKSB7XG4gICAgICAgIGFzc2VydC5lcXVhbChydWxlcy5uaWNlKCdsaW5lYXInLCBjLCB7dHlwZTogJ3F1YW50aXRhdGl2ZScsIGJpbjogdHJ1ZX0pLCB1bmRlZmluZWQpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBub3QgcmV0dXJuIG5pY2UgZm9yIHRlbXBvcmFsIHggYW5kIHkuJywgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjIG9mIFsneCcsICd5J10gYXMgQ2hhbm5lbFtdKSB7XG4gICAgICAgIGFzc2VydC5lcXVhbChydWxlcy5uaWNlKCd0aW1lJywgYywge3R5cGU6ICd0ZW1wb3JhbCd9KSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgZGVzY3JpYmUoJ3BhZGRpbmcnLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBiZSBwb2ludFBhZGRpbmcgZm9yIHBvaW50IHNjYWxlIGlmIGNoYW5uZWwgaXMgeCBvciB5IGFuZCBwYWRkaW5nIGlzIG5vdCBzcGVjaWZpZWQuJywgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjIG9mIFsneCcsICd5J10gYXMgQ2hhbm5lbFtdKSB7XG4gICAgICAgIGFzc2VydC5lcXVhbChydWxlcy5wYWRkaW5nKGMsICdwb2ludCcsIHtwb2ludFBhZGRpbmc6IDEzfSwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCksIDEzKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYmUgY29udGludW91c0JhbmRTaXplIGZvciBsaW5lYXIgeC1zY2FsZSBvZiB2ZXJ0aWNhbCBiYXIuJywgKCkgPT4ge1xuICAgICAgYXNzZXJ0LmVxdWFsKHJ1bGVzLnBhZGRpbmcoJ3gnLCAnbGluZWFyJywge30sIHtmaWVsZDogJ2RhdGUnLCB0eXBlOiAndGVtcG9yYWwnfSwge3R5cGU6ICdiYXInLCBvcmllbnQ6ICd2ZXJ0aWNhbCd9LCB7Y29udGludW91c0JhbmRTaXplOiAxM30pLCAxMyk7XG4gICAgfSk7XG5cblxuICAgIGl0KCdzaG91bGQgYmUgdW5kZWZpbmVkIGZvciBsaW5lYXIgeC1zY2FsZSBmb3IgYmlubmVkIGZpZWxkIG9mIHZlcnRpY2FsIGJhci4nLCAoKSA9PiB7XG4gICAgICBhc3NlcnQuZXF1YWwocnVsZXMucGFkZGluZygneCcsICdsaW5lYXInLCB7fSwge2JpbjogdHJ1ZSwgZmllbGQ6ICdkYXRlJywgdHlwZTogJ3RlbXBvcmFsJ30sIHt0eXBlOiAnYmFyJywgb3JpZW50OiAndmVydGljYWwnfSwge2NvbnRpbnVvdXNCYW5kU2l6ZTogMTN9KSwgdW5kZWZpbmVkKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYmUgY29udGludW91c0JhbmRTaXplIGZvciBsaW5lYXIgeS1zY2FsZSBvZiBob3Jpem9udGFsIGJhci4nLCAoKSA9PiB7XG4gICAgICBhc3NlcnQuZXF1YWwocnVsZXMucGFkZGluZygneScsICdsaW5lYXInLCB7fSwge2ZpZWxkOiAnZGF0ZScsIHR5cGU6ICd0ZW1wb3JhbCd9LCB7dHlwZTogJ2JhcicsIG9yaWVudDogJ2hvcml6b250YWwnfSwge2NvbnRpbnVvdXNCYW5kU2l6ZTogMTN9KSwgMTMpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncGFkZGluZ0lubmVyJywgKCkgPT4ge1xuICAgIGl0KCdzaG91bGQgYmUgdW5kZWZpbmVkIGlmIHBhZGRpbmcgaXMgc3BlY2lmaWVkLicsICgpID0+IHtcbiAgICAgIGFzc2VydC5lcXVhbChydWxlcy5wYWRkaW5nSW5uZXIoMTAsICd4Jywge30pLCB1bmRlZmluZWQpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCBiZSBiYW5kUGFkZGluZ0lubmVyIGlmIGNoYW5uZWwgaXMgeCBvciB5IGFuZCBwYWRkaW5nIGlzIG5vdCBzcGVjaWZpZWQuJywgKCkgPT4ge1xuICAgICAgYXNzZXJ0LmVxdWFsKHJ1bGVzLnBhZGRpbmdJbm5lcih1bmRlZmluZWQsICd4Jywge2JhbmRQYWRkaW5nSW5uZXI6IDE1fSksIDE1KTtcbiAgICAgIGFzc2VydC5lcXVhbChydWxlcy5wYWRkaW5nSW5uZXIodW5kZWZpbmVkLCAneScsIHtiYW5kUGFkZGluZ0lubmVyOiAxNX0pLCAxNSk7XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGJlIHVuZGVmaW5lZCBmb3Igbm9uLXh5IGNoYW5uZWxzLicsICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgYyBvZiBOT05QT1NJVElPTl9TQ0FMRV9DSEFOTkVMUykge1xuICAgICAgICBhc3NlcnQuZXF1YWwocnVsZXMucGFkZGluZ0lubmVyKHVuZGVmaW5lZCwgYywge2JhbmRQYWRkaW5nSW5uZXI6IDE1fSksIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0pO1xuXG4gIGRlc2NyaWJlKCdwYWRkaW5nT3V0ZXInLCAoKSA9PiB7XG4gICAgaXQoJ3Nob3VsZCBiZSB1bmRlZmluZWQgaWYgcGFkZGluZyBpcyBzcGVjaWZpZWQuJywgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBzY2FsZVR5cGUgb2YgWydwb2ludCcsICdiYW5kJ10gYXMgU2NhbGVUeXBlW10pIHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHJ1bGVzLnBhZGRpbmdPdXRlcigxMCwgJ3gnLCBzY2FsZVR5cGUsIDAsIHt9KSwgdW5kZWZpbmVkKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgYmUgY29uZmlnLnNjYWxlLmJhbmRQYWRkaW5nT3V0ZXIgZm9yIGJhbmQgc2NhbGUgaWYgY2hhbm5lbCBpcyB4IG9yIHkgYW5kIHBhZGRpbmcgaXMgbm90IHNwZWNpZmllZCBhbmQgY29uZmlnLnNjYWxlLmJhbmRQYWRkaW5nT3V0ZXIuJywgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjIG9mIFsneCcsICd5J10gYXMgQ2hhbm5lbFtdKSB7XG4gICAgICAgIGFzc2VydC5lcXVhbChydWxlcy5wYWRkaW5nT3V0ZXIodW5kZWZpbmVkLCBjLCAnYmFuZCcsIDAsIHtiYW5kUGFkZGluZ091dGVyOiAxNn0pLCAxNik7XG4gICAgICB9XG4gICAgfSk7XG4gICAgaXQoJ3Nob3VsZCBiZSBwYWRkaW5nSW5uZXIvMiBmb3IgYmFuZCBzY2FsZSBpZiBjaGFubmVsIGlzIHggb3IgeSBhbmQgcGFkZGluZyBpcyBub3Qgc3BlY2lmaWVkIGFuZCBjb25maWcuc2NhbGUuYmFuZFBhZGRpbmdPdXRlci4nLCAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGMgb2YgWyd4JywgJ3knXSBhcyBDaGFubmVsW10pIHtcbiAgICAgICAgYXNzZXJ0LmVxdWFsKHJ1bGVzLnBhZGRpbmdPdXRlcih1bmRlZmluZWQsIGMsICdiYW5kJywgMTAsIHt9KSwgNSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIGJlIHVuZGVmaW5lZCBmb3Igbm9uLXh5IGNoYW5uZWxzLicsICgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgYyBvZiBOT05QT1NJVElPTl9TQ0FMRV9DSEFOTkVMUykge1xuICAgICAgICBmb3IgKGNvbnN0IHNjYWxlVHlwZSBvZiBbJ3BvaW50JywgJ2JhbmQnXSBhcyBTY2FsZVR5cGVbXSkge1xuICAgICAgICAgIGFzc2VydC5lcXVhbChydWxlcy5wYWRkaW5nT3V0ZXIodW5kZWZpbmVkLCBjLCBzY2FsZVR5cGUsIDAsIHt9KSwgdW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgncmV2ZXJzZScsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiB0cnVlIGZvciBhIGNvbnRpbnVvdXMgc2NhbGUgd2l0aCBzb3J0ID0gXCJkZXNjZW5kaW5nXCIuJywgKCkgPT4ge1xuICAgICAgYXNzZXJ0LmlzVHJ1ZShydWxlcy5yZXZlcnNlKCdsaW5lYXInLCAnZGVzY2VuZGluZycpKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIGZvciBhIGRpc2NyZXRlIHNjYWxlIHdpdGggc29ydCA9IFwiZGVzY2VuZGluZ1wiLicsICgpID0+IHtcbiAgICAgIGFzc2VydC5pc1VuZGVmaW5lZChydWxlcy5yZXZlcnNlKCdwb2ludCcsICdkZXNjZW5kaW5nJykpO1xuICAgIH0pO1xuICB9KTtcblxuICBkZXNjcmliZSgnemVybycsICgpID0+IHtcbiAgICBpdCgnc2hvdWxkIHJldHVybiB0cnVlIHdoZW4gbWFwcGluZyBhIHF1YW50aXRhdGl2ZSBmaWVsZCB0byB4IHdpdGggc2NhbGUuZG9tYWluID0gXCJ1bmFnZ3JlZ2F0ZWRcIicsICgpID0+IHtcbiAgICAgIGFzc2VydChydWxlcy56ZXJvKCd4Jywge2ZpZWxkOiAnYScsIHR5cGU6ICdxdWFudGl0YXRpdmUnfSwgJ3VuYWdncmVnYXRlZCcsIHt0eXBlOiAncG9pbnQnfSkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIG1hcHBpbmcgYSBxdWFudGl0YXRpdmUgZmllbGQgdG8gc2l6ZScsICgpID0+IHtcbiAgICAgIGFzc2VydChydWxlcy56ZXJvKCdzaXplJywge2ZpZWxkOiAnYScsIHR5cGU6ICdxdWFudGl0YXRpdmUnfSwgdW5kZWZpbmVkLCB7dHlwZTogJ3BvaW50J30pKTtcbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gbWFwcGluZyBhIG9yZGluYWwgZmllbGQgdG8gc2l6ZScsICgpID0+IHtcbiAgICAgIGFzc2VydCghcnVsZXMuemVybygnc2l6ZScsIHtmaWVsZDogJ2EnLCB0eXBlOiAnb3JkaW5hbCd9LCB1bmRlZmluZWQsIHt0eXBlOiAncG9pbnQnfSkpO1xuICAgIH0pO1xuXG4gICAgaXQoJ3Nob3VsZCByZXR1cm4gdHJ1ZSB3aGVuIG1hcHBpbmcgYSBub24tYmlubmVkIHF1YW50aXRhdGl2ZSBmaWVsZCB0byB4L3kgb2YgcG9pbnQnLCAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGNoYW5uZWwgb2YgWyd4JywgJ3knXSBhcyBDaGFubmVsW10pIHtcbiAgICAgICAgYXNzZXJ0KHJ1bGVzLnplcm8oY2hhbm5lbCwge2ZpZWxkOiAnYScsIHR5cGU6ICdxdWFudGl0YXRpdmUnfSwgdW5kZWZpbmVkLCB7dHlwZTogJ3BvaW50J30pKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gbWFwcGluZyBhIHF1YW50aXRhdGl2ZSBmaWVsZCB0byBkaW1lbnNpb24gYXhpcyBvZiBiYXIsIGxpbmUsIGFuZCBhcmVhJywgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBtYXJrIG9mIFtCQVIsIEFSRUEsIExJTkVdKSB7XG4gICAgICAgIGFzc2VydC5pc0ZhbHNlKHJ1bGVzLnplcm8oJ3gnLCB7ZmllbGQ6ICdhJywgdHlwZTogJ3F1YW50aXRhdGl2ZSd9LCB1bmRlZmluZWQsIHt0eXBlOiBtYXJrLCBvcmllbnQ6ICd2ZXJ0aWNhbCd9KSk7XG4gICAgICAgIGFzc2VydC5pc0ZhbHNlKHJ1bGVzLnplcm8oJ3knLCB7ZmllbGQ6ICdhJywgdHlwZTogJ3F1YW50aXRhdGl2ZSd9LCB1bmRlZmluZWQsIHt0eXBlOiBtYXJrLCBvcmllbnQ6ICdob3Jpem9udGFsJ30pKTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIGl0KCdzaG91bGQgcmV0dXJuIGZhbHNlIHdoZW4gbWFwcGluZyBhIGJpbm5lZCBxdWFudGl0YXRpdmUgZmllbGQgdG8geC95JywgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjaGFubmVsIG9mIFsneCcsICd5J10gYXMgQ2hhbm5lbFtdKSB7XG4gICAgICAgIGFzc2VydCghcnVsZXMuemVybyhjaGFubmVsLCB7YmluOiB0cnVlLCBmaWVsZDogJ2EnLCB0eXBlOiAncXVhbnRpdGF0aXZlJ30sIHVuZGVmaW5lZCwge3R5cGU6ICdwb2ludCd9KSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpdCgnc2hvdWxkIHJldHVybiBmYWxzZSB3aGVuIG1hcHBpbmcgYSBub24tYmlubmVkIHF1YW50aXRhdGl2ZSBmaWVsZCB3aXRoIGN1c3RvbSBkb21haW4gdG8geC95JywgKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBjaGFubmVsIG9mIFsneCcsICd5J10gYXMgQ2hhbm5lbFtdKSB7XG4gICAgICAgIGFzc2VydCghcnVsZXMuemVybyhjaGFubmVsLCB7XG4gICAgICAgICAgYmluOiB0cnVlLCBmaWVsZDogJ2EnLCB0eXBlOiAncXVhbnRpdGF0aXZlJ1xuICAgICAgICB9LCBbMywgNV0sIHt0eXBlOiAncG9pbnQnfSkpO1xuICAgICAgfVxuICAgIH0pO1xuICB9KTtcbn0pO1xuIl19