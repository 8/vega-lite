import * as tslib_1 from "tslib";
import { MAIN, RAW } from '../../data';
import * as log from '../../log';
import { isAggregate, isBin, isCalculate, isFilter, isLookup, isStack, isTimeUnit, isWindow } from '../../transform';
import { keys } from '../../util';
import { isFacetModel, isLayerModel, isUnitModel } from '../model';
import { requiresSelectionId } from '../selection/selection';
import { AggregateNode } from './aggregate';
import { BinNode } from './bin';
import { CalculateNode } from './calculate';
import { OutputNode } from './dataflow';
import { FacetNode } from './facet';
import { FilterNode } from './filter';
import { FilterInvalidNode } from './filterinvalid';
import { ParseNode } from './formatparse';
import { GeoJSONNode } from './geojson';
import { GeoPointNode } from './geopoint';
import { IdentifierNode } from './indentifier';
import { AncestorParse } from './index';
import { LookupNode } from './lookup';
import { SourceNode } from './source';
import { StackNode } from './stack';
import { TimeUnitNode } from './timeunit';
import { WindowTransformNode } from './window';
function parseRoot(model, sources) {
    if (model.data || !model.parent) {
        // if the model defines a data source or is the root, create a source node
        var source = new SourceNode(model.data);
        var hash = source.hash();
        if (hash in sources) {
            // use a reference if we already have a source
            return sources[hash];
        }
        else {
            // otherwise add a new one
            sources[hash] = source;
            return source;
        }
    }
    else {
        // If we don't have a source defined (overriding parent's data), use the parent's facet root or main.
        return model.parent.component.data.facetRoot ? model.parent.component.data.facetRoot : model.parent.component.data.main;
    }
}
/**
 * Parses a transforms array into a chain of connected dataflow nodes.
 */
export function parseTransformArray(head, model, ancestorParse) {
    var lookupCounter = 0;
    model.transforms.forEach(function (t) {
        if (isCalculate(t)) {
            head = new CalculateNode(head, t);
            ancestorParse.set(t.as, 'derived', false);
        }
        else if (isFilter(t)) {
            head = ParseNode.makeImplicitFromFilterTransform(head, t, ancestorParse) || head;
            head = new FilterNode(head, model, t.filter);
        }
        else if (isBin(t)) {
            head = BinNode.makeFromTransform(head, t, model);
            ancestorParse.set(t.as, 'number', false);
        }
        else if (isTimeUnit(t)) {
            head = TimeUnitNode.makeFromTransform(head, t);
            ancestorParse.set(t.as, 'date', false);
        }
        else if (isAggregate(t)) {
            var agg = head = AggregateNode.makeFromTransform(head, t);
            if (requiresSelectionId(model)) {
                head = new IdentifierNode(head);
            }
            for (var _i = 0, _a = keys(agg.producedFields()); _i < _a.length; _i++) {
                var field = _a[_i];
                ancestorParse.set(field, 'derived', false);
            }
        }
        else if (isLookup(t)) {
            var lookup = head = LookupNode.make(head, model, t, lookupCounter++);
            for (var _b = 0, _c = keys(lookup.producedFields()); _b < _c.length; _b++) {
                var field = _c[_b];
                ancestorParse.set(field, 'derived', false);
            }
        }
        else if (isWindow(t)) {
            var window_1 = head = new WindowTransformNode(head, t);
            for (var _d = 0, _e = keys(window_1.producedFields()); _d < _e.length; _d++) {
                var field = _e[_d];
                ancestorParse.set(field, 'derived', false);
            }
        }
        else if (isStack(t)) {
            var stack = head = StackNode.makeFromTransform(head, t);
            for (var _f = 0, _g = keys(stack.producedFields()); _f < _g.length; _f++) {
                var field = _g[_f];
                ancestorParse.set(field, 'derived', false);
            }
        }
        else {
            log.warn(log.message.invalidTransformIgnored(t));
            return;
        }
    });
    return head;
}
/*
Description of the dataflow (http://asciiflow.com/):
     +--------+
     | Source |
     +---+----+
         |
         v
     FormatParse
     (explicit)
         |
         v
     Transforms
(Filter, Calculate, Binning, TimeUnit, Aggregate, Window, ...)
         |
         v
     FormatParse
     (implicit)
         |
         v
 Binning (in `encoding`)
         |
         v
 Timeunit (in `encoding`)
         |
         v
Formula From Sort Array
         |
         v
      +--+--+
      | Raw |
      +-----+
         |
         v
  Aggregate (in `encoding`)
         |
         v
  Stack (in `encoding`)
         |
         v
  Invalid Filter
         |
         v
   +----------+
   |   Main   |
   +----------+
         |
         v
     +-------+
     | Facet |----> "column", "column-layout", and "row"
     +-------+
         |
         v
  ...Child data...
*/
export function parseData(model) {
    var head = parseRoot(model, model.component.data.sources);
    var _a = model.component.data, outputNodes = _a.outputNodes, outputNodeRefCounts = _a.outputNodeRefCounts;
    var ancestorParse = model.parent ? model.parent.component.data.ancestorParse.clone() : new AncestorParse();
    // format.parse: null means disable parsing
    if (model.data && model.data.format && model.data.format.parse === null) {
        ancestorParse.parseNothing = true;
    }
    head = ParseNode.makeExplicit(head, model, ancestorParse) || head;
    // Default discrete selections require an identifier transform to
    // uniquely identify data points as the _id field is volatile. Add
    // this transform at the head of our pipeline such that the identifier
    // field is available for all subsequent datasets. Additional identifier
    // transforms will be necessary when new tuples are constructed
    // (e.g., post-aggregation).
    if (requiresSelectionId(model) && (isUnitModel(model) || isLayerModel(model))) {
        head = new IdentifierNode(head);
    }
    // HACK: This is equivalent for merging bin extent for union scale.
    // FIXME(https://github.com/vega/vega-lite/issues/2270): Correctly merge extent / bin node for shared bin scale
    var parentIsLayer = model.parent && isLayerModel(model.parent);
    if (isUnitModel(model) || isFacetModel(model)) {
        if (parentIsLayer) {
            head = BinNode.makeFromEncoding(head, model) || head;
        }
    }
    if (model.transforms.length > 0) {
        head = parseTransformArray(head, model, ancestorParse);
    }
    head = ParseNode.makeImplicitFromEncoding(head, model, ancestorParse) || head;
    if (isUnitModel(model)) {
        head = GeoJSONNode.parseAll(head, model);
        head = GeoPointNode.parseAll(head, model);
    }
    if (isUnitModel(model) || isFacetModel(model)) {
        if (!parentIsLayer) {
            head = BinNode.makeFromEncoding(head, model) || head;
        }
        head = TimeUnitNode.makeFromEncoding(head, model) || head;
        head = CalculateNode.parseAllForSortIndex(head, model);
    }
    // add an output node pre aggregation
    var rawName = model.getName(RAW);
    var raw = new OutputNode(head, rawName, RAW, outputNodeRefCounts);
    outputNodes[rawName] = raw;
    head = raw;
    if (isUnitModel(model)) {
        var agg = AggregateNode.makeFromEncoding(head, model);
        if (agg) {
            head = agg;
            if (requiresSelectionId(model)) {
                head = new IdentifierNode(head);
            }
        }
        head = StackNode.makeFromEncoding(head, model) || head;
    }
    if (isUnitModel(model)) {
        head = FilterInvalidNode.make(head, model) || head;
    }
    // output node for marks
    var mainName = model.getName(MAIN);
    var main = new OutputNode(head, mainName, MAIN, outputNodeRefCounts);
    outputNodes[mainName] = main;
    head = main;
    // add facet marker
    var facetRoot = null;
    if (isFacetModel(model)) {
        var facetName = model.getName('facet');
        facetRoot = new FacetNode(head, model, facetName, main.getSource());
        outputNodes[facetName] = facetRoot;
        head = facetRoot;
    }
    return tslib_1.__assign({}, model.component.data, { outputNodes: outputNodes,
        outputNodeRefCounts: outputNodeRefCounts,
        raw: raw,
        main: main,
        facetRoot: facetRoot,
        ancestorParse: ancestorParse });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcGlsZS9kYXRhL3BhcnNlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsSUFBSSxFQUFFLEdBQUcsRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNyQyxPQUFPLEtBQUssR0FBRyxNQUFNLFdBQVcsQ0FBQztBQUNqQyxPQUFPLEVBQUMsV0FBVyxFQUFFLEtBQUssRUFBRSxXQUFXLEVBQUUsUUFBUSxFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUUsVUFBVSxFQUFFLFFBQVEsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ25ILE9BQU8sRUFBTyxJQUFJLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDdEMsT0FBTyxFQUFDLFlBQVksRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFRLE1BQU0sVUFBVSxDQUFDO0FBQ3hFLE9BQU8sRUFBQyxtQkFBbUIsRUFBQyxNQUFNLHdCQUF3QixDQUFDO0FBQzNELE9BQU8sRUFBQyxhQUFhLEVBQUMsTUFBTSxhQUFhLENBQUM7QUFDMUMsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLE9BQU8sQ0FBQztBQUM5QixPQUFPLEVBQUMsYUFBYSxFQUFDLE1BQU0sYUFBYSxDQUFDO0FBQzFDLE9BQU8sRUFBZSxVQUFVLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDcEQsT0FBTyxFQUFDLFNBQVMsRUFBQyxNQUFNLFNBQVMsQ0FBQztBQUNsQyxPQUFPLEVBQUMsVUFBVSxFQUFDLE1BQU0sVUFBVSxDQUFDO0FBQ3BDLE9BQU8sRUFBQyxpQkFBaUIsRUFBQyxNQUFNLGlCQUFpQixDQUFDO0FBQ2xELE9BQU8sRUFBQyxTQUFTLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFDeEMsT0FBTyxFQUFDLFdBQVcsRUFBQyxNQUFNLFdBQVcsQ0FBQztBQUN0QyxPQUFPLEVBQUMsWUFBWSxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBQ3hDLE9BQU8sRUFBQyxj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bSAnLi4vLi4vZGF0YSc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnLi4vLi4vbG9nJztcbmltcG9ydCB7aXNBZ2dyZWdhdGUsIGlzQmluLCBpc0NhbGN1bGF0ZSwgaXNGaWx0ZXIsIGlzTG9va3VwLCBpc1N0YWNrLCBpc1RpbWVVbml0LCBpc1dpbmRvd30gZnJvbSAnLi4vLi4vdHJhbnNmb3JtJztcbmltcG9ydCB7RGljdCwga2V5c30gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge2lzRmFjZXRNb2RlbCwgaXNMYXllck1vZGVsLCBpc1VuaXRNb2RlbCwgTW9kZWx9IGZyb20gJy4uL21vZGVsJztcbmltcG9ydCB7cmVxdWlyZXNTZWxlY3Rpb25JZH0gZnJvbSAnLi4vc2VsZWN0aW9uL3NlbGVjdGlvbic7XG5pbXBvcnQge0FnZ3JlZ2F0ZU5vZGV9IGZyb20gJy4vYWdncmVnYXRlJztcbmltcG9ydCB7QmluTm9kZX0gZnJvbSAnLi9iaW4nO1xuaW1wb3J0IHtDYWxjdWxhdGVOb2RlfSBmcm9tICcuL2NhbGN1bGF0ZSc7XG5pbXBvcnQge0RhdGFGbG93Tm9kZSwgT3V0cHV0Tm9kZX0gZnJvbSAnLi9kYXRhZmxvdyc7XG5pbXBvcnQge0ZhY2V0Tm9kZX0gZnJvbSAnLi9mYWNldCc7XG5pbXBvcnQge0ZpbHRlck5vZGV9IGZyb20gJy4vZmlsdGVyJztcbmltcG9ydCB7RmlsdGVySW52YWxpZE5vZGV9IGZyb20gJy4vZmlsdGVyaW52YWxpZCc7XG5pbXBvcnQge1BhcnNlTm9kZX0gZnJvbSAnLi9mb3JtYXRwYXJzZSc7XG5pbXBvcnQge0dlb0pTT05Ob2RlfSBmcm9tICcuL2dlb2pzb24nO1xuaW1wb3J0IHtHZW9Qb2ludE5vZGV9IGZyb20gJy4vZ2VvcG9pbnQnO1xuaW1wb3J0IHtJZGVudGlmaWVyTm9kZX0gZnJvbSAnLi9pbmRlbnRpZmllcic7XG5pbXBvcnQge0FuY2VzdG9yUGFyc2UsIERhdGFDb21wb25lbnR9IGZyb20gJy4vaW5kZXgnO1xuaW1wb3J0IHtMb29rdXBOb2RlfSBmcm9tICcuL2xvb2t1cCc7XG5pbXBvcnQge1NvdXJjZU5vZGV9IGZyb20gJy4vc291cmNlJztcbmltcG9ydCB7U3RhY2tOb2RlfSBmcm9tICcuL3N0YWNrJztcbmltcG9ydCB7VGltZVVuaXROb2RlfSBmcm9tICcuL3RpbWV1bml0JztcbmltcG9ydCB7V2luZG93VHJhbnNmb3JtTm9kZX0gZnJvbSAnLi93aW5kb3cnO1xuXG5mdW5jdGlvbiBwYXJzZVJvb3QobW9kZWw6IE1vZGVsLCBzb3VyY2VzOiBEaWN0PFNvdXJjZU5vZGU+KTogRGF0YUZsb3dOb2RlIHtcbiAgaWYgKG1vZGVsLmRhdGEgfHwgIW1vZGVsLnBhcmVudCkge1xuICAgIC8vIGlmIHRoZSBtb2RlbCBkZWZpbmVzIGEgZGF0YSBzb3VyY2Ugb3IgaXMgdGhlIHJvb3QsIGNyZWF0ZSBhIHNvdXJjZSBub2RlXG4gICAgY29uc3Qgc291cmNlID0gbmV3IFNvdXJjZU5vZGUobW9kZWwuZGF0YSk7XG4gICAgY29uc3QgaGFzaCA9IHNvdXJjZS5oYXNoKCk7XG4gICAgaWYgKGhhc2ggaW4gc291cmNlcykge1xuICAgICAgLy8gdXNlIGEgcmVmZXJlbmNlIGlmIHdlIGFscmVhZHkgaGF2ZSBhIHNvdXJjZVxuICAgICAgcmV0dXJuIHNvdXJjZXNbaGFzaF07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIG90aGVyd2lzZSBhZGQgYSBuZXcgb25lXG4gICAgICBzb3VyY2VzW2hhc2hdID0gc291cmNlO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSWYgd2UgZG9uJ3QgaGF2ZSBhIHNvdXJjZSBkZWZpbmVkIChvdmVycmlkaW5nIHBhcmVudCdzIGRhdGEpLCB1c2UgdGhlIHBhcmVudCdzIGZhY2V0IHJvb3Qgb3IgbWFpbi5cbiAgICByZXR1cm4gbW9kZWwucGFyZW50LmNvbXBvbmVudC5kYXRhLmZhY2V0Um9vdCA/IG1vZGVsLnBhcmVudC5jb21wb25lbnQuZGF0YS5mYWNldFJvb3QgOiBtb2RlbC5wYXJlbnQuY29tcG9uZW50LmRhdGEubWFpbjtcbiAgfVxufVxuXG5cbi8qKlxuICogUGFyc2VzIGEgdHJhbnNmb3JtcyBhcnJheSBpbnRvIGEgY2hhaW4gb2YgY29ubmVjdGVkIGRhdGFmbG93IG5vZGVzLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUcmFuc2Zvcm1BcnJheShoZWFkOiBEYXRhRmxvd05vZGUsIG1vZGVsOiBNb2RlbCwgYW5jZXN0b3JQYXJzZTogQW5jZXN0b3JQYXJzZSk6IERhdGFGbG93Tm9kZSB7XG4gIGxldCBsb29rdXBDb3VudGVyID0gMDtcblxuICBtb2RlbC50cmFuc2Zvcm1zLmZvckVhY2godCA9PiB7XG4gICAgaWYgKGlzQ2FsY3VsYXRlKHQpKSB7XG4gICAgICBoZWFkID0gbmV3IENhbGN1bGF0ZU5vZGUoaGVhZCwgdCk7XG4gICAgICBhbmNlc3RvclBhcnNlLnNldCh0LmFzLCAnZGVyaXZlZCcsIGZhbHNlKTtcbiAgICB9IGVsc2UgaWYgKGlzRmlsdGVyKHQpKSB7XG4gICAgICBoZWFkID0gUGFyc2VOb2RlLm1ha2VJbXBsaWNpdEZyb21GaWx0ZXJUcmFuc2Zvcm0oaGVhZCwgdCwgYW5jZXN0b3JQYXJzZSkgfHwgaGVhZDtcblxuICAgICAgaGVhZCA9IG5ldyBGaWx0ZXJOb2RlKGhlYWQsIG1vZGVsLCB0LmZpbHRlcik7XG4gICAgfSBlbHNlIGlmIChpc0Jpbih0KSkge1xuICAgICAgaGVhZCA9IEJpbk5vZGUubWFrZUZyb21UcmFuc2Zvcm0oaGVhZCwgdCwgbW9kZWwpO1xuXG4gICAgICBhbmNlc3RvclBhcnNlLnNldCh0LmFzLCAnbnVtYmVyJywgZmFsc2UpO1xuICAgIH0gZWxzZSBpZiAoaXNUaW1lVW5pdCh0KSkge1xuICAgICAgaGVhZCA9IFRpbWVVbml0Tm9kZS5tYWtlRnJvbVRyYW5zZm9ybShoZWFkLCB0KTtcblxuICAgICAgYW5jZXN0b3JQYXJzZS5zZXQodC5hcywgJ2RhdGUnLCBmYWxzZSk7XG4gICAgfSBlbHNlIGlmIChpc0FnZ3JlZ2F0ZSh0KSkge1xuICAgICAgY29uc3QgYWdnID0gaGVhZCA9IEFnZ3JlZ2F0ZU5vZGUubWFrZUZyb21UcmFuc2Zvcm0oaGVhZCwgdCk7XG5cbiAgICAgIGlmIChyZXF1aXJlc1NlbGVjdGlvbklkKG1vZGVsKSkge1xuICAgICAgICBoZWFkID0gbmV3IElkZW50aWZpZXJOb2RlKGhlYWQpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGtleXMoYWdnLnByb2R1Y2VkRmllbGRzKCkpKSB7XG4gICAgICAgIGFuY2VzdG9yUGFyc2Uuc2V0KGZpZWxkLCAnZGVyaXZlZCcsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzTG9va3VwKHQpKSB7XG4gICAgICBjb25zdCBsb29rdXAgPSBoZWFkID0gTG9va3VwTm9kZS5tYWtlKGhlYWQsIG1vZGVsLCB0LCBsb29rdXBDb3VudGVyKyspO1xuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGtleXMobG9va3VwLnByb2R1Y2VkRmllbGRzKCkpKSB7XG4gICAgICAgIGFuY2VzdG9yUGFyc2Uuc2V0KGZpZWxkLCAnZGVyaXZlZCcsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzV2luZG93KHQpKSB7XG4gICAgICBjb25zdCB3aW5kb3cgPSBoZWFkID0gbmV3IFdpbmRvd1RyYW5zZm9ybU5vZGUoaGVhZCwgdCk7XG5cbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2Yga2V5cyh3aW5kb3cucHJvZHVjZWRGaWVsZHMoKSkpIHtcbiAgICAgICAgYW5jZXN0b3JQYXJzZS5zZXQoZmllbGQsICdkZXJpdmVkJywgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNTdGFjayh0KSkge1xuICAgICAgY29uc3Qgc3RhY2sgPSBoZWFkID0gU3RhY2tOb2RlLm1ha2VGcm9tVHJhbnNmb3JtKGhlYWQsIHQpO1xuXG4gICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGtleXMoc3RhY2sucHJvZHVjZWRGaWVsZHMoKSkpIHtcbiAgICAgICAgYW5jZXN0b3JQYXJzZS5zZXQoZmllbGQsICdkZXJpdmVkJywgZmFsc2UpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5pbnZhbGlkVHJhbnNmb3JtSWdub3JlZCh0KSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gaGVhZDtcbn1cblxuLypcbkRlc2NyaXB0aW9uIG9mIHRoZSBkYXRhZmxvdyAoaHR0cDovL2FzY2lpZmxvdy5jb20vKTpcbiAgICAgKy0tLS0tLS0tK1xuICAgICB8IFNvdXJjZSB8XG4gICAgICstLS0rLS0tLStcbiAgICAgICAgIHxcbiAgICAgICAgIHZcbiAgICAgRm9ybWF0UGFyc2VcbiAgICAgKGV4cGxpY2l0KVxuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgICBUcmFuc2Zvcm1zXG4oRmlsdGVyLCBDYWxjdWxhdGUsIEJpbm5pbmcsIFRpbWVVbml0LCBBZ2dyZWdhdGUsIFdpbmRvdywgLi4uKVxuICAgICAgICAgfFxuICAgICAgICAgdlxuICAgICBGb3JtYXRQYXJzZVxuICAgICAoaW1wbGljaXQpXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gQmlubmluZyAoaW4gYGVuY29kaW5nYClcbiAgICAgICAgIHxcbiAgICAgICAgIHZcbiBUaW1ldW5pdCAoaW4gYGVuY29kaW5nYClcbiAgICAgICAgIHxcbiAgICAgICAgIHZcbkZvcm11bGEgRnJvbSBTb3J0IEFycmF5XG4gICAgICAgICB8XG4gICAgICAgICB2XG4gICAgICArLS0rLS0rXG4gICAgICB8IFJhdyB8XG4gICAgICArLS0tLS0rXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gIEFnZ3JlZ2F0ZSAoaW4gYGVuY29kaW5nYClcbiAgICAgICAgIHxcbiAgICAgICAgIHZcbiAgU3RhY2sgKGluIGBlbmNvZGluZ2ApXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gIEludmFsaWQgRmlsdGVyXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gICArLS0tLS0tLS0tLStcbiAgIHwgICBNYWluICAgfFxuICAgKy0tLS0tLS0tLS0rXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gICAgICstLS0tLS0tK1xuICAgICB8IEZhY2V0IHwtLS0tPiBcImNvbHVtblwiLCBcImNvbHVtbi1sYXlvdXRcIiwgYW5kIFwicm93XCJcbiAgICAgKy0tLS0tLS0rXG4gICAgICAgICB8XG4gICAgICAgICB2XG4gIC4uLkNoaWxkIGRhdGEuLi5cbiovXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZURhdGEobW9kZWw6IE1vZGVsKTogRGF0YUNvbXBvbmVudCB7XG4gIGxldCBoZWFkID0gcGFyc2VSb290KG1vZGVsLCBtb2RlbC5jb21wb25lbnQuZGF0YS5zb3VyY2VzKTtcblxuICBjb25zdCB7b3V0cHV0Tm9kZXMsIG91dHB1dE5vZGVSZWZDb3VudHN9ID0gbW9kZWwuY29tcG9uZW50LmRhdGE7XG4gIGNvbnN0IGFuY2VzdG9yUGFyc2UgPSBtb2RlbC5wYXJlbnQgPyBtb2RlbC5wYXJlbnQuY29tcG9uZW50LmRhdGEuYW5jZXN0b3JQYXJzZS5jbG9uZSgpIDogbmV3IEFuY2VzdG9yUGFyc2UoKTtcblxuICAvLyBmb3JtYXQucGFyc2U6IG51bGwgbWVhbnMgZGlzYWJsZSBwYXJzaW5nXG4gIGlmIChtb2RlbC5kYXRhICYmIG1vZGVsLmRhdGEuZm9ybWF0ICYmIG1vZGVsLmRhdGEuZm9ybWF0LnBhcnNlID09PSBudWxsKSB7XG4gICAgYW5jZXN0b3JQYXJzZS5wYXJzZU5vdGhpbmcgPSB0cnVlO1xuICB9XG5cbiAgaGVhZCA9IFBhcnNlTm9kZS5tYWtlRXhwbGljaXQoaGVhZCwgbW9kZWwsIGFuY2VzdG9yUGFyc2UpIHx8IGhlYWQ7XG5cbiAgLy8gRGVmYXVsdCBkaXNjcmV0ZSBzZWxlY3Rpb25zIHJlcXVpcmUgYW4gaWRlbnRpZmllciB0cmFuc2Zvcm0gdG9cbiAgLy8gdW5pcXVlbHkgaWRlbnRpZnkgZGF0YSBwb2ludHMgYXMgdGhlIF9pZCBmaWVsZCBpcyB2b2xhdGlsZS4gQWRkXG4gIC8vIHRoaXMgdHJhbnNmb3JtIGF0IHRoZSBoZWFkIG9mIG91ciBwaXBlbGluZSBzdWNoIHRoYXQgdGhlIGlkZW50aWZpZXJcbiAgLy8gZmllbGQgaXMgYXZhaWxhYmxlIGZvciBhbGwgc3Vic2VxdWVudCBkYXRhc2V0cy4gQWRkaXRpb25hbCBpZGVudGlmaWVyXG4gIC8vIHRyYW5zZm9ybXMgd2lsbCBiZSBuZWNlc3Nhcnkgd2hlbiBuZXcgdHVwbGVzIGFyZSBjb25zdHJ1Y3RlZFxuICAvLyAoZS5nLiwgcG9zdC1hZ2dyZWdhdGlvbikuXG4gIGlmIChyZXF1aXJlc1NlbGVjdGlvbklkKG1vZGVsKSAmJiAoaXNVbml0TW9kZWwobW9kZWwpIHx8IGlzTGF5ZXJNb2RlbChtb2RlbCkpKSB7XG4gICAgaGVhZCA9IG5ldyBJZGVudGlmaWVyTm9kZShoZWFkKTtcbiAgfVxuXG4gIC8vIEhBQ0s6IFRoaXMgaXMgZXF1aXZhbGVudCBmb3IgbWVyZ2luZyBiaW4gZXh0ZW50IGZvciB1bmlvbiBzY2FsZS5cbiAgLy8gRklYTUUoaHR0cHM6Ly9naXRodWIuY29tL3ZlZ2EvdmVnYS1saXRlL2lzc3Vlcy8yMjcwKTogQ29ycmVjdGx5IG1lcmdlIGV4dGVudCAvIGJpbiBub2RlIGZvciBzaGFyZWQgYmluIHNjYWxlXG4gIGNvbnN0IHBhcmVudElzTGF5ZXIgPSBtb2RlbC5wYXJlbnQgJiYgaXNMYXllck1vZGVsKG1vZGVsLnBhcmVudCk7XG4gIGlmIChpc1VuaXRNb2RlbChtb2RlbCkgfHwgaXNGYWNldE1vZGVsKG1vZGVsKSkge1xuICAgIGlmIChwYXJlbnRJc0xheWVyKSB7XG4gICAgICBoZWFkID0gQmluTm9kZS5tYWtlRnJvbUVuY29kaW5nKGhlYWQsIG1vZGVsKSB8fCBoZWFkO1xuICAgIH1cbiAgfVxuXG4gIGlmIChtb2RlbC50cmFuc2Zvcm1zLmxlbmd0aCA+IDApIHtcbiAgICBoZWFkID0gcGFyc2VUcmFuc2Zvcm1BcnJheShoZWFkLCBtb2RlbCwgYW5jZXN0b3JQYXJzZSk7XG4gIH1cblxuICBoZWFkID0gUGFyc2VOb2RlLm1ha2VJbXBsaWNpdEZyb21FbmNvZGluZyhoZWFkLCBtb2RlbCwgYW5jZXN0b3JQYXJzZSkgfHwgaGVhZDtcblxuICBpZiAoaXNVbml0TW9kZWwobW9kZWwpKSB7XG4gICAgaGVhZCA9IEdlb0pTT05Ob2RlLnBhcnNlQWxsKGhlYWQsIG1vZGVsKTtcbiAgICBoZWFkID0gR2VvUG9pbnROb2RlLnBhcnNlQWxsKGhlYWQsIG1vZGVsKTtcbiAgfVxuXG4gIGlmIChpc1VuaXRNb2RlbChtb2RlbCkgfHwgaXNGYWNldE1vZGVsKG1vZGVsKSkge1xuXG4gICAgaWYgKCFwYXJlbnRJc0xheWVyKSB7XG4gICAgICBoZWFkID0gQmluTm9kZS5tYWtlRnJvbUVuY29kaW5nKGhlYWQsIG1vZGVsKSB8fCBoZWFkO1xuICAgIH1cblxuICAgIGhlYWQgPSBUaW1lVW5pdE5vZGUubWFrZUZyb21FbmNvZGluZyhoZWFkLCBtb2RlbCkgfHwgaGVhZDtcbiAgICBoZWFkID0gQ2FsY3VsYXRlTm9kZS5wYXJzZUFsbEZvclNvcnRJbmRleChoZWFkLCBtb2RlbCk7XG4gIH1cblxuICAvLyBhZGQgYW4gb3V0cHV0IG5vZGUgcHJlIGFnZ3JlZ2F0aW9uXG4gIGNvbnN0IHJhd05hbWUgPSBtb2RlbC5nZXROYW1lKFJBVyk7XG4gIGNvbnN0IHJhdyA9IG5ldyBPdXRwdXROb2RlKGhlYWQsIHJhd05hbWUsIFJBVywgb3V0cHV0Tm9kZVJlZkNvdW50cyk7XG4gIG91dHB1dE5vZGVzW3Jhd05hbWVdID0gcmF3O1xuICBoZWFkID0gcmF3O1xuXG4gIGlmIChpc1VuaXRNb2RlbChtb2RlbCkpIHtcbiAgICBjb25zdCBhZ2cgPSBBZ2dyZWdhdGVOb2RlLm1ha2VGcm9tRW5jb2RpbmcoaGVhZCwgbW9kZWwpO1xuICAgIGlmIChhZ2cpIHtcbiAgICAgIGhlYWQgPSBhZ2c7XG5cbiAgICAgIGlmIChyZXF1aXJlc1NlbGVjdGlvbklkKG1vZGVsKSkge1xuICAgICAgICBoZWFkID0gbmV3IElkZW50aWZpZXJOb2RlKGhlYWQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGhlYWQgPSBTdGFja05vZGUubWFrZUZyb21FbmNvZGluZyhoZWFkLCBtb2RlbCkgfHwgaGVhZDtcbiAgfVxuXG4gIGlmIChpc1VuaXRNb2RlbChtb2RlbCkpIHtcbiAgICBoZWFkID0gRmlsdGVySW52YWxpZE5vZGUubWFrZShoZWFkLCBtb2RlbCkgfHwgaGVhZDtcbiAgfVxuXG4gIC8vIG91dHB1dCBub2RlIGZvciBtYXJrc1xuICBjb25zdCBtYWluTmFtZSA9IG1vZGVsLmdldE5hbWUoTUFJTik7XG4gIGNvbnN0IG1haW4gPSBuZXcgT3V0cHV0Tm9kZShoZWFkLCBtYWluTmFtZSwgTUFJTiwgb3V0cHV0Tm9kZVJlZkNvdW50cyk7XG4gIG91dHB1dE5vZGVzW21haW5OYW1lXSA9IG1haW47XG4gIGhlYWQgPSBtYWluO1xuXG4gIC8vIGFkZCBmYWNldCBtYXJrZXJcbiAgbGV0IGZhY2V0Um9vdCA9IG51bGw7XG4gIGlmIChpc0ZhY2V0TW9kZWwobW9kZWwpKSB7XG4gICAgY29uc3QgZmFjZXROYW1lID0gbW9kZWwuZ2V0TmFtZSgnZmFjZXQnKTtcbiAgICBmYWNldFJvb3QgPSBuZXcgRmFjZXROb2RlKGhlYWQsIG1vZGVsLCBmYWNldE5hbWUsIG1haW4uZ2V0U291cmNlKCkpO1xuICAgIG91dHB1dE5vZGVzW2ZhY2V0TmFtZV0gPSBmYWNldFJvb3Q7XG4gICAgaGVhZCA9IGZhY2V0Um9vdDtcbiAgfVxuXG4gIHJldHVybiB7XG4gICAgLi4ubW9kZWwuY29tcG9uZW50LmRhdGEsXG4gICAgb3V0cHV0Tm9kZXMsXG4gICAgb3V0cHV0Tm9kZVJlZkNvdW50cyxcbiAgICByYXcsXG4gICAgbWFpbixcbiAgICBmYWNldFJvb3QsXG4gICAgYW5jZXN0b3JQYXJzZVxuICB9O1xufVxuIl19