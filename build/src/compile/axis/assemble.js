import * as tslib_1 from "tslib";
import { isArray } from 'vega-util';
import { AXIS_PARTS, AXIS_PROPERTY_TYPE } from '../../axis';
import { title as fieldDefTitle } from '../../fielddef';
import { keys } from '../../util';
function assembleTitle(title, config) {
    if (isArray(title)) {
        return title.map(function (fieldDef) { return fieldDefTitle(fieldDef, config); }).join(', ');
    }
    return title;
}
export function assembleAxis(axisCmpt, kind, config, opt) {
    if (opt === void 0) { opt = { header: false }; }
    var _a = axisCmpt.combine(), orient = _a.orient, scale = _a.scale, title = _a.title, zindex = _a.zindex, axis = tslib_1.__rest(_a, ["orient", "scale", "title", "zindex"]);
    // Remove properties that are not valid for this kind of axis
    keys(axis).forEach(function (key) {
        var propType = AXIS_PROPERTY_TYPE[key];
        if (propType && propType !== kind && propType !== 'both') {
            delete axis[key];
        }
    });
    if (kind === 'grid') {
        if (!axis.grid) {
            return undefined;
        }
        // Remove unnecessary encode block
        if (axis.encode) {
            // Only need to keep encode block for grid
            var grid = axis.encode.grid;
            axis.encode = tslib_1.__assign({}, (grid ? { grid: grid } : {}));
            if (keys(axis.encode).length === 0) {
                delete axis.encode;
            }
        }
        return tslib_1.__assign({ scale: scale,
            orient: orient }, axis, { domain: false, labels: false, 
            // Always set min/maxExtent to 0 to ensure that `config.axis*.minExtent` and `config.axis*.maxExtent`
            // would not affect gridAxis
            maxExtent: 0, minExtent: 0, ticks: false, zindex: zindex !== undefined ? zindex : 0 // put grid behind marks by default
         });
    }
    else { // kind === 'main'
        if (!opt.header && axisCmpt.mainExtracted) {
            // if mainExtracted has been extracted to a separate facet
            return undefined;
        }
        // Remove unnecessary encode block
        if (axis.encode) {
            for (var _i = 0, AXIS_PARTS_1 = AXIS_PARTS; _i < AXIS_PARTS_1.length; _i++) {
                var part = AXIS_PARTS_1[_i];
                if (!axisCmpt.hasAxisPart(part)) {
                    delete axis.encode[part];
                }
            }
            if (keys(axis.encode).length === 0) {
                delete axis.encode;
            }
        }
        var titleString = assembleTitle(title, config);
        return tslib_1.__assign({ scale: scale,
            orient: orient }, (titleString ? { title: titleString } : {}), axis, { zindex: zindex !== undefined ? zindex : 1 // put axis line above marks by default
         });
    }
}
export function assembleAxes(axisComponents, config) {
    var _a = axisComponents.x, x = _a === void 0 ? [] : _a, _b = axisComponents.y, y = _b === void 0 ? [] : _b;
    return x.map(function (a) { return assembleAxis(a, 'main', config); }).concat(x.map(function (a) { return assembleAxis(a, 'grid', config); }), y.map(function (a) { return assembleAxis(a, 'main', config); }), y.map(function (a) { return assembleAxis(a, 'grid', config); })).filter(function (a) { return a; }); // filter undefined
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYXNzZW1ibGUuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcGlsZS9heGlzL2Fzc2VtYmxlLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQSxPQUFPLEVBQUMsT0FBTyxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBRWxDLE9BQU8sRUFBQyxVQUFVLEVBQUUsa0JBQWtCLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFFMUQsT0FBTyxFQUFlLEtBQUssSUFBSSxhQUFhLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNwRSxPQUFPLEVBQUMsSUFBSSxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBSWhDLHVCQUF1QixLQUFzQyxFQUFFLE1BQWM7SUFDM0UsSUFBSSxPQUFPLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDbEIsT0FBTyxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQUEsUUFBUSxJQUFJLE9BQUEsYUFBYSxDQUFDLFFBQVEsRUFBRSxNQUFNLENBQUMsRUFBL0IsQ0FBK0IsQ0FBQyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQztLQUMxRTtJQUNELE9BQU8sS0FBSyxDQUFDO0FBQ2YsQ0FBQztBQUVELE1BQU0sdUJBQ0osUUFBdUIsRUFDdkIsSUFBcUIsRUFDckIsTUFBYyxFQUNkLEdBRW1CO0lBRm5CLG9CQUFBLEVBQUEsUUFFSyxNQUFNLEVBQUUsS0FBSyxFQUFDO0lBRW5CLElBQU0sdUJBQTRELEVBQTNELGtCQUFNLEVBQUUsZ0JBQUssRUFBRSxnQkFBSyxFQUFFLGtCQUFNLEVBQUUsaUVBQTZCLENBQUM7SUFFbkUsNkRBQTZEO0lBQzdELElBQUksQ0FBQyxJQUFJLENBQUMsQ0FBQyxPQUFPLENBQUMsVUFBQyxHQUFHO1FBQ3JCLElBQU0sUUFBUSxHQUFHLGtCQUFrQixDQUFDLEdBQUcsQ0FBQyxDQUFDO1FBQ3pDLElBQUksUUFBUSxJQUFJLFFBQVEsS0FBSyxJQUFJLElBQUksUUFBUSxLQUFLLE1BQU0sRUFBRTtZQUN4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LEVBQUUsTUFBTSxFQUFFLE1BQU0sQ0FBQyxFQUEvQixDQUErQixDQUFDLEVBQzNDLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxZQUFZLENBQUMsQ0FBQyxFQUFFLE1BQU0sRUFBRSxNQUFNLENBQUMsRUFBL0IsQ0FBK0IsQ0FBQyxFQUM5QyxNQUFNLENBQUMsVUFBQSxDQUFDLElBQUksT0FBQSxDQUFDLEVBQUQsQ0FBQyxDQUFDLENBQUMsQ0FBQyxtQkFBbUI7QUFDdkMsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNBcnJheX0gZnJvbSAndmVnYS11dGlsJztcblxuaW1wb3J0IHtBWElTX1BBUlRTLCBBWElTX1BST1BFUlRZX1RZUEV9IGZyb20gJy4uLy4uL2F4aXMnO1xuaW1wb3J0IHtDb25maWd9IGZyb20gJy4uLy4uL2NvbmZpZyc7XG5pbXBvcnQge0ZpZWxkRGVmQmFzZSwgdGl0bGUgYXMgZmllbGREZWZUaXRsZX0gZnJvbSAnLi4vLi4vZmllbGRkZWYnO1xuaW1wb3J0IHtrZXlzfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7VmdBeGlzfSBmcm9tICcuLi8uLi92ZWdhLnNjaGVtYSc7XG5pbXBvcnQge0F4aXNDb21wb25lbnQsIEF4aXNDb21wb25lbnRJbmRleH0gZnJvbSAnLi9jb21wb25lbnQnO1xuXG5mdW5jdGlvbiBhc3NlbWJsZVRpdGxlKHRpdGxlOiBzdHJpbmcgfCBGaWVsZERlZkJhc2U8c3RyaW5nPltdLCBjb25maWc6IENvbmZpZykge1xuICBpZiAoaXNBcnJheSh0aXRsZSkpIHtcbiAgICByZXR1cm4gdGl0bGUubWFwKGZpZWxkRGVmID0+IGZpZWxkRGVmVGl0bGUoZmllbGREZWYsIGNvbmZpZykpLmpvaW4oJywgJyk7XG4gIH1cbiAgcmV0dXJuIHRpdGxlO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZW1ibGVBeGlzKFxuICBheGlzQ21wdDogQXhpc0NvbXBvbmVudCxcbiAga2luZDogJ21haW4nIHwgJ2dyaWQnLFxuICBjb25maWc6IENvbmZpZyxcbiAgb3B0OiB7XG4gICAgaGVhZGVyOiBib29sZWFuIC8vIHdoZXRoZXIgdGhpcyBpcyBjYWxsZWQgdmlhIGEgaGVhZGVyXG4gIH0gPSB7aGVhZGVyOiBmYWxzZX1cbik6IFZnQXhpcyB7XG4gIGNvbnN0IHtvcmllbnQsIHNjYWxlLCB0aXRsZSwgemluZGV4LCAuLi5heGlzfSA9IGF4aXNDbXB0LmNvbWJpbmUoKTtcblxuICAvLyBSZW1vdmUgcHJvcGVydGllcyB0aGF0IGFyZSBub3QgdmFsaWQgZm9yIHRoaXMga2luZCBvZiBheGlzXG4gIGtleXMoYXhpcykuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgY29uc3QgcHJvcFR5cGUgPSBBWElTX1BST1BFUlRZX1RZUEVba2V5XTtcbiAgICBpZiAocHJvcFR5cGUgJiYgcHJvcFR5cGUgIT09IGtpbmQgJiYgcHJvcFR5cGUgIT09ICdib3RoJykge1xuICAgICAgZGVsZXRlIGF4aXNba2V5XTtcbiAgICB9XG4gIH0pO1xuXG4gIGlmIChraW5kID09PSAnZ3JpZCcpIHtcbiAgICBpZiAoIWF4aXMuZ3JpZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgdW5uZWNlc3NhcnkgZW5jb2RlIGJsb2NrXG4gICAgaWYgKGF4aXMuZW5jb2RlKSB7XG4gICAgICAvLyBPbmx5IG5lZWQgdG8ga2VlcCBlbmNvZGUgYmxvY2sgZm9yIGdyaWRcbiAgICAgIGNvbnN0IHtncmlkfSA9IGF4aXMuZW5jb2RlO1xuICAgICAgYXhpcy5lbmNvZGUgPSB7XG4gICAgICAgIC4uLihncmlkID8ge2dyaWR9IDoge30pXG4gICAgICB9O1xuXG4gICAgICBpZiAoa2V5cyhheGlzLmVuY29kZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSBheGlzLmVuY29kZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgc2NhbGUsXG4gICAgICBvcmllbnQsXG4gICAgICAuLi5heGlzLFxuICAgICAgZG9tYWluOiBmYWxzZSxcbiAgICAgIGxhYmVsczogZmFsc2UsXG5cbiAgICAgIC8vIEFsd2F5cyBzZXQgbWluL21heEV4dGVudCB0byAwIHRvIGVuc3VyZSB0aGF0IGBjb25maWcuYXhpcyoubWluRXh0ZW50YCBhbmQgYGNvbmZpZy5heGlzKi5tYXhFeHRlbnRgXG4gICAgICAvLyB3b3VsZCBub3QgYWZmZWN0IGdyaWRBeGlzXG4gICAgICBtYXhFeHRlbnQ6IDAsXG4gICAgICBtaW5FeHRlbnQ6IDAsXG4gICAgICB0aWNrczogZmFsc2UsXG4gICAgICB6aW5kZXg6IHppbmRleCAhPT0gdW5kZWZpbmVkID8gemluZGV4IDogMCAvLyBwdXQgZ3JpZCBiZWhpbmQgbWFya3MgYnkgZGVmYXVsdFxuICAgIH07XG4gIH0gZWxzZSB7IC8vIGtpbmQgPT09ICdtYWluJ1xuXG4gICAgaWYgKCFvcHQuaGVhZGVyICYmIGF4aXNDbXB0Lm1haW5FeHRyYWN0ZWQpIHtcbiAgICAgIC8vIGlmIG1haW5FeHRyYWN0ZWQgaGFzIGJlZW4gZXh0cmFjdGVkIHRvIGEgc2VwYXJhdGUgZmFjZXRcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLy8gUmVtb3ZlIHVubmVjZXNzYXJ5IGVuY29kZSBibG9ja1xuICAgIGlmIChheGlzLmVuY29kZSkge1xuICAgICAgZm9yIChjb25zdCBwYXJ0IG9mIEFYSVNfUEFSVFMpIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgICFheGlzQ21wdC5oYXNBeGlzUGFydChwYXJ0KVxuICAgICAgICApIHtcbiAgICAgICAgICBkZWxldGUgYXhpcy5lbmNvZGVbcGFydF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChrZXlzKGF4aXMuZW5jb2RlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgZGVsZXRlIGF4aXMuZW5jb2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGNvbnN0IHRpdGxlU3RyaW5nID0gYXNzZW1ibGVUaXRsZSh0aXRsZSwgY29uZmlnKTtcblxuICAgIHJldHVybiB7XG4gICAgICBzY2FsZSxcbiAgICAgIG9yaWVudCxcbiAgICAgIC4uLih0aXRsZVN0cmluZyA/IHt0aXRsZTogdGl0bGVTdHJpbmd9IDoge30pLFxuICAgICAgLi4uYXhpcyxcbiAgICAgIHppbmRleDogemluZGV4ICE9PSB1bmRlZmluZWQgPyB6aW5kZXggOiAxIC8vIHB1dCBheGlzIGxpbmUgYWJvdmUgbWFya3MgYnkgZGVmYXVsdFxuICAgIH07XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VtYmxlQXhlcyhheGlzQ29tcG9uZW50czogQXhpc0NvbXBvbmVudEluZGV4LCBjb25maWc6IENvbmZpZyk6IFZnQXhpc1tdIHtcbiAgY29uc3Qge3g9W10sIHk9W119ID0gYXhpc0NvbXBvbmVudHM7XG4gIHJldHVybiBbXG4gICAgLi4ueC5tYXAoYSA9PiBhc3NlbWJsZUF4aXMoYSwgJ21haW4nLCBjb25maWcpKSxcbiAgICAuLi54Lm1hcChhID0+IGFzc2VtYmxlQXhpcyhhLCAnZ3JpZCcsIGNvbmZpZykpLFxuICAgIC4uLnkubWFwKGEgPT4gYXNzZW1ibGVBeGlzKGEsICdtYWluJywgY29uZmlnKSksXG4gICAgLi4ueS5tYXAoYSA9PiBhc3NlbWJsZUF4aXMoYSwgJ2dyaWQnLCBjb25maWcpKVxuICBdLmZpbHRlcihhID0+IGEpOyAvLyBmaWx0ZXIgdW5kZWZpbmVkXG59XG4iXX0=