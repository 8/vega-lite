import { COLOR, FILL, OPACITY, SHAPE, SIZE, STROKE } from '../../channel';
import { isFieldDef, title as fieldDefTitle } from '../../fielddef';
import { LEGEND_PROPERTIES, VG_LEGEND_PROPERTIES } from '../../legend';
import { GEOJSON } from '../../type';
import { deleteNestedProperty, keys } from '../../util';
import { getSpecifiedOrDefaultValue, numberFormat, titleMerger } from '../common';
import { isUnitModel } from '../model';
import { parseGuideResolve } from '../resolve';
import { makeImplicit } from '../split';
import { defaultTieBreaker, mergeValuesWithExplicit } from '../split';
import { LegendComponent } from './component';
import * as encode from './encode';
import * as properties from './properties';
export function parseLegend(model) {
    if (isUnitModel(model)) {
        model.component.legends = parseUnitLegend(model);
    }
    else {
        model.component.legends = parseNonUnitLegend(model);
    }
}
function parseUnitLegend(model) {
    var encoding = model.encoding;
    return [COLOR, FILL, STROKE, SIZE, SHAPE, OPACITY].reduce(function (legendComponent, channel) {
        var def = encoding[channel];
        if (model.legend(channel) && model.getScaleComponent(channel) && !(isFieldDef(def) && (channel === SHAPE && def.type === GEOJSON))) {
            legendComponent[channel] = parseLegendForChannel(model, channel);
        }
        return legendComponent;
    }, {});
}
function getLegendDefWithScale(model, channel) {
    // For binned field with continuous scale, use a special scale so we can overrride the mark props and labels
    switch (channel) {
        case COLOR:
            var scale = model.scaleName(COLOR);
            return model.markDef.filled ? { fill: scale } : { stroke: scale };
        case FILL:
        case STROKE:
        case SIZE:
        case SHAPE:
        case OPACITY:
            return _a = {}, _a[channel] = model.scaleName(channel), _a;
    }
    var _a;
}
export function parseLegendForChannel(model, channel) {
    var fieldDef = model.fieldDef(channel);
    var legend = model.legend(channel);
    var legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));
    LEGEND_PROPERTIES.forEach(function (property) {
        var value = getProperty(property, legend, channel, model);
        if (value !== undefined) {
            var explicit = property === 'values' ?
                !!legend.values : // specified legend.values is already respected, but may get transformed.
                value === legend[property];
            if (explicit || model.config.legend[property] === undefined) {
                legendCmpt.set(property, value, explicit);
            }
        }
    });
    // 2) Add mark property definition groups
    var legendEncoding = legend.encoding || {};
    var legendEncode = ['labels', 'legend', 'title', 'symbols', 'gradient'].reduce(function (e, part) {
        var value = encode[part] ?
            // TODO: replace legendCmpt with type is sufficient
            encode[part](fieldDef, legendEncoding[part], model, channel, legendCmpt.get('type')) : // apply rule
            legendEncoding[part]; // no rule -- just default values
        if (value !== undefined && keys(value).length > 0) {
            e[part] = { update: value };
        }
        return e;
    }, {});
    if (keys(legendEncode).length > 0) {
        legendCmpt.set('encode', legendEncode, !!legend.encoding);
    }
    return legendCmpt;
}
function getProperty(property, specifiedLegend, channel, model) {
    var fieldDef = model.fieldDef(channel);
    switch (property) {
        case 'format':
            // We don't include temporal field here as we apply format in encode block
            return numberFormat(fieldDef, specifiedLegend.format, model.config);
        case 'title':
            // For falsy value, keep undefined so we use default,
            // but use null for '', null, and false to hide the title
            var specifiedTitle = fieldDef.title !== undefined ? fieldDef.title :
                specifiedLegend.title || (specifiedLegend.title === undefined ? undefined : null);
            return getSpecifiedOrDefaultValue(specifiedTitle, fieldDefTitle(fieldDef, model.config)) || undefined; // make falsy value undefined so output Vega spec is shorter
        case 'values':
            return properties.values(specifiedLegend);
        case 'type':
            return getSpecifiedOrDefaultValue(specifiedLegend.type, properties.type(fieldDef.type, channel, model.getScaleComponent(channel).get('type')));
    }
    // Otherwise, return specified property.
    return specifiedLegend[property];
}
function parseNonUnitLegend(model) {
    var _a = model.component, legends = _a.legends, resolve = _a.resolve;
    var _loop_1 = function (child) {
        parseLegend(child);
        keys(child.component.legends).forEach(function (channel) {
            resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);
            if (resolve.legend[channel] === 'shared') {
                // If the resolve says shared (and has not been overridden)
                // We will try to merge and see if there is a conflict
                legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);
                if (!legends[channel]) {
                    // If merge returns nothing, there is a conflict so we cannot make the legend shared.
                    // Thus, mark legend as independent and remove the legend component.
                    resolve.legend[channel] = 'independent';
                    delete legends[channel];
                }
            }
        });
    };
    for (var _i = 0, _b = model.children; _i < _b.length; _i++) {
        var child = _b[_i];
        _loop_1(child);
    }
    keys(legends).forEach(function (channel) {
        for (var _i = 0, _a = model.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (!child.component.legends[channel]) {
                // skip if the child does not have a particular legend
                continue;
            }
            if (resolve.legend[channel] === 'shared') {
                // After merging shared legend, make sure to remove legend from child
                delete child.component.legends[channel];
            }
        }
    });
    return legends;
}
export function mergeLegendComponent(mergedLegend, childLegend) {
    if (!mergedLegend) {
        return childLegend.clone();
    }
    var mergedOrient = mergedLegend.getWithExplicit('orient');
    var childOrient = childLegend.getWithExplicit('orient');
    if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
        // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)
        // Cannot merge due to inconsistent orient
        return undefined;
    }
    var typeMerged = false;
    var _loop_2 = function (prop) {
        var mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend', 
        // Tie breaker function
        function (v1, v2) {
            switch (prop) {
                case 'title':
                    return titleMerger(v1, v2);
                case 'type':
                    // There are only two types. If we have different types, then prefer symbol over gradient.
                    typeMerged = true;
                    return makeImplicit('symbol');
            }
            return defaultTieBreaker(v1, v2, prop, 'legend');
        });
        mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);
    };
    // Otherwise, let's merge
    for (var _i = 0, VG_LEGEND_PROPERTIES_1 = VG_LEGEND_PROPERTIES; _i < VG_LEGEND_PROPERTIES_1.length; _i++) {
        var prop = VG_LEGEND_PROPERTIES_1[_i];
        _loop_2(prop);
    }
    if (typeMerged) {
        if (((mergedLegend.implicit || {}).encode || {}).gradient) {
            deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);
        }
        if (((mergedLegend.explicit || {}).encode || {}).gradient) {
            deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);
        }
    }
    return mergedLegend;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcGlsZS9sZWdlbmQvcGFyc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLEtBQUssRUFBRSxJQUFJLEVBQTJCLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUNqRyxPQUFPLEVBQUMsVUFBVSxFQUFFLEtBQUssSUFBSSxhQUFhLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRSxPQUFPLEVBQVMsaUJBQWlCLEVBQUUsb0JBQW9CLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDN0UsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNuQyxPQUFPLEVBQUMsb0JBQW9CLEVBQUUsSUFBSSxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBRXRELE9BQU8sRUFBQywwQkFBMEIsRUFBRSxZQUFZLEVBQUUsV0FBVyxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBQ2hGLE9BQU8sRUFBQyxXQUFXLEVBQVEsTUFBTSxVQUFVLENBQUM7QUFDNUMsT0FBTyxFQUFDLGlCQUFpQixFQUFDLE1BQU0sWUFBWSxDQUFDO0FBQzdDLE9BQU8sRUFBVyxZQUFZLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFDaEQsT0FBTyxFQUFDLGlCQUFpQixFQUFFLHVCQUF1QixFQUFDLE1BQU0sVUFBVSxDQUFDO0FBRXBFLE9BQU8sRUFBQyxlQUFlLEVBQXVCLE1BQU0sYUFBYSxDQUFDO0FBQ2xFLE9BQU8sS0FBSyxNQUFNLE1BQU0sVUFBVSxDQUFDO0FBQ25DLE9BQU8sS0FBSyxVQUFVLE1BQU0sY0FBYyxDQUFDO0FBRzNDLE1BQU0sc0JBQXNCLEtBQVk7SUFDdEMsSUFBSSxXQUFXLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDdEIsS0FBSyxDQUFDLFNBQVMsQ0FBQyxPQUFPLEdBQUcsZUFBZSxDQUFDLEtBQUssQ0FBQyxD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UUFDbEUsQ0FBQyxDQUNGLENBQUM7UUFDRixZQUFZLENBQUMsZUFBZSxDQUFDLElBQUksRUFBRSx1QkFBdUIsQ0FBQyxDQUFDO0lBQzlELENBQUM7SUFyQkQseUJBQXlCO0lBQ3pCLEtBQW1CLFVBQW9CLEVBQXBCLDZDQUFvQixFQUFwQixrQ0FBb0IsRUFBcEIsSUFBb0I7UUFBbEMsSUFBTSxJQUFJLDZCQUFBO2dCQUFKLElBQUk7S0FvQmQ7SUFDRCxJQUFJLFVBQVUsRUFBRTtRQUNkLElBQUcsQ0FBQyxDQUFDLFlBQVksQ0FBQyxRQUFRLElBQUksRUFBRSxDQUFDLENBQUMsTUFBTSxJQUFJLEVBQUUsQ0FBQyxDQUFDLFFBQVEsRUFBRTtZQUN4RCxvQkFBb0IsQ0FBQyxZQUFZLENBQUMsUUFBUSxFQUFFLENBQUMsUUFBUSxFQUFFLFVBQVUsQ0FBQyxDQUFDLENBQUM7U0FDckU7UUFDRCxJQUFJLENBQUMsQ0FBQyxZQUFZLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUU7WUFDekQsb0JBQW9CLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO1NBQ3JFO0tBQ0Y7SUFHRCxPQUFPLFlBQVksQ0FBQztBQUN0QixDQUFDIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtDT0xPUiwgRklMTCwgTm9uUG9zaXRpb25TY2FsZUNoYW5uZWwsIE9QQUNJVFksIFNIQVBFLCBTSVpFLCBTVFJPS0V9IGZyb20gJy4uLy4uL2NoYW5uZWwnO1xuaW1wb3J0IHtpc0ZpZWxkRGVmLCB0aXRsZSBhcyBmaWVsZERlZlRpdGxlfSBmcm9tICcuLi8uLi9maWVsZGRlZic7XG5pbXBvcnQge0xlZ2VuZCwgTEVHRU5EX1BST1BFUlRJRVMsIFZHX0xFR0VORF9QUk9QRVJUSUVTfSBmcm9tICcuLi8uLi9sZWdlbmQnO1xuaW1wb3J0IHtHRU9KU09OfSBmcm9tICcuLi8uLi90eXBlJztcbmltcG9ydCB7ZGVsZXRlTmVzdGVkUHJvcGVydHksIGtleXN9IGZyb20gJy4uLy4uL3V0aWwnO1xuaW1wb3J0IHtWZ0xlZ2VuZCwgVmdMZWdlbmRFbmNvZGV9IGZyb20gJy4uLy4uL3ZlZ2Euc2NoZW1hJztcbmltcG9ydCB7Z2V0U3BlY2lmaWVkT3JEZWZhdWx0VmFsdWUsIG51bWJlckZvcm1hdCwgdGl0bGVNZXJnZXJ9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQge2lzVW5pdE1vZGVsLCBNb2RlbH0gZnJvbSAnLi4vbW9kZWwnO1xuaW1wb3J0IHtwYXJzZUd1aWRlUmVzb2x2ZX0gZnJvbSAnLi4vcmVzb2x2ZSc7XG5pbXBvcnQge0V4cGxpY2l0LCBtYWtlSW1wbGljaXR9IGZyb20gJy4uL3NwbGl0JztcbmltcG9ydCB7ZGVmYXVsdFRpZUJyZWFrZXIsIG1lcmdlVmFsdWVzV2l0aEV4cGxpY2l0fSBmcm9tICcuLi9zcGxpdCc7XG5pbXBvcnQge1VuaXRNb2RlbH0gZnJvbSAnLi4vdW5pdCc7XG5pbXBvcnQge0xlZ2VuZENvbXBvbmVudCwgTGVnZW5kQ29tcG9uZW50SW5kZXh9IGZyb20gJy4vY29tcG9uZW50JztcbmltcG9ydCAqIGFzIGVuY29kZSBmcm9tICcuL2VuY29kZSc7XG5pbXBvcnQgKiBhcyBwcm9wZXJ0aWVzIGZyb20gJy4vcHJvcGVydGllcyc7XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlTGVnZW5kKG1vZGVsOiBNb2RlbCkge1xuICBpZiAoaXNVbml0TW9kZWwobW9kZWwpKSB7XG4gICAgbW9kZWwuY29tcG9uZW50LmxlZ2VuZHMgPSBwYXJzZVVuaXRMZWdlbmQobW9kZWwpO1xuICB9IGVsc2Uge1xuICAgIG1vZGVsLmNvbXBvbmVudC5sZWdlbmRzID0gcGFyc2VOb25Vbml0TGVnZW5kKG1vZGVsKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZVVuaXRMZWdlbmQobW9kZWw6IFVuaXRNb2RlbCk6IExlZ2VuZENvbXBvbmVudEluZGV4IHtcbiAgY29uc3Qge2VuY29kaW5nfSA9IG1vZGVsO1xuICByZXR1cm4gW0NPTE9SLCBGSUxMLCBTVFJPS0UsIFNJWkUsIFNIQVBFLCBPUEFDSVRZXS5yZWR1Y2UoZnVuY3Rpb24gKGxlZ2VuZENvbXBvbmVudCwgY2hhbm5lbCkge1xuICAgIGNvbnN0IGRlZiA9IGVuY29kaW5nW2NoYW5uZWxdO1xuICAgIGlmIChtb2RlbC5sZWdlbmQoY2hhbm5lbCkgJiYgbW9kZWwuZ2V0U2NhbGVDb21wb25lbnQoY2hhbm5lbCkgJiYgIShpc0ZpZWxkRGVmKGRlZikgJiYgKGNoYW5uZWwgPT09IFNIQVBFICYmIGRlZi50eXBlID09PSBHRU9KU09OKSkpIHtcbiAgICAgIGxlZ2VuZENvbXBvbmVudFtjaGFubmVsXSA9IHBhcnNlTGVnZW5kRm9yQ2hhbm5lbChtb2RlbCwgY2hhbm5lbCk7XG4gICAgfVxuICAgIHJldHVybiBsZWdlbmRDb21wb25lbnQ7XG4gIH0sIHt9KTtcbn1cblxuZnVuY3Rpb24gZ2V0TGVnZW5kRGVmV2l0aFNjYWxlKG1vZGVsOiBVbml0TW9kZWwsIGNoYW5uZWw6IE5vblBvc2l0aW9uU2NhbGVDaGFubmVsKTogVmdMZWdlbmQge1xuICAvLyBGb3IgYmlubmVkIGZpZWxkIHdpdGggY29udGludW91cyBzY2FsZSwgdXNlIGEgc3BlY2lhbCBzY2FsZSBzbyB3ZSBjYW4gb3ZlcnJyaWRlIHRoZSBtYXJrIHByb3BzIGFuZCBsYWJlbHNcbiAgc3dpdGNoIChjaGFubmVsKSB7XG4gICAgY2FzZSBDT0xPUjpcbiAgICAgIGNvbnN0IHNjYWxlID0gbW9kZWwuc2NhbGVOYW1lKENPTE9SKTtcbiAgICAgIHJldHVybiBtb2RlbC5tYXJrRGVmLmZpbGxlZCA/IHtmaWxsOiBzY2FsZX0gOiB7c3Ryb2tlOiBzY2FsZX07XG4gICAgY2FzZSBGSUxMOlxuICAgIGNhc2UgU1RST0tFOlxuICAgIGNhc2UgU0laRTpcbiAgICBjYXNlIFNIQVBFOlxuICAgIGNhc2UgT1BBQ0lUWTpcbiAgICAgIHJldHVybiB7W2NoYW5uZWxdOiBtb2RlbC5zY2FsZU5hbWUoY2hhbm5lbCl9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUxlZ2VuZEZvckNoYW5uZWwobW9kZWw6IFVuaXRNb2RlbCwgY2hhbm5lbDogTm9uUG9zaXRpb25TY2FsZUNoYW5uZWwpOiBMZWdlbmRDb21wb25lbnQge1xuICBjb25zdCBmaWVsZERlZiA9IG1vZGVsLmZpZWxkRGVmKGNoYW5uZWwpO1xuICBjb25zdCBsZWdlbmQgPSBtb2RlbC5sZWdlbmQoY2hhbm5lbCk7XG5cbiAgY29uc3QgbGVnZW5kQ21wdCA9IG5ldyBMZWdlbmRDb21wb25lbnQoe30sIGdldExlZ2VuZERlZldpdGhTY2FsZShtb2RlbCwgY2hhbm5lbCkpO1xuXG4gIExFR0VORF9QUk9QRVJUSUVTLmZvckVhY2goZnVuY3Rpb24ocHJvcGVydHkpIHtcbiAgICBjb25zdCB2YWx1ZSA9IGdldFByb3BlcnR5KHByb3BlcnR5LCBsZWdlbmQsIGNoYW5uZWwsIG1vZGVsKTtcbiAgICBpZiAodmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgY29uc3QgZXhwbGljaXQgPSBwcm9wZXJ0eSA9PT0gJ3ZhbHVlcycgP1xuICAgICAgICAhIWxlZ2VuZC52YWx1ZXMgOiAgLy8gc3BlY2lmaWVkIGxlZ2VuZC52YWx1ZXMgaXMgYWxyZWFkeSByZXNwZWN0ZWQsIGJ1dCBtYXkgZ2V0IHRyYW5zZm9ybWVkLlxuICAgICAgICB2YWx1ZSA9PT0gbGVnZW5kW3Byb3BlcnR5XTtcbiAgICAgIGlmIChleHBsaWNpdCB8fCBtb2RlbC5jb25maWcubGVnZW5kW3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxlZ2VuZENtcHQuc2V0KHByb3BlcnR5LCB2YWx1ZSwgZXhwbGljaXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gMikgQWRkIG1hcmsgcHJvcGVydHkgZGVmaW5pdGlvbiBncm91cHNcbiAgY29uc3QgbGVnZW5kRW5jb2RpbmcgPSBsZWdlbmQuZW5jb2RpbmcgfHwge307XG4gIGNvbnN0IGxlZ2VuZEVuY29kZSA9IFsnbGFiZWxzJywgJ2xlZ2VuZCcsICd0aXRsZScsICdzeW1ib2xzJywgJ2dyYWRpZW50J10ucmVkdWNlKChlOiBWZ0xlZ2VuZEVuY29kZSwgcGFydCkgPT4ge1xuICAgIGNvbnN0IHZhbHVlID0gZW5jb2RlW3BhcnRdID9cbiAgICAgIC8vIFRPRE86IHJlcGxhY2UgbGVnZW5kQ21wdCB3aXRoIHR5cGUgaXMgc3VmZmljaWVudFxuICAgICAgZW5jb2RlW3BhcnRdKGZpZWxkRGVmLCBsZWdlbmRFbmNvZGluZ1twYXJ0XSwgbW9kZWwsIGNoYW5uZWwsIGxlZ2VuZENtcHQuZ2V0KCd0eXBlJykpIDogLy8gYXBwbHkgcnVsZVxuICAgICAgbGVnZW5kRW5jb2RpbmdbcGFydF07IC8vIG5vIHJ1bGUgLS0ganVzdCBkZWZhdWx0IHZhbHVlc1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGtleXModmFsdWUpLmxlbmd0aCA+IDApIHtcbiAgICAgIGVbcGFydF0gPSB7dXBkYXRlOiB2YWx1ZX07XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCB7fSBhcyBWZ0xlZ2VuZEVuY29kZSk7XG5cbiAgaWYgKGtleXMobGVnZW5kRW5jb2RlKS5sZW5ndGggPiAwKSB7XG4gICAgbGVnZW5kQ21wdC5zZXQoJ2VuY29kZScsIGxlZ2VuZEVuY29kZSwgISFsZWdlbmQuZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGxlZ2VuZENtcHQ7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5KHByb3BlcnR5OiBrZXlvZiAoTGVnZW5kIHwgVmdMZWdlbmQpLCBzcGVjaWZpZWRMZWdlbmQ6IExlZ2VuZCwgY2hhbm5lbDogTm9uUG9zaXRpb25TY2FsZUNoYW5uZWwsIG1vZGVsOiBVbml0TW9kZWwpIHtcbiAgY29uc3QgZmllbGREZWYgPSBtb2RlbC5maWVsZERlZihjaGFubmVsKTtcblxuICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnZm9ybWF0JzpcbiAgICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGVtcG9yYWwgZmllbGQgaGVyZSBhcyB3ZSBhcHBseSBmb3JtYXQgaW4gZW5jb2RlIGJsb2NrXG4gICAgICByZXR1cm4gbnVtYmVyRm9ybWF0KGZpZWxkRGVmLCBzcGVjaWZpZWRMZWdlbmQuZm9ybWF0LCBtb2RlbC5jb25maWcpO1xuICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIC8vIEZvciBmYWxzeSB2YWx1ZSwga2VlcCB1bmRlZmluZWQgc28gd2UgdXNlIGRlZmF1bHQsXG4gICAgICAvLyBidXQgdXNlIG51bGwgZm9yICcnLCBudWxsLCBhbmQgZmFsc2UgdG8gaGlkZSB0aGUgdGl0bGVcbiAgICAgIGNvbnN0IHNwZWNpZmllZFRpdGxlID0gZmllbGREZWYudGl0bGUgIT09IHVuZGVmaW5lZCA/IGZpZWxkRGVmLnRpdGxlIDpcbiAgICAgICAgc3BlY2lmaWVkTGVnZW5kLnRpdGxlIHx8IChzcGVjaWZpZWRMZWdlbmQudGl0bGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG51bGwpO1xuXG4gICAgICByZXR1cm4gZ2V0U3BlY2lmaWVkT3JEZWZhdWx0VmFsdWUoXG4gICAgICAgIHNwZWNpZmllZFRpdGxlLFxuICAgICAgICBmaWVsZERlZlRpdGxlKGZpZWxkRGVmLCBtb2RlbC5jb25maWcpXG4gICAgICApIHx8IHVuZGVmaW5lZDsgLy8gbWFrZSBmYWxzeSB2YWx1ZSB1bmRlZmluZWQgc28gb3V0cHV0IFZlZ2Egc3BlYyBpcyBzaG9ydGVyXG4gICAgY2FzZSAndmFsdWVzJzpcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzLnZhbHVlcyhzcGVjaWZpZWRMZWdlbmQpO1xuICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgcmV0dXJuIGdldFNwZWNpZmllZE9yRGVmYXVsdFZhbHVlKHNwZWNpZmllZExlZ2VuZC50eXBlLCBwcm9wZXJ0aWVzLnR5cGUoZmllbGREZWYudHlwZSwgY2hhbm5lbCwgbW9kZWwuZ2V0U2NhbGVDb21wb25lbnQoY2hhbm5lbCkuZ2V0KCd0eXBlJykpKTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgcmV0dXJuIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAgcmV0dXJuIHNwZWNpZmllZExlZ2VuZFtwcm9wZXJ0eV07XG59XG5cbmZ1bmN0aW9uIHBhcnNlTm9uVW5pdExlZ2VuZChtb2RlbDogTW9kZWwpIHtcbiAgY29uc3Qge2xlZ2VuZHMsIHJlc29sdmV9ID0gbW9kZWwuY29tcG9uZW50O1xuXG4gIGZvciAoY29uc3QgY2hpbGQgb2YgbW9kZWwuY2hpbGRyZW4pIHtcbiAgICBwYXJzZUxlZ2VuZChjaGlsZCk7XG5cbiAgICBrZXlzKGNoaWxkLmNvbXBvbmVudC5sZWdlbmRzKS5mb3JFYWNoKChjaGFubmVsOiBOb25Qb3NpdGlvblNjYWxlQ2hhbm5lbCkgPT4ge1xuICAgICAgcmVzb2x2ZS5sZWdlbmRbY2hhbm5lbF0gPSBwYXJzZUd1aWRlUmVzb2x2ZShtb2RlbC5jb21wb25lbnQucmVzb2x2ZSwgY2hhbm5lbCk7XG5cbiAgICAgIGlmIChyZXNvbHZlLmxlZ2VuZFtjaGFubmVsXSA9PT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJlc29sdmUgc2F5cyBzaGFyZWQgKGFuZCBoYXMgbm90IGJlZW4gb3ZlcnJpZGRlbilcbiAgICAgICAgLy8gV2Ugd2lsbCB0cnkgdG8gbWVyZ2UgYW5kIHNlZSBpZiB0aGVyZSBpcyBhIGNvbmZsaWN0XG5cbiAgICAgICAgbGVnZW5kc1tjaGFubmVsXSA9IG1lcmdlTGVnZW5kQ29tcG9uZW50KGxlZ2VuZHNbY2hhbm5lbF0sIGNoaWxkLmNvbXBvbmVudC5sZWdlbmRzW2NoYW5uZWxdKTtcblxuICAgICAgICBpZiAoIWxlZ2VuZHNbY2hhbm5lbF0pIHtcbiAgICAgICAgICAvLyBJZiBtZXJnZSByZXR1cm5zIG5vdGhpbmcsIHRoZXJlIGlzIGEgY29uZmxpY3Qgc28gd2UgY2Fubm90IG1ha2UgdGhlIGxlZ2VuZCBzaGFyZWQuXG4gICAgICAgICAgLy8gVGh1cywgbWFyayBsZWdlbmQgYXMgaW5kZXBlbmRlbnQgYW5kIHJlbW92ZSB0aGUgbGVnZW5kIGNvbXBvbmVudC5cbiAgICAgICAgICByZXNvbHZlLmxlZ2VuZFtjaGFubmVsXSA9ICdpbmRlcGVuZGVudCc7XG4gICAgICAgICAgZGVsZXRlIGxlZ2VuZHNbY2hhbm5lbF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGtleXMobGVnZW5kcykuZm9yRWFjaCgoY2hhbm5lbDogTm9uUG9zaXRpb25TY2FsZUNoYW5uZWwpID0+IHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG1vZGVsLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoIWNoaWxkLmNvbXBvbmVudC5sZWdlbmRzW2NoYW5uZWxdKSB7XG4gICAgICAgIC8vIHNraXAgaWYgdGhlIGNoaWxkIGRvZXMgbm90IGhhdmUgYSBwYXJ0aWN1bGFyIGxlZ2VuZFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc29sdmUubGVnZW5kW2NoYW5uZWxdID09PSAnc2hhcmVkJykge1xuICAgICAgICAvLyBBZnRlciBtZXJnaW5nIHNoYXJlZCBsZWdlbmQsIG1ha2Ugc3VyZSB0byByZW1vdmUgbGVnZW5kIGZyb20gY2hpbGRcbiAgICAgICAgZGVsZXRlIGNoaWxkLmNvbXBvbmVudC5sZWdlbmRzW2NoYW5uZWxdO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsZWdlbmRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VMZWdlbmRDb21wb25lbnQobWVyZ2VkTGVnZW5kOiBMZWdlbmRDb21wb25lbnQsIGNoaWxkTGVnZW5kOiBMZWdlbmRDb21wb25lbnQpOiBMZWdlbmRDb21wb25lbnQge1xuICBpZiAoIW1lcmdlZExlZ2VuZCkge1xuICAgIHJldHVybiBjaGlsZExlZ2VuZC5jbG9uZSgpO1xuICB9XG4gIGNvbnN0IG1lcmdlZE9yaWVudCA9IG1lcmdlZExlZ2VuZC5nZXRXaXRoRXhwbGljaXQoJ29yaWVudCcpO1xuICBjb25zdCBjaGlsZE9yaWVudCA9IGNoaWxkTGVnZW5kLmdldFdpdGhFeHBsaWNpdCgnb3JpZW50Jyk7XG5cblxuICBpZiAobWVyZ2VkT3JpZW50LmV4cGxpY2l0ICYmIGNoaWxkT3JpZW50LmV4cGxpY2l0ICYmIG1lcmdlZE9yaWVudC52YWx1ZSAhPT0gY2hpbGRPcmllbnQudmFsdWUpIHtcbiAgICAvLyBUT0RPOiB0aHJvdyB3YXJuaW5nIGlmIHJlc29sdmUgaXMgZXhwbGljaXQgKFdlIGRvbid0IGhhdmUgaW5mbyBhYm91dCBleHBsaWNpdC9pbXBsaWNpdCByZXNvbHZlIHlldC4pXG4gICAgLy8gQ2Fubm90IG1lcmdlIGR1ZSB0byBpbmNvbnNpc3RlbnQgb3JpZW50XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgdHlwZU1lcmdlZCA9IGZhbHNlO1xuICAvLyBPdGhlcndpc2UsIGxldCdzIG1lcmdlXG4gIGZvciAoY29uc3QgcHJvcCBvZiBWR19MRUdFTkRfUFJPUEVSVElFUykge1xuICAgIGNvbnN0IG1lcmdlZFZhbHVlV2l0aEV4cGxpY2l0ID0gbWVyZ2VWYWx1ZXNXaXRoRXhwbGljaXQ8VmdMZWdlbmQsIGFueT4oXG4gICAgICBtZXJnZWRMZWdlbmQuZ2V0V2l0aEV4cGxpY2l0KHByb3ApLFxuICAgICAgY2hpbGRMZWdlbmQuZ2V0V2l0aEV4cGxpY2l0KHByb3ApLFxuICAgICAgcHJvcCwgJ2xlZ2VuZCcsXG5cbiAgICAgIC8vIFRpZSBicmVha2VyIGZ1bmN0aW9uXG4gICAgICAodjE6IEV4cGxpY2l0PGFueT4sIHYyOiBFeHBsaWNpdDxhbnk+KTogYW55ID0+IHtcbiAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgICAgICAgcmV0dXJuIHRpdGxlTWVyZ2VyKHYxLCB2Mik7XG4gICAgICAgICAgY2FzZSAndHlwZSc6XG4gICAgICAgICAgICAvLyBUaGVyZSBhcmUgb25seSB0d28gdHlwZXMuIElmIHdlIGhhdmUgZGlmZmVyZW50IHR5cGVzLCB0aGVuIHByZWZlciBzeW1ib2wgb3ZlciBncmFkaWVudC5cbiAgICAgICAgICAgIHR5cGVNZXJnZWQgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIG1ha2VJbXBsaWNpdCgnc3ltYm9sJyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlZmF1bHRUaWVCcmVha2VyPFZnTGVnZW5kLCBhbnk+KHYxLCB2MiwgcHJvcCwgJ2xlZ2VuZCcpO1xuICAgICAgfVxuICAgICk7XG4gICAgbWVyZ2VkTGVnZW5kLnNldFdpdGhFeHBsaWNpdChwcm9wLCBtZXJnZWRWYWx1ZVdpdGhFeHBsaWNpdCk7XG4gIH1cbiAgaWYgKHR5cGVNZXJnZWQpIHtcbiAgICBpZigoKG1lcmdlZExlZ2VuZC5pbXBsaWNpdCB8fCB7fSkuZW5jb2RlIHx8IHt9KS5ncmFkaWVudCkge1xuICAgICAgZGVsZXRlTmVzdGVkUHJvcGVydHkobWVyZ2VkTGVnZW5kLmltcGxpY2l0LCBbJ2VuY29kZScsICdncmFkaWVudCddKTtcbiAgICB9XG4gICAgaWYgKCgobWVyZ2VkTGVnZW5kLmV4cGxpY2l0IHx8IHt9KS5lbmNvZGUgfHwge30pLmdyYWRpZW50KSB7XG4gICAgICBkZWxldGVOZXN0ZWRQcm9wZXJ0eShtZXJnZWRMZWdlbmQuZXhwbGljaXQsIFsnZW5jb2RlJywgJ2dyYWRpZW50J10pO1xuICAgIH1cbiAgfVxuXG5cbiAgcmV0dXJuIG1lcmdlZExlZ2VuZDtcbn1cblxuIl19