import { COLOR, FILL, OPACITY, SHAPE, SIZE, STROKE } from '../../channel';
import { isFieldDef, title as fieldDefTitle } from '../../fielddef';
import { LEGEND_PROPERTIES, VG_LEGEND_PROPERTIES } from '../../legend';
import { GEOJSON } from '../../type';
import { deleteNestedProperty, keys } from '../../util';
import { getSpecifiedOrDefaultValue, guideEncodeEntry, mergeTitleComponent, numberFormat } from '../common';
import { isUnitModel } from '../model';
import { parseGuideResolve } from '../resolve';
import { defaultTieBreaker, makeImplicit, mergeValuesWithExplicit } from '../split';
import { LegendComponent } from './component';
import * as encode from './encode';
import * as properties from './properties';
export function parseLegend(model) {
    if (isUnitModel(model)) {
        model.component.legends = parseUnitLegend(model);
    }
    else {
        model.component.legends = parseNonUnitLegend(model);
    }
}
function parseUnitLegend(model) {
    var encoding = model.encoding;
    return [COLOR, FILL, STROKE, SIZE, SHAPE, OPACITY].reduce(function (legendComponent, channel) {
        var def = encoding[channel];
        if (model.legend(channel) && model.getScaleComponent(channel) && !(isFieldDef(def) && (channel === SHAPE && def.type === GEOJSON))) {
            legendComponent[channel] = parseLegendForChannel(model, channel);
        }
        return legendComponent;
    }, {});
}
function getLegendDefWithScale(model, channel) {
    // For binned field with continuous scale, use a special scale so we can overrride the mark props and labels
    switch (channel) {
        case COLOR:
            var scale = model.scaleName(COLOR);
            return model.markDef.filled ? { fill: scale } : { stroke: scale };
        case FILL:
        case STROKE:
        case SIZE:
        case SHAPE:
        case OPACITY:
            return _a = {}, _a[channel] = model.scaleName(channel), _a;
    }
    var _a;
}
export function parseLegendForChannel(model, channel) {
    var fieldDef = model.fieldDef(channel);
    var legend = model.legend(channel);
    var legendCmpt = new LegendComponent({}, getLegendDefWithScale(model, channel));
    LEGEND_PROPERTIES.forEach(function (property) {
        var value = getProperty(property, legend, channel, model);
        if (value !== undefined) {
            var explicit = 
            // specified legend.values is already respected, but may get transformed.
            property === 'values' ? !!legend.values :
                // title can be explicit if fieldDef.title is set
                property === 'title' && value === model.fieldDef(channel).title ? true :
                    // Otherwise, things are explicit if the returned value matches the specified property
                    value === legend[property];
            if (explicit || model.config.legend[property] === undefined) {
                legendCmpt.set(property, value, explicit);
            }
        }
    });
    // 2) Add mark property definition groups
    var legendEncoding = legend.encoding || {};
    var legendEncode = ['labels', 'legend', 'title', 'symbols', 'gradient'].reduce(function (e, part) {
        var legendEncodingPart = guideEncodeEntry(legendEncoding[part] || {}, model);
        var value = encode[part] ?
            // TODO: replace legendCmpt with type is sufficient
            encode[part](fieldDef, legendEncodingPart, model, channel, legendCmpt.get('type')) : // apply rule
            legendEncodingPart; // no rule -- just default values
        if (value !== undefined && keys(value).length > 0) {
            e[part] = { update: value };
        }
        return e;
    }, {});
    if (keys(legendEncode).length > 0) {
        legendCmpt.set('encode', legendEncode, !!legend.encoding);
    }
    return legendCmpt;
}
function getProperty(property, specifiedLegend, channel, model) {
    var fieldDef = model.fieldDef(channel);
    switch (property) {
        case 'format':
            // We don't include temporal field here as we apply format in encode block
            return numberFormat(fieldDef, specifiedLegend.format, model.config);
        case 'title':
            // For falsy value, keep undefined so we use default,
            // but use null for '', null, and false to hide the title
            var specifiedTitle = fieldDef.title !== undefined ? fieldDef.title :
                specifiedLegend.title || (specifiedLegend.title === undefined ? undefined : null);
            return getSpecifiedOrDefaultValue(specifiedTitle, fieldDefTitle(fieldDef, model.config)) || undefined; // make falsy value undefined so output Vega spec is shorter
        case 'values':
            return properties.values(specifiedLegend);
        case 'type':
            return getSpecifiedOrDefaultValue(specifiedLegend.type, properties.type(fieldDef.type, channel, model.getScaleComponent(channel).get('type')));
    }
    // Otherwise, return specified property.
    return specifiedLegend[property];
}
function parseNonUnitLegend(model) {
    var _a = model.component, legends = _a.legends, resolve = _a.resolve;
    var _loop_1 = function (child) {
        parseLegend(child);
        keys(child.component.legends).forEach(function (channel) {
            resolve.legend[channel] = parseGuideResolve(model.component.resolve, channel);
            if (resolve.legend[channel] === 'shared') {
                // If the resolve says shared (and has not been overridden)
                // We will try to merge and see if there is a conflict
                legends[channel] = mergeLegendComponent(legends[channel], child.component.legends[channel]);
                if (!legends[channel]) {
                    // If merge returns nothing, there is a conflict so we cannot make the legend shared.
                    // Thus, mark legend as independent and remove the legend component.
                    resolve.legend[channel] = 'independent';
                    delete legends[channel];
                }
            }
        });
    };
    for (var _i = 0, _b = model.children; _i < _b.length; _i++) {
        var child = _b[_i];
        _loop_1(child);
    }
    keys(legends).forEach(function (channel) {
        for (var _i = 0, _a = model.children; _i < _a.length; _i++) {
            var child = _a[_i];
            if (!child.component.legends[channel]) {
                // skip if the child does not have a particular legend
                continue;
            }
            if (resolve.legend[channel] === 'shared') {
                // After merging shared legend, make sure to remove legend from child
                delete child.component.legends[channel];
            }
        }
    });
    return legends;
}
export function mergeLegendComponent(mergedLegend, childLegend) {
    if (!mergedLegend) {
        return childLegend.clone();
    }
    var mergedOrient = mergedLegend.getWithExplicit('orient');
    var childOrient = childLegend.getWithExplicit('orient');
    if (mergedOrient.explicit && childOrient.explicit && mergedOrient.value !== childOrient.value) {
        // TODO: throw warning if resolve is explicit (We don't have info about explicit/implicit resolve yet.)
        // Cannot merge due to inconsistent orient
        return undefined;
    }
    var typeMerged = false;
    var _loop_2 = function (prop) {
        var mergedValueWithExplicit = mergeValuesWithExplicit(mergedLegend.getWithExplicit(prop), childLegend.getWithExplicit(prop), prop, 'legend', 
        // Tie breaker function
        function (v1, v2) {
            switch (prop) {
                case 'title':
                    return mergeTitleComponent(v1, v2);
                case 'type':
                    // There are only two types. If we have different types, then prefer symbol over gradient.
                    typeMerged = true;
                    return makeImplicit('symbol');
            }
            return defaultTieBreaker(v1, v2, prop, 'legend');
        });
        mergedLegend.setWithExplicit(prop, mergedValueWithExplicit);
    };
    // Otherwise, let's merge
    for (var _i = 0, VG_LEGEND_PROPERTIES_1 = VG_LEGEND_PROPERTIES; _i < VG_LEGEND_PROPERTIES_1.length; _i++) {
        var prop = VG_LEGEND_PROPERTIES_1[_i];
        _loop_2(prop);
    }
    if (typeMerged) {
        if (((mergedLegend.implicit || {}).encode || {}).gradient) {
            deleteNestedProperty(mergedLegend.implicit, ['encode', 'gradient']);
        }
        if (((mergedLegend.explicit || {}).encode || {}).gradient) {
            deleteNestedProperty(mergedLegend.explicit, ['encode', 'gradient']);
        }
    }
    return mergedLegend;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcGlsZS9sZWdlbmQvcGFyc2UudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUEsT0FBTyxFQUFDLEtBQUssRUFBRSxJQUFJLEVBQTJCLE9BQU8sRUFBRSxLQUFLLEVBQUUsSUFBSSxFQUFFLE1BQU0sRUFBQyxNQUFNLGVBQWUsQ0FBQztBQUNqRyxPQUFPLEVBQUMsVUFBVSxFQUFFLEtBQUssSUFBSSxhQUFhLEVBQUMsTUFBTSxnQkFBZ0IsQ0FBQztBQUNsRSxPQUFPLEVBQVMsaUJBQWlCLEVBQUUsb0JBQW9CLEVBQUMsTUFBTSxjQUFjLENBQUM7QUFDN0UsT0FBTyxFQUFDLE9BQU8sRUFBQyxNQUFNLFlBQVksQ0FBQztBQUNuQyxPQUFPLEVBQUMsb0JBQW9CLEVBQUUsSUFBSSxFQUFDLE1BQU0sWUFBWSxDQUFDO0FBRXRELE9BQU8sRUFBQywwQkFBMEIsRUFBRSxnQkFBZ0IsRUFBRSxtQkFBbUIsRUFBRSxZQUFZLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDMUcsT0FBTyxFQUFDLFdBQVcsRUFBUSxNQUFNLFVBQVUsQ0FBQztBQUM1QyxPQUFPLEVBQUMsaUJBQWlCLEVBQUMsTUFBTSxZQUFZLENBQUM7QUFDN0MsT0FBTyxFQUFDLGlCQUFpQixFQUFZLFlBQVksRUFBRSx1QkFBdUIsRUFBQyxNQUFNLFVBQVUsQ0FBQztBQUU1RixPQUFPLEVBQUMsZUFBZSxFQUF1QixNQUFNLGFBQWEsQ0FBQztBQUNsRSxPQUFPLEtBQUssTUFBTSxNQUFNLFVBQVUsQ0FBQztBQUNuQyxPQUFPLEtBQUssVUFBVSxNQUFNLGNBQWMsQ0FBQztBQUczQyxNQUFNLHNCQUFzQixLQUFZO0lBQ3RDLElBQUksV0FBVyxDQUFDLEtBQUssQ0FBQyxFQUFFO1FBQ3RCLEtBQUssQ0FBQyxTQUFTLENBQUMsT0FBTyxHQUFHLGVBQWUsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUNsRDtTQUFNO1FB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Q0FBQyxDQUFDO2dCQUNyQyxLQUFLLE1BQU07b0JBQ1QsMEZBQTBGO29CQUMxRixVQUFVLEdBQUcsSUFBSSxDQUFDO29CQUNsQixPQUFPLFlBQVksQ0FBQyxRQUFRLENBQUMsQ0FBQzthQUNqQztZQUNELE9BQU8saUJBQWlCLENBQWdCLEVBQUUsRUFBRSxFQUFFLEVBQUUsSUFBSSxFQUFFLFFBQVEsQ0FBQyxDQUFDO1FBQ2xFLENBQUMsQ0FDRixDQUFDO1FBQ0YsWUFBWSxDQUFDLGVBQWUsQ0FBQyxJQUFJLEVBQUUsdUJBQXVCLENBQUMsQ0FBQztJQUM5RCxDQUFDO0lBckJELHlCQUF5QjtJQUN6QixLQUFtQixVQUFvQixFQUFwQiw2Q0FBb0IsRUFBcEIsa0NBQW9CLEVBQXBCLElBQW9CO1FBQWxDLElBQU0sSUFBSSw2QkFBQTtnQkFBSixJQUFJO0tBb0JkO0lBQ0QsSUFBSSxVQUFVLEVBQUU7UUFDZCxJQUFHLENBQUMsQ0FBQyxZQUFZLENBQUMsUUFBUSxJQUFJLEVBQUUsQ0FBQyxDQUFDLE1BQU0sSUFBSSxFQUFFLENBQUMsQ0FBQyxRQUFRLEVBQUU7WUFDeEQsb0JBQW9CLENBQUMsWUFBWSxDQUFDLFFBQVEsRUFBRSxDQUFDLFFBQVEsRUFBRSxVQUFVLENBQUMsQ0FBQyxDQUFDO1NBQ3JFO1FBQ0QsSUFBSSxDQUFDLENBQUMsWUFBWSxDQUFDLFFBQVEsSUFBSSxFQUFFLENBQUMsQ0FBQyxNQUFNLElBQUksRUFBRSxDQUFDLENBQUMsUUFBUSxFQUFFO1lBQ3pELG9CQUFvQixDQUFDLFlBQVksQ0FBQyxRQUFRLEVBQUUsQ0FBQyxRQUFRLEVBQUUsVUFBVSxDQUFDLENBQUMsQ0FBQztTQUNyRTtLQUNGO0lBR0QsT0FBTyxZQUFZLENBQUM7QUFDdEIsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7Q09MT1IsIEZJTEwsIE5vblBvc2l0aW9uU2NhbGVDaGFubmVsLCBPUEFDSVRZLCBTSEFQRSwgU0laRSwgU1RST0tFfSBmcm9tICcuLi8uLi9jaGFubmVsJztcbmltcG9ydCB7aXNGaWVsZERlZiwgdGl0bGUgYXMgZmllbGREZWZUaXRsZX0gZnJvbSAnLi4vLi4vZmllbGRkZWYnO1xuaW1wb3J0IHtMZWdlbmQsIExFR0VORF9QUk9QRVJUSUVTLCBWR19MRUdFTkRfUFJPUEVSVElFU30gZnJvbSAnLi4vLi4vbGVnZW5kJztcbmltcG9ydCB7R0VPSlNPTn0gZnJvbSAnLi4vLi4vdHlwZSc7XG5pbXBvcnQge2RlbGV0ZU5lc3RlZFByb3BlcnR5LCBrZXlzfSBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7VmdMZWdlbmQsIFZnTGVnZW5kRW5jb2RlfSBmcm9tICcuLi8uLi92ZWdhLnNjaGVtYSc7XG5pbXBvcnQge2dldFNwZWNpZmllZE9yRGVmYXVsdFZhbHVlLCBndWlkZUVuY29kZUVudHJ5LCBtZXJnZVRpdGxlQ29tcG9uZW50LCBudW1iZXJGb3JtYXR9IGZyb20gJy4uL2NvbW1vbic7XG5pbXBvcnQge2lzVW5pdE1vZGVsLCBNb2RlbH0gZnJvbSAnLi4vbW9kZWwnO1xuaW1wb3J0IHtwYXJzZUd1aWRlUmVzb2x2ZX0gZnJvbSAnLi4vcmVzb2x2ZSc7XG5pbXBvcnQge2RlZmF1bHRUaWVCcmVha2VyLCBFeHBsaWNpdCwgbWFrZUltcGxpY2l0LCBtZXJnZVZhbHVlc1dpdGhFeHBsaWNpdH0gZnJvbSAnLi4vc3BsaXQnO1xuaW1wb3J0IHtVbml0TW9kZWx9IGZyb20gJy4uL3VuaXQnO1xuaW1wb3J0IHtMZWdlbmRDb21wb25lbnQsIExlZ2VuZENvbXBvbmVudEluZGV4fSBmcm9tICcuL2NvbXBvbmVudCc7XG5pbXBvcnQgKiBhcyBlbmNvZGUgZnJvbSAnLi9lbmNvZGUnO1xuaW1wb3J0ICogYXMgcHJvcGVydGllcyBmcm9tICcuL3Byb3BlcnRpZXMnO1xuXG5cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZUxlZ2VuZChtb2RlbDogTW9kZWwpIHtcbiAgaWYgKGlzVW5pdE1vZGVsKG1vZGVsKSkge1xuICAgIG1vZGVsLmNvbXBvbmVudC5sZWdlbmRzID0gcGFyc2VVbml0TGVnZW5kKG1vZGVsKTtcbiAgfSBlbHNlIHtcbiAgICBtb2RlbC5jb21wb25lbnQubGVnZW5kcyA9IHBhcnNlTm9uVW5pdExlZ2VuZChtb2RlbCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcGFyc2VVbml0TGVnZW5kKG1vZGVsOiBVbml0TW9kZWwpOiBMZWdlbmRDb21wb25lbnRJbmRleCB7XG4gIGNvbnN0IHtlbmNvZGluZ30gPSBtb2RlbDtcbiAgcmV0dXJuIFtDT0xPUiwgRklMTCwgU1RST0tFLCBTSVpFLCBTSEFQRSwgT1BBQ0lUWV0ucmVkdWNlKGZ1bmN0aW9uIChsZWdlbmRDb21wb25lbnQsIGNoYW5uZWwpIHtcbiAgICBjb25zdCBkZWYgPSBlbmNvZGluZ1tjaGFubmVsXTtcbiAgICBpZiAobW9kZWwubGVnZW5kKGNoYW5uZWwpICYmIG1vZGVsLmdldFNjYWxlQ29tcG9uZW50KGNoYW5uZWwpICYmICEoaXNGaWVsZERlZihkZWYpICYmIChjaGFubmVsID09PSBTSEFQRSAmJiBkZWYudHlwZSA9PT0gR0VPSlNPTikpKSB7XG4gICAgICBsZWdlbmRDb21wb25lbnRbY2hhbm5lbF0gPSBwYXJzZUxlZ2VuZEZvckNoYW5uZWwobW9kZWwsIGNoYW5uZWwpO1xuICAgIH1cbiAgICByZXR1cm4gbGVnZW5kQ29tcG9uZW50O1xuICB9LCB7fSk7XG59XG5cbmZ1bmN0aW9uIGdldExlZ2VuZERlZldpdGhTY2FsZShtb2RlbDogVW5pdE1vZGVsLCBjaGFubmVsOiBOb25Qb3NpdGlvblNjYWxlQ2hhbm5lbCk6IFZnTGVnZW5kIHtcbiAgLy8gRm9yIGJpbm5lZCBmaWVsZCB3aXRoIGNvbnRpbnVvdXMgc2NhbGUsIHVzZSBhIHNwZWNpYWwgc2NhbGUgc28gd2UgY2FuIG92ZXJycmlkZSB0aGUgbWFyayBwcm9wcyBhbmQgbGFiZWxzXG4gIHN3aXRjaCAoY2hhbm5lbCkge1xuICAgIGNhc2UgQ09MT1I6XG4gICAgICBjb25zdCBzY2FsZSA9IG1vZGVsLnNjYWxlTmFtZShDT0xPUik7XG4gICAgICByZXR1cm4gbW9kZWwubWFya0RlZi5maWxsZWQgPyB7ZmlsbDogc2NhbGV9IDoge3N0cm9rZTogc2NhbGV9O1xuICAgIGNhc2UgRklMTDpcbiAgICBjYXNlIFNUUk9LRTpcbiAgICBjYXNlIFNJWkU6XG4gICAgY2FzZSBTSEFQRTpcbiAgICBjYXNlIE9QQUNJVFk6XG4gICAgICByZXR1cm4ge1tjaGFubmVsXTogbW9kZWwuc2NhbGVOYW1lKGNoYW5uZWwpfTtcbiAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VMZWdlbmRGb3JDaGFubmVsKG1vZGVsOiBVbml0TW9kZWwsIGNoYW5uZWw6IE5vblBvc2l0aW9uU2NhbGVDaGFubmVsKTogTGVnZW5kQ29tcG9uZW50IHtcbiAgY29uc3QgZmllbGREZWYgPSBtb2RlbC5maWVsZERlZihjaGFubmVsKTtcbiAgY29uc3QgbGVnZW5kID0gbW9kZWwubGVnZW5kKGNoYW5uZWwpO1xuXG4gIGNvbnN0IGxlZ2VuZENtcHQgPSBuZXcgTGVnZW5kQ29tcG9uZW50KHt9LCBnZXRMZWdlbmREZWZXaXRoU2NhbGUobW9kZWwsIGNoYW5uZWwpKTtcblxuICBMRUdFTkRfUFJPUEVSVElFUy5mb3JFYWNoKGZ1bmN0aW9uKHByb3BlcnR5KSB7XG4gICAgY29uc3QgdmFsdWUgPSBnZXRQcm9wZXJ0eShwcm9wZXJ0eSwgbGVnZW5kLCBjaGFubmVsLCBtb2RlbCk7XG4gICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGNvbnN0IGV4cGxpY2l0ID1cbiAgICAgICAgLy8gc3BlY2lmaWVkIGxlZ2VuZC52YWx1ZXMgaXMgYWxyZWFkeSByZXNwZWN0ZWQsIGJ1dCBtYXkgZ2V0IHRyYW5zZm9ybWVkLlxuICAgICAgICBwcm9wZXJ0eSA9PT0gJ3ZhbHVlcycgPyAhIWxlZ2VuZC52YWx1ZXMgOlxuICAgICAgICAvLyB0aXRsZSBjYW4gYmUgZXhwbGljaXQgaWYgZmllbGREZWYudGl0bGUgaXMgc2V0XG4gICAgICAgIHByb3BlcnR5ID09PSAndGl0bGUnICYmIHZhbHVlID09PSBtb2RlbC5maWVsZERlZihjaGFubmVsKS50aXRsZSA/IHRydWUgOlxuICAgICAgICAvLyBPdGhlcndpc2UsIHRoaW5ncyBhcmUgZXhwbGljaXQgaWYgdGhlIHJldHVybmVkIHZhbHVlIG1hdGNoZXMgdGhlIHNwZWNpZmllZCBwcm9wZXJ0eVxuICAgICAgICB2YWx1ZSA9PT0gbGVnZW5kW3Byb3BlcnR5XTtcbiAgICAgIGlmIChleHBsaWNpdCB8fCBtb2RlbC5jb25maWcubGVnZW5kW3Byb3BlcnR5XSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxlZ2VuZENtcHQuc2V0KHByb3BlcnR5LCB2YWx1ZSwgZXhwbGljaXQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgLy8gMikgQWRkIG1hcmsgcHJvcGVydHkgZGVmaW5pdGlvbiBncm91cHNcbiAgY29uc3QgbGVnZW5kRW5jb2RpbmcgPSBsZWdlbmQuZW5jb2RpbmcgfHwge307XG4gIGNvbnN0IGxlZ2VuZEVuY29kZSA9IFsnbGFiZWxzJywgJ2xlZ2VuZCcsICd0aXRsZScsICdzeW1ib2xzJywgJ2dyYWRpZW50J10ucmVkdWNlKChlOiBWZ0xlZ2VuZEVuY29kZSwgcGFydCkgPT4ge1xuICAgIGNvbnN0IGxlZ2VuZEVuY29kaW5nUGFydCA9IGd1aWRlRW5jb2RlRW50cnkobGVnZW5kRW5jb2RpbmdbcGFydF0gfHwge30sIG1vZGVsKTtcbiAgICBjb25zdCB2YWx1ZSA9IGVuY29kZVtwYXJ0XSA/XG4gICAgICAvLyBUT0RPOiByZXBsYWNlIGxlZ2VuZENtcHQgd2l0aCB0eXBlIGlzIHN1ZmZpY2llbnRcbiAgICAgIGVuY29kZVtwYXJ0XShmaWVsZERlZiwgbGVnZW5kRW5jb2RpbmdQYXJ0LCBtb2RlbCwgY2hhbm5lbCwgbGVnZW5kQ21wdC5nZXQoJ3R5cGUnKSkgOiAvLyBhcHBseSBydWxlXG4gICAgICBsZWdlbmRFbmNvZGluZ1BhcnQ7IC8vIG5vIHJ1bGUgLS0ganVzdCBkZWZhdWx0IHZhbHVlc1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkICYmIGtleXModmFsdWUpLmxlbmd0aCA+IDApIHtcbiAgICAgIGVbcGFydF0gPSB7dXBkYXRlOiB2YWx1ZX07XG4gICAgfVxuICAgIHJldHVybiBlO1xuICB9LCB7fSBhcyBWZ0xlZ2VuZEVuY29kZSk7XG5cbiAgaWYgKGtleXMobGVnZW5kRW5jb2RlKS5sZW5ndGggPiAwKSB7XG4gICAgbGVnZW5kQ21wdC5zZXQoJ2VuY29kZScsIGxlZ2VuZEVuY29kZSwgISFsZWdlbmQuZW5jb2RpbmcpO1xuICB9XG5cbiAgcmV0dXJuIGxlZ2VuZENtcHQ7XG59XG5cbmZ1bmN0aW9uIGdldFByb3BlcnR5KHByb3BlcnR5OiBrZXlvZiAoTGVnZW5kIHwgVmdMZWdlbmQpLCBzcGVjaWZpZWRMZWdlbmQ6IExlZ2VuZCwgY2hhbm5lbDogTm9uUG9zaXRpb25TY2FsZUNoYW5uZWwsIG1vZGVsOiBVbml0TW9kZWwpIHtcbiAgY29uc3QgZmllbGREZWYgPSBtb2RlbC5maWVsZERlZihjaGFubmVsKTtcblxuICBzd2l0Y2ggKHByb3BlcnR5KSB7XG4gICAgY2FzZSAnZm9ybWF0JzpcbiAgICAgIC8vIFdlIGRvbid0IGluY2x1ZGUgdGVtcG9yYWwgZmllbGQgaGVyZSBhcyB3ZSBhcHBseSBmb3JtYXQgaW4gZW5jb2RlIGJsb2NrXG4gICAgICByZXR1cm4gbnVtYmVyRm9ybWF0KGZpZWxkRGVmLCBzcGVjaWZpZWRMZWdlbmQuZm9ybWF0LCBtb2RlbC5jb25maWcpO1xuICAgIGNhc2UgJ3RpdGxlJzpcbiAgICAgIC8vIEZvciBmYWxzeSB2YWx1ZSwga2VlcCB1bmRlZmluZWQgc28gd2UgdXNlIGRlZmF1bHQsXG4gICAgICAvLyBidXQgdXNlIG51bGwgZm9yICcnLCBudWxsLCBhbmQgZmFsc2UgdG8gaGlkZSB0aGUgdGl0bGVcbiAgICAgIGNvbnN0IHNwZWNpZmllZFRpdGxlID0gZmllbGREZWYudGl0bGUgIT09IHVuZGVmaW5lZCA/IGZpZWxkRGVmLnRpdGxlIDpcbiAgICAgICAgc3BlY2lmaWVkTGVnZW5kLnRpdGxlIHx8IChzcGVjaWZpZWRMZWdlbmQudGl0bGUgPT09IHVuZGVmaW5lZCA/IHVuZGVmaW5lZCA6IG51bGwpO1xuXG4gICAgICByZXR1cm4gZ2V0U3BlY2lmaWVkT3JEZWZhdWx0VmFsdWUoXG4gICAgICAgIHNwZWNpZmllZFRpdGxlLFxuICAgICAgICBmaWVsZERlZlRpdGxlKGZpZWxkRGVmLCBtb2RlbC5jb25maWcpXG4gICAgICApIHx8IHVuZGVmaW5lZDsgLy8gbWFrZSBmYWxzeSB2YWx1ZSB1bmRlZmluZWQgc28gb3V0cHV0IFZlZ2Egc3BlYyBpcyBzaG9ydGVyXG4gICAgY2FzZSAndmFsdWVzJzpcbiAgICAgIHJldHVybiBwcm9wZXJ0aWVzLnZhbHVlcyhzcGVjaWZpZWRMZWdlbmQpO1xuICAgIGNhc2UgJ3R5cGUnOlxuICAgICAgcmV0dXJuIGdldFNwZWNpZmllZE9yRGVmYXVsdFZhbHVlKHNwZWNpZmllZExlZ2VuZC50eXBlLCBwcm9wZXJ0aWVzLnR5cGUoZmllbGREZWYudHlwZSwgY2hhbm5lbCwgbW9kZWwuZ2V0U2NhbGVDb21wb25lbnQoY2hhbm5lbCkuZ2V0KCd0eXBlJykpKTtcbiAgfVxuXG4gIC8vIE90aGVyd2lzZSwgcmV0dXJuIHNwZWNpZmllZCBwcm9wZXJ0eS5cbiAgcmV0dXJuIHNwZWNpZmllZExlZ2VuZFtwcm9wZXJ0eV07XG59XG5cbmZ1bmN0aW9uIHBhcnNlTm9uVW5pdExlZ2VuZChtb2RlbDogTW9kZWwpIHtcbiAgY29uc3Qge2xlZ2VuZHMsIHJlc29sdmV9ID0gbW9kZWwuY29tcG9uZW50O1xuXG4gIGZvciAoY29uc3QgY2hpbGQgb2YgbW9kZWwuY2hpbGRyZW4pIHtcbiAgICBwYXJzZUxlZ2VuZChjaGlsZCk7XG5cbiAgICBrZXlzKGNoaWxkLmNvbXBvbmVudC5sZWdlbmRzKS5mb3JFYWNoKChjaGFubmVsOiBOb25Qb3NpdGlvblNjYWxlQ2hhbm5lbCkgPT4ge1xuICAgICAgcmVzb2x2ZS5sZWdlbmRbY2hhbm5lbF0gPSBwYXJzZUd1aWRlUmVzb2x2ZShtb2RlbC5jb21wb25lbnQucmVzb2x2ZSwgY2hhbm5lbCk7XG5cbiAgICAgIGlmIChyZXNvbHZlLmxlZ2VuZFtjaGFubmVsXSA9PT0gJ3NoYXJlZCcpIHtcbiAgICAgICAgLy8gSWYgdGhlIHJlc29sdmUgc2F5cyBzaGFyZWQgKGFuZCBoYXMgbm90IGJlZW4gb3ZlcnJpZGRlbilcbiAgICAgICAgLy8gV2Ugd2lsbCB0cnkgdG8gbWVyZ2UgYW5kIHNlZSBpZiB0aGVyZSBpcyBhIGNvbmZsaWN0XG5cbiAgICAgICAgbGVnZW5kc1tjaGFubmVsXSA9IG1lcmdlTGVnZW5kQ29tcG9uZW50KGxlZ2VuZHNbY2hhbm5lbF0sIGNoaWxkLmNvbXBvbmVudC5sZWdlbmRzW2NoYW5uZWxdKTtcblxuICAgICAgICBpZiAoIWxlZ2VuZHNbY2hhbm5lbF0pIHtcbiAgICAgICAgICAvLyBJZiBtZXJnZSByZXR1cm5zIG5vdGhpbmcsIHRoZXJlIGlzIGEgY29uZmxpY3Qgc28gd2UgY2Fubm90IG1ha2UgdGhlIGxlZ2VuZCBzaGFyZWQuXG4gICAgICAgICAgLy8gVGh1cywgbWFyayBsZWdlbmQgYXMgaW5kZXBlbmRlbnQgYW5kIHJlbW92ZSB0aGUgbGVnZW5kIGNvbXBvbmVudC5cbiAgICAgICAgICByZXNvbHZlLmxlZ2VuZFtjaGFubmVsXSA9ICdpbmRlcGVuZGVudCc7XG4gICAgICAgICAgZGVsZXRlIGxlZ2VuZHNbY2hhbm5lbF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIGtleXMobGVnZW5kcykuZm9yRWFjaCgoY2hhbm5lbDogTm9uUG9zaXRpb25TY2FsZUNoYW5uZWwpID0+IHtcbiAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG1vZGVsLmNoaWxkcmVuKSB7XG4gICAgICBpZiAoIWNoaWxkLmNvbXBvbmVudC5sZWdlbmRzW2NoYW5uZWxdKSB7XG4gICAgICAgIC8vIHNraXAgaWYgdGhlIGNoaWxkIGRvZXMgbm90IGhhdmUgYSBwYXJ0aWN1bGFyIGxlZ2VuZFxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc29sdmUubGVnZW5kW2NoYW5uZWxdID09PSAnc2hhcmVkJykge1xuICAgICAgICAvLyBBZnRlciBtZXJnaW5nIHNoYXJlZCBsZWdlbmQsIG1ha2Ugc3VyZSB0byByZW1vdmUgbGVnZW5kIGZyb20gY2hpbGRcbiAgICAgICAgZGVsZXRlIGNoaWxkLmNvbXBvbmVudC5sZWdlbmRzW2NoYW5uZWxdO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG4gIHJldHVybiBsZWdlbmRzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gbWVyZ2VMZWdlbmRDb21wb25lbnQobWVyZ2VkTGVnZW5kOiBMZWdlbmRDb21wb25lbnQsIGNoaWxkTGVnZW5kOiBMZWdlbmRDb21wb25lbnQpOiBMZWdlbmRDb21wb25lbnQge1xuICBpZiAoIW1lcmdlZExlZ2VuZCkge1xuICAgIHJldHVybiBjaGlsZExlZ2VuZC5jbG9uZSgpO1xuICB9XG4gIGNvbnN0IG1lcmdlZE9yaWVudCA9IG1lcmdlZExlZ2VuZC5nZXRXaXRoRXhwbGljaXQoJ29yaWVudCcpO1xuICBjb25zdCBjaGlsZE9yaWVudCA9IGNoaWxkTGVnZW5kLmdldFdpdGhFeHBsaWNpdCgnb3JpZW50Jyk7XG5cblxuICBpZiAobWVyZ2VkT3JpZW50LmV4cGxpY2l0ICYmIGNoaWxkT3JpZW50LmV4cGxpY2l0ICYmIG1lcmdlZE9yaWVudC52YWx1ZSAhPT0gY2hpbGRPcmllbnQudmFsdWUpIHtcbiAgICAvLyBUT0RPOiB0aHJvdyB3YXJuaW5nIGlmIHJlc29sdmUgaXMgZXhwbGljaXQgKFdlIGRvbid0IGhhdmUgaW5mbyBhYm91dCBleHBsaWNpdC9pbXBsaWNpdCByZXNvbHZlIHlldC4pXG4gICAgLy8gQ2Fubm90IG1lcmdlIGR1ZSB0byBpbmNvbnNpc3RlbnQgb3JpZW50XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxuICBsZXQgdHlwZU1lcmdlZCA9IGZhbHNlO1xuICAvLyBPdGhlcndpc2UsIGxldCdzIG1lcmdlXG4gIGZvciAoY29uc3QgcHJvcCBvZiBWR19MRUdFTkRfUFJPUEVSVElFUykge1xuICAgIGNvbnN0IG1lcmdlZFZhbHVlV2l0aEV4cGxpY2l0ID0gbWVyZ2VWYWx1ZXNXaXRoRXhwbGljaXQ8VmdMZWdlbmQsIGFueT4oXG4gICAgICBtZXJnZWRMZWdlbmQuZ2V0V2l0aEV4cGxpY2l0KHByb3ApLFxuICAgICAgY2hpbGRMZWdlbmQuZ2V0V2l0aEV4cGxpY2l0KHByb3ApLFxuICAgICAgcHJvcCwgJ2xlZ2VuZCcsXG5cbiAgICAgIC8vIFRpZSBicmVha2VyIGZ1bmN0aW9uXG4gICAgICAodjE6IEV4cGxpY2l0PGFueT4sIHYyOiBFeHBsaWNpdDxhbnk+KTogYW55ID0+IHtcbiAgICAgICAgc3dpdGNoIChwcm9wKSB7XG4gICAgICAgICAgY2FzZSAndGl0bGUnOlxuICAgICAgICAgICAgcmV0dXJuIG1lcmdlVGl0bGVDb21wb25lbnQodjEsIHYyKTtcbiAgICAgICAgICBjYXNlICd0eXBlJzpcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSBvbmx5IHR3byB0eXBlcy4gSWYgd2UgaGF2ZSBkaWZmZXJlbnQgdHlwZXMsIHRoZW4gcHJlZmVyIHN5bWJvbCBvdmVyIGdyYWRpZW50LlxuICAgICAgICAgICAgdHlwZU1lcmdlZCA9IHRydWU7XG4gICAgICAgICAgICByZXR1cm4gbWFrZUltcGxpY2l0KCdzeW1ib2wnKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdFRpZUJyZWFrZXI8VmdMZWdlbmQsIGFueT4odjEsIHYyLCBwcm9wLCAnbGVnZW5kJyk7XG4gICAgICB9XG4gICAgKTtcbiAgICBtZXJnZWRMZWdlbmQuc2V0V2l0aEV4cGxpY2l0KHByb3AsIG1lcmdlZFZhbHVlV2l0aEV4cGxpY2l0KTtcbiAgfVxuICBpZiAodHlwZU1lcmdlZCkge1xuICAgIGlmKCgobWVyZ2VkTGVnZW5kLmltcGxpY2l0IHx8IHt9KS5lbmNvZGUgfHwge30pLmdyYWRpZW50KSB7XG4gICAgICBkZWxldGVOZXN0ZWRQcm9wZXJ0eShtZXJnZWRMZWdlbmQuaW1wbGljaXQsIFsnZW5jb2RlJywgJ2dyYWRpZW50J10pO1xuICAgIH1cbiAgICBpZiAoKChtZXJnZWRMZWdlbmQuZXhwbGljaXQgfHwge30pLmVuY29kZSB8fCB7fSkuZ3JhZGllbnQpIHtcbiAgICAgIGRlbGV0ZU5lc3RlZFByb3BlcnR5KG1lcmdlZExlZ2VuZC5leHBsaWNpdCwgWydlbmNvZGUnLCAnZ3JhZGllbnQnXSk7XG4gICAgfVxuICB9XG5cblxuICByZXR1cm4gbWVyZ2VkTGVnZW5kO1xufVxuXG4iXX0=