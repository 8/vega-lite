/// <reference path="../../../typings/vega-event-selector.d.ts" />
import * as tslib_1 from "tslib";
import { selector as parseSelector } from 'vega-event-selector';
import { isString, stringValue } from 'vega-util';
import { X, Y } from '../../channel';
import { warn } from '../../log';
import { SELECTION_ID } from '../../selection';
import { accessPathWithDatum, logicalExpr, varName } from '../../util';
import { isFacetModel, isUnitModel } from '../model';
import intervalCompiler from './interval';
import multiCompiler from './multi';
import singleCompiler from './single';
import { forEachTransform } from './transforms/transforms';
export var STORE = '_store';
export var TUPLE = '_tuple';
export var MODIFY = '_modify';
export var SELECTION_DOMAIN = '_selection_domain_';
export function parseUnitSelection(model, selDefs) {
    var selCmpts = {};
    var selectionConfig = model.config.selection;
    var _loop_1 = function (name_1) {
        if (!selDefs.hasOwnProperty(name_1)) {
            return "continue";
        }
        var selDef = selDefs[name_1];
        var cfg = selectionConfig[selDef.type];
        // Set default values from config if a property hasn't been specified,
        // or if it is true. E.g., "translate": true should use the default
        // event handlers for translate. However, true may be a valid value for
        // a property (e.g., "nearest": true).
        for (var key in cfg) {
            // A selection should contain either `encodings` or `fields`, only use
            // default values for these two values if neither of them is specified.
            if ((key === 'encodings' && selDef.fields) || (key === 'fields' && selDef.encodings)) {
                continue;
            }
            if (key === 'mark') {
                selDef[key] = tslib_1.__assign({}, cfg[key], selDef[key]);
            }
            if (selDef[key] === undefined || selDef[key] === true) {
                selDef[key] = cfg[key] || selDef[key];
            }
        }
        name_1 = varName(name_1);
        var selCmpt = selCmpts[name_1] = tslib_1.__assign({}, selDef, { name: name_1, events: isString(selDef.on) ? parseSelector(selDef.on, 'scope') : selDef.on });
        forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.parse) {
                txCompiler.parse(model, selDef, selCmpt);
            }
        });
    };
    for (var name_1 in selDefs) {
        _loop_1(name_1);
    }
    return selCmpts;
}
export function assembleUnitSelectionSignals(model, signals) {
    forEachSelection(model, function (selCmpt, selCompiler) {
        var name = selCmpt.name;
        var modifyExpr = selCompiler.modifyExpr(model, selCmpt);
        signals.push.apply(signals, selCompiler.signals(model, selCmpt));
        forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.signals) {
                signals = txCompiler.signals(model, selCmpt, signals);
            }
            if (txCompiler.modifyExpr) {
                modifyExpr = txCompiler.modifyExpr(model, selCmpt, modifyExpr);
            }
        });
        signals.push({
            name: name + MODIFY,
            on: [{
                    events: { signal: name + TUPLE },
                    update: "modify(" + stringValue(selCmpt.name + STORE) + ", " + modifyExpr + ")"
                }]
        });
    });
    var facetModel = getFacetModel(model);
    if (signals.length && facetModel) {
        var name_2 = stringValue(facetModel.getName('cell'));
        signals.unshift({
            name: 'facet',
            value: {},
            on: [{
                    events: parseSelector('mousemove', 'scope'),
                    update: "isTuple(facet) ? facet : group(" + name_2 + ").datum"
                }]
        });
    }
    return signals;
}
export function assembleTopLevelSignals(model, signals) {
    var needsUnit = false;
    forEachSelection(model, function (selCmpt, selCompiler) {
        if (selCompiler.topLevelSignals) {
            signals = selCompiler.topLevelSignals(model, selCmpt, signals);
        }
        forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.topLevelSignals) {
                signals = txCompiler.topLevelSignals(model, selCmpt, signals);
            }
        });
        needsUnit = true;
    });
    if (needsUnit) {
        var hasUnit = signals.filter(function (s) { return s.name === 'unit'; });
        if (!(hasUnit.length)) {
            signals.unshift({
                name: 'unit',
                value: {},
                on: [{ events: 'mousemove', update: 'isTuple(group()) ? group() : unit' }]
            });
        }
    }
    return signals;
}
export function assembleUnitSelectionData(model, data) {
    forEachSelection(model, function (selCmpt) {
        var contains = data.filter(function (d) { return d.name === selCmpt.name + STORE; });
        if (!contains.length) {
            data.push({ name: selCmpt.name + STORE });
        }
    });
    return data;
}
export function assembleUnitSelectionMarks(model, marks) {
    forEachSelection(model, function (selCmpt, selCompiler) {
        marks = selCompiler.marks ? selCompiler.marks(model, selCmpt, marks) : marks;
        forEachTransform(selCmpt, function (txCompiler) {
            if (txCompiler.marks) {
                marks = txCompiler.marks(model, selCmpt, marks);
            }
        });
    });
    return marks;
}
export function assembleLayerSelectionMarks(model, marks) {
    model.children.forEach(function (child) {
        if (isUnitModel(child)) {
            marks = assembleUnitSelectionMarks(child, marks);
        }
    });
    return marks;
}
export function selectionPredicate(model, selections, dfnode) {
    var stores = [];
    function expr(name) {
        var vname = varName(name);
        var selCmpt = model.getSelectionComponent(vname, name);
        var store = stringValue(vname + STORE);
        if (selCmpt.timeUnit) {
            var child = dfnode || model.component.data.raw;
            var tunode = selCmpt.timeUnit.clone();
            if (child.parent) {
                tunode.insertAsParentOf(child);
            }
            else {
                child.parent = tunode;
            }
        }
        if (selCmpt.empty !== 'none') {
            stores.push(store);
        }
        return compiler(selCmpt.type).predicate + ("(" + store + ", datum") +
            (selCmpt.resolve === 'global' ? ')' : ", " + stringValue(selCmpt.resolve) + ")");
    }
    var predicateStr = logicalExpr(selections, expr);
    return (stores.length
        ? '!(' + stores.map(function (s) { return "length(data(" + s + "))"; }).join(' || ') + ') || '
        : '') + ("(" + predicateStr + ")");
}
// Selections are parsed _after_ scales. If a scale domain is set to
// use a selection, the SELECTION_DOMAIN constant is used as the
// domainRaw.signal during scale.parse and then replaced with the necessary
// selection expression function during scale.assemble. To not pollute the
// type signatures to account for this setup, the selection domain definition
// is coerced to a string and appended to SELECTION_DOMAIN.
export function isRawSelectionDomain(domainRaw) {
    return domainRaw.signal.indexOf(SELECTION_DOMAIN) >= 0;
}
export function selectionScaleDomain(model, domainRaw) {
    var selDomain = JSON.parse(domainRaw.signal.replace(SELECTION_DOMAIN, ''));
    var name = varName(selDomain.selection);
    var selCmpt = model.component.selection && model.component.selection[name];
    if (selCmpt) {
        warn('Use "bind": "scales" to setup a binding for scales and selections within the same view.');
    }
    else {
        selCmpt = model.getSelectionComponent(name, selDomain.selection);
        if (!selDomain.encoding && !selDomain.field) {
            selDomain.field = selCmpt.project[0].field;
            if (selCmpt.project.length > 1) {
                warn('A "field" or "encoding" must be specified when using a selection as a scale domain. ' +
                    ("Using \"field\": " + stringValue(selDomain.field) + "."));
            }
        }
        return {
            signal: compiler(selCmpt.type).scaleDomain +
                ("(" + stringValue(name + STORE) + ", " + stringValue(selDomain.encoding || null) + ", ") +
                stringValue(selDomain.field || null) +
                (selCmpt.resolve === 'global' ? ')' : ", " + stringValue(selCmpt.resolve) + ")")
        };
    }
    return { signal: 'null' };
}
// Utility functions
function forEachSelection(model, cb) {
    var selections = model.component.selection;
    for (var name_3 in selections) {
        if (selections.hasOwnProperty(name_3)) {
            var sel = selections[name_3];
            cb(sel, compiler(sel.type));
        }
    }
}
function compiler(type) {
    switch (type) {
        case 'single':
            return singleCompiler;
        case 'multi':
            return multiCompiler;
        case 'interval':
            return intervalCompiler;
    }
    return null;
}
function getFacetModel(model) {
    var parent = model.parent;
    while (parent) {
        if (isFacetModel(parent)) {
            break;
        }
        parent = parent.parent;
    }
    return parent;
}
export function unitName(model) {
    var name = stringValue(model.name);
    var facet = getFacetModel(model);
    if (facet) {
        name += (facet.facet.row ? " + '_' + (" + accessPathWithDatum(facet.vgField('row'), 'facet') + ")" : '')
            + (facet.facet.column ? " + '_' + (" + accessPathWithDatum(facet.vgField('column'), 'facet') + ")" : '');
    }
    return name;
}
export function requiresSelectionId(model) {
    var identifier = false;
    forEachSelection(model, function (selCmpt) {
        identifier = identifier || selCmpt.project.some(function (proj) { return proj.field === SELECTION_ID; });
    });
    return identifier;
}
export function channelSignalName(selCmpt, channel, range) {
    var sgNames = selCmpt._signalNames || (selCmpt._signalNames = {});
    if (sgNames[channel] && sgNames[channel][range]) {
        return sgNames[channel][range];
    }
    sgNames[channel] = sgNames[channel] || {};
    var basename = varName(selCmpt.name + '_' + (range === 'visual' ? channel : selCmpt.fields[channel]));
    var name = basename;
    var counter = 1;
    while (sgNames[name]) {
        name = basename + "_" + counter++;
    }
    return (sgNames[name] = sgNames[channel][range] = name);
}
export function positionalProjections(selCmpt) {
    var x = null;
    var xi = null;
    var y = null;
    var yi = null;
    selCmpt.project.forEach(function (p, i) {
        if (p.channel === X) {
            x = p;
            xi = i;
        }
        else if (p.channel === Y) {
            y = p;
            yi = i;
        }
    });
    return { x: x, xi: xi, y: y, yi: yi };
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2VsZWN0aW9uLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vLi4vc3JjL2NvbXBpbGUvc2VsZWN0aW9uL3NlbGVjdGlvbi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxrRUFBa0U7O0FBRWxFLE9BQU8sRUFBQyxRQUFRLElBQUksYUFBYSxFQUFDLE1BQU0scUJBQXFCLENBQUM7QUFDOUQsT0FBTyxFQUFDLFFBQVEsRUFBRSxXQUFXLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFDaEQsT0FBTyxFQUF3QixDQUFDLEVBQUUsQ0FBQyxFQUFDLE1BQU0sZUFBZSxDQUFDO0FBQzFELE9BQU8sRUFBQyxJQUFJLEVBQUMsTUFBTSxXQUFXLENBQUM7QUFFL0IsT0FBTyxFQUFjLFlBQVksRUFBbUQsTUFBTSxpQkFBaUIsQ0FBQztBQUM1RyxPQUFPLEVBQUMsbUJBQW1CLEVBQVEsV0FBVyxFQUFFLE9BQU8sRUFBQyxNQUFNLFlBQVksQ0FBQztBQU0zRSxPQUFPLEVBQUMsWUFBWSxFQUFFLFdBQVcsRUFBUSxNQUFNLFVBQVUsQ0FBQztBQUUxRCxPQUFPLGdCQUFnQixNQUFNLFlBQVksQ0FBQztBQUMxQyxPQUFPLGFBQWEsTUFBTSxTQUFTLENBQUM7QUFFcEMsT0FBTyxjQUFjLE1BQU0sVUFBVSxDQUFDO0FBQ3RDLE9BQU8sRUFBQyxnQkFBZ0IsRUFBQyxNQUFNLHlCQUF5QixDQUFDO0FBR3pELE1BQU0sQ0FBQyxJQUFNLEtBQUssR0FBRyxRQUFRLENBQUM7QUFDOUIsTUFBTSxDQUFDLElBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQztBQUM5QixNQUFNLENBQUMsSUFBTSxNQUFNLEdBQUcsU0FBUyxDQUFDO0FBQ2hDLE1BQU0sQ0FBQyxJQUFNLGdCQUFnQixHQUFHLG9CQUFvQixDQUFDO0FBdUNyRCxNQUFNLDZCQUE2QixLQUFnQixFQUFFLE9BQTJCO0lBQzlFLElBQU0sUUFBUSxHQUE2QixFQUFFLENBQUM7SUFDOUMsSUFBTSxlQUFlLEdBQUcs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dEIsT0FBTyxDQUFDLE9BQU8sQ0FBQyxPQUFPLENBQUMsVUFBQyxDQUFDLEVBQUUsQ0FBQztRQUMzQixJQUFJLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxFQUFFO1lBQ25CLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDTixFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQ1I7YUFBTSxJQUFJLENBQUMsQ0FBQyxPQUFPLEtBQUssQ0FBQyxFQUFFO1lBQzFCLENBQUMsR0FBRyxDQUFDLENBQUM7WUFDTixFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQ1I7SUFDSCxDQUFDLENBQUMsQ0FBQztJQUNILE9BQU8sRUFBQyxDQUFDLEdBQUEsRUFBRSxFQUFFLElBQUEsRUFBRSxDQUFDLEdBQUEsRUFBRSxFQUFFLElBQUEsRUFBQyxDQUFDO0FBQ3hCLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSBwYXRoPVwiLi4vLi4vLi4vdHlwaW5ncy92ZWdhLWV2ZW50LXNlbGVjdG9yLmQudHNcIiAvPlxuXG5pbXBvcnQge3NlbGVjdG9yIGFzIHBhcnNlU2VsZWN0b3J9IGZyb20gJ3ZlZ2EtZXZlbnQtc2VsZWN0b3InO1xuaW1wb3J0IHtpc1N0cmluZywgc3RyaW5nVmFsdWV9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5pbXBvcnQge0NoYW5uZWwsIFNjYWxlQ2hhbm5lbCwgWCwgWX0gZnJvbSAnLi4vLi4vY2hhbm5lbCc7XG5pbXBvcnQge3dhcm59IGZyb20gJy4uLy4uL2xvZyc7XG5pbXBvcnQge0xvZ2ljYWxPcGVyYW5kfSBmcm9tICcuLi8uLi9sb2dpY2FsJztcbmltcG9ydCB7QnJ1c2hDb25maWcsIFNFTEVDVElPTl9JRCwgU2VsZWN0aW9uRGVmLCBTZWxlY3Rpb25SZXNvbHV0aW9uLCBTZWxlY3Rpb25UeXBlfSBmcm9tICcuLi8uLi9zZWxlY3Rpb24nO1xuaW1wb3J0IHthY2Nlc3NQYXRoV2l0aERhdHVtLCBEaWN0LCBsb2dpY2FsRXhwciwgdmFyTmFtZX0gZnJvbSAnLi4vLi4vdXRpbCc7XG5pbXBvcnQge1ZnQmluZGluZywgVmdEYXRhLCBWZ0V2ZW50U3RyZWFtLCBWZ1NpZ25hbFJlZn0gZnJvbSAnLi4vLi4vdmVnYS5zY2hlbWEnO1xuaW1wb3J0IHtEYXRhRmxvd05vZGV9IGZyb20gJy4uL2RhdGEvZGF0YWZsb3cnO1xuaW1wb3J0IHtUaW1lVW5pdE5vZGV9IGZyb20gJy4uL2RhdGEvdGltZXVuaXQnO1xuaW1wb3J0IHtGYWNldE1vZGVsfSBmcm9tICcuLi9mYWNldCc7XG5pbXBvcnQge0xheWVyTW9kZWx9IGZyb20gJy4uL2xheWVyJztcbmltcG9ydCB7aXNGYWNldE1vZGVsLCBpc1VuaXRNb2RlbCwgTW9kZWx9IGZyb20gJy4uL21vZGVsJztcbmltcG9ydCB7VW5pdE1vZGVsfSBmcm9tICcuLi91bml0JztcbmltcG9ydCBpbnRlcnZhbENvbXBpbGVyIGZyb20gJy4vaW50ZXJ2YWwnO1xuaW1wb3J0IG11bHRpQ29tcGlsZXIgZnJvbSAnLi9tdWx0aSc7XG5pbXBvcnQge1NlbGVjdGlvbkNvbXBvbmVudH0gZnJvbSAnLi9zZWxlY3Rpb24nO1xuaW1wb3J0IHNpbmdsZUNvbXBpbGVyIGZyb20gJy4vc2luZ2xlJztcbmltcG9ydCB7Zm9yRWFjaFRyYW5zZm9ybX0gZnJvbSAnLi90cmFuc2Zvcm1zL3RyYW5zZm9ybXMnO1xuXG5cbmV4cG9ydCBjb25zdCBTVE9SRSA9ICdfc3RvcmUnO1xuZXhwb3J0IGNvbnN0IFRVUExFID0gJ190dXBsZSc7XG5leHBvcnQgY29uc3QgTU9ESUZZID0gJ19tb2RpZnknO1xuZXhwb3J0IGNvbnN0IFNFTEVDVElPTl9ET01BSU4gPSAnX3NlbGVjdGlvbl9kb21haW5fJztcblxuZXhwb3J0IGludGVyZmFjZSBTZWxlY3Rpb25Db21wb25lbnQge1xuICBuYW1lOiBzdHJpbmc7XG4gIHR5cGU6IFNlbGVjdGlvblR5cGU7XG4gIGV2ZW50czogVmdFdmVudFN0cmVhbTtcbiAgLy8gcHJlZGljYXRlPzogc3RyaW5nO1xuICBiaW5kPzogJ3NjYWxlcycgfCBWZ0JpbmRpbmcgfCB7W2tleTogc3RyaW5nXTogVmdCaW5kaW5nfTtcbiAgcmVzb2x2ZTogU2VsZWN0aW9uUmVzb2x1dGlvbjtcbiAgZW1wdHk6ICdhbGwnIHwgJ25vbmUnO1xuICBtYXJrPzogQnJ1c2hDb25maWc7XG5cbiAgX3NpZ25hbE5hbWVzOiB7fTtcblxuICAvLyBUcmFuc2Zvcm1zXG4gIHByb2plY3Q/OiBQcm9qZWN0Q29tcG9uZW50W107XG4gIGZpZWxkcz86IGFueTtcbiAgdGltZVVuaXQ/OiBUaW1lVW5pdE5vZGU7XG4gIHNjYWxlcz86IENoYW5uZWxbXTtcbiAgdG9nZ2xlPzogYW55O1xuICB0cmFuc2xhdGU/OiBhbnk7XG4gIHpvb20/OiBhbnk7XG4gIG5lYXJlc3Q/OiBhbnk7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgUHJvamVjdENvbXBvbmVudCB7XG4gIGZpZWxkPzogc3RyaW5nO1xuICBjaGFubmVsPzogU2NhbGVDaGFubmVsO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFNlbGVjdGlvbkNvbXBpbGVyIHtcbiAgc2lnbmFsczogKG1vZGVsOiBVbml0TW9kZWwsIHNlbENtcHQ6IFNlbGVjdGlvbkNvbXBvbmVudCkgPT4gYW55W107XG4gIHRvcExldmVsU2lnbmFscz86IChtb2RlbDogTW9kZWwsIHNlbENtcHQ6IFNlbGVjdGlvbkNvbXBvbmVudCwgc2lnbmFsczogYW55W10pID0+IGFueVtdO1xuICBtb2RpZnlFeHByOiAobW9kZWw6IFVuaXRNb2RlbCwgc2VsQ21wdDogU2VsZWN0aW9uQ29tcG9uZW50KSA9PiBzdHJpbmc7XG4gIG1hcmtzPzogKG1vZGVsOiBVbml0TW9kZWwsIHNlbENtcHQ6U2VsZWN0aW9uQ29tcG9uZW50LCBtYXJrczogYW55W10pID0+IGFueVtdO1xuICBwcmVkaWNhdGU6IHN0cmluZzsgIC8vIFZlZ2EgZXhwciBzdHJpbmcgdG8gZGV0ZXJtaW5lIGluY2x1c2lvbiBpbiBzZWxlY3Rpb24uXG4gIHNjYWxlRG9tYWluOiBzdHJpbmc7ICAvLyBWZWdhIGV4cHIgc3RyaW5nIHRvIG1hdGVyaWFsaXplIGEgc2NhbGUgZG9tYWluLlxufVxuXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVbml0U2VsZWN0aW9uKG1vZGVsOiBVbml0TW9kZWwsIHNlbERlZnM6IERpY3Q8U2VsZWN0aW9uRGVmPikge1xuICBjb25zdCBzZWxDbXB0czogRGljdDxTZWxlY3Rpb25Db21wb25lbnQ+ID0ge307XG4gIGNvbnN0IHNlbGVjdGlvbkNvbmZpZyA9IG1vZGVsLmNvbmZpZy5zZWxlY3Rpb247XG5cbiAgZm9yIChsZXQgbmFtZSBpbiBzZWxEZWZzKSB7XG4gICAgaWYgKCFzZWxEZWZzLmhhc093blByb3BlcnR5KG5hbWUpKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBjb25zdCBzZWxEZWYgPSBzZWxEZWZzW25hbWVdO1xuICAgIGNvbnN0IGNmZyA9IHNlbGVjdGlvbkNvbmZpZ1tzZWxEZWYudHlwZV07XG5cbiAgICAvLyBTZXQgZGVmYXVsdCB2YWx1ZXMgZnJvbSBjb25maWcgaWYgYSBwcm9wZXJ0eSBoYXNuJ3QgYmVlbiBzcGVjaWZpZWQsXG4gICAgLy8gb3IgaWYgaXQgaXMgdHJ1ZS4gRS5nLiwgXCJ0cmFuc2xhdGVcIjogdHJ1ZSBzaG91bGQgdXNlIHRoZSBkZWZhdWx0XG4gICAgLy8gZXZlbnQgaGFuZGxlcnMgZm9yIHRyYW5zbGF0ZS4gSG93ZXZlciwgdHJ1ZSBtYXkgYmUgYSB2YWxpZCB2YWx1ZSBmb3JcbiAgICAvLyBhIHByb3BlcnR5IChlLmcuLCBcIm5lYXJlc3RcIjogdHJ1ZSkuXG4gICAgZm9yIChjb25zdCBrZXkgaW4gY2ZnKSB7XG4gICAgICAvLyBBIHNlbGVjdGlvbiBzaG91bGQgY29udGFpbiBlaXRoZXIgYGVuY29kaW5nc2Agb3IgYGZpZWxkc2AsIG9ubHkgdXNlXG4gICAgICAvLyBkZWZhdWx0IHZhbHVlcyBmb3IgdGhlc2UgdHdvIHZhbHVlcyBpZiBuZWl0aGVyIG9mIHRoZW0gaXMgc3BlY2lmaWVkLlxuICAgICAgaWYgKChrZXkgPT09ICdlbmNvZGluZ3MnICYmIHNlbERlZi5maWVsZHMpIHx8IChrZXkgPT09ICdmaWVsZHMnICYmIHNlbERlZi5lbmNvZGluZ3MpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuXG4gICAgICBpZiAoa2V5ID09PSAnbWFyaycpIHtcbiAgICAgICAgc2VsRGVmW2tleV0gPSB7Li4uY2ZnW2tleV0sIC4uLnNlbERlZltrZXldfTtcbiAgICAgIH1cblxuICAgICAgaWYgKHNlbERlZltrZXldID09PSB1bmRlZmluZWQgfHwgc2VsRGVmW2tleV0gPT09IHRydWUpIHtcbiAgICAgICAgc2VsRGVmW2tleV0gPSBjZmdba2V5XSB8fCBzZWxEZWZba2V5XTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBuYW1lID0gdmFyTmFtZShuYW1lKTtcbiAgICBjb25zdCBzZWxDbXB0ID0gc2VsQ21wdHNbbmFtZV0gPSB7XG4gICAgICAuLi5zZWxEZWYsXG4gICAgICBuYW1lOiBuYW1lLFxuICAgICAgZXZlbnRzOiBpc1N0cmluZyhzZWxEZWYub24pID8gcGFyc2VTZWxlY3RvcihzZWxEZWYub24sICdzY29wZScpIDogc2VsRGVmLm9uLFxuICAgIH0gYXMgU2VsZWN0aW9uQ29tcG9uZW50O1xuXG4gICAgZm9yRWFjaFRyYW5zZm9ybShzZWxDbXB0LCB0eENvbXBpbGVyID0+IHtcbiAgICAgIGlmICh0eENvbXBpbGVyLnBhcnNlKSB7XG4gICAgICAgIHR4Q29tcGlsZXIucGFyc2UobW9kZWwsIHNlbERlZiwgc2VsQ21wdCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gc2VsQ21wdHM7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhc3NlbWJsZVVuaXRTZWxlY3Rpb25TaWduYWxzKG1vZGVsOiBVbml0TW9kZWwsIHNpZ25hbHM6IGFueVtdKSB7XG4gIGZvckVhY2hTZWxlY3Rpb24obW9kZWwsIChzZWxDbXB0LCBzZWxDb21waWxlcikgPT4ge1xuICAgIGNvbnN0IG5hbWUgPSBzZWxDbXB0Lm5hbWU7XG4gICAgbGV0IG1vZGlmeUV4cHIgPSBzZWxDb21waWxlci5tb2RpZnlFeHByKG1vZGVsLCBzZWxDbXB0KTtcblxuICAgIHNpZ25hbHMucHVzaC5hcHBseShzaWduYWxzLCBzZWxDb21waWxlci5zaWduYWxzKG1vZGVsLCBzZWxDbXB0KSk7XG5cbiAgICBmb3JFYWNoVHJhbnNmb3JtKHNlbENtcHQsIHR4Q29tcGlsZXIgPT4ge1xuICAgICAgaWYgKHR4Q29tcGlsZXIuc2lnbmFscykge1xuICAgICAgICBzaWduYWxzID0gdHhDb21waWxlci5zaWduYWxzKG1vZGVsLCBzZWxDbXB0LCBzaWduYWxzKTtcbiAgICAgIH1cbiAgICAgIGlmICh0eENvbXBpbGVyLm1vZGlmeUV4cHIpIHtcbiAgICAgICAgbW9kaWZ5RXhwciA9IHR4Q29tcGlsZXIubW9kaWZ5RXhwcihtb2RlbCwgc2VsQ21wdCwgbW9kaWZ5RXhwcik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBzaWduYWxzLnB1c2goe1xuICAgICAgbmFtZTogbmFtZSArIE1PRElGWSxcbiAgICAgIG9uOiBbe1xuICAgICAgICBldmVudHM6IHtzaWduYWw6IG5hbWUgKyBUVVBMRX0sXG4gICAgICAgIHVwZGF0ZTogYG1vZGlmeSgke3N0cmluZ1ZhbHVlKHNlbENtcHQubmFtZSArIFNUT1JFKX0sICR7bW9kaWZ5RXhwcn0pYFxuICAgICAgfV1cbiAgICB9KTtcbiAgfSk7XG5cbiAgY29uc3QgZmFjZXRNb2RlbCA9IGdldEZhY2V0TW9kZWwobW9kZWwpO1xuICBpZiAoc2lnbmFscy5sZW5ndGggJiYgZmFjZXRNb2RlbCkge1xuICAgIGNvbnN0IG5hbWUgPSBzdHJpbmdWYWx1ZShmYWNldE1vZGVsLmdldE5hbWUoJ2NlbGwnKSk7XG4gICAgc2lnbmFscy51bnNoaWZ0KHtcbiAgICAgIG5hbWU6ICdmYWNldCcsXG4gICAgICB2YWx1ZToge30sXG4gICAgICBvbjogW3tcbiAgICAgICAgZXZlbnRzOiBwYXJzZVNlbGVjdG9yKCdtb3VzZW1vdmUnLCAnc2NvcGUnKSxcbiAgICAgICAgdXBkYXRlOiBgaXNUdXBsZShmYWNldCkgPyBmYWNldCA6IGdyb3VwKCR7bmFtZX0pLmRhdHVtYFxuICAgICAgfV1cbiAgICB9KTtcbiAgfVxuXG4gIHJldHVybiBzaWduYWxzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZW1ibGVUb3BMZXZlbFNpZ25hbHMobW9kZWw6IFVuaXRNb2RlbCwgc2lnbmFsczogYW55W10pIHtcbiAgbGV0IG5lZWRzVW5pdCA9IGZhbHNlO1xuICBmb3JFYWNoU2VsZWN0aW9uKG1vZGVsLCAoc2VsQ21wdCwgc2VsQ29tcGlsZXIpID0+IHtcbiAgICBpZiAoc2VsQ29tcGlsZXIudG9wTGV2ZWxTaWduYWxzKSB7XG4gICAgICBzaWduYWxzID0gc2VsQ29tcGlsZXIudG9wTGV2ZWxTaWduYWxzKG1vZGVsLCBzZWxDbXB0LCBzaWduYWxzKTtcbiAgICB9XG5cbiAgICBmb3JFYWNoVHJhbnNmb3JtKHNlbENtcHQsIHR4Q29tcGlsZXIgPT4ge1xuICAgICAgaWYgKHR4Q29tcGlsZXIudG9wTGV2ZWxTaWduYWxzKSB7XG4gICAgICAgIHNpZ25hbHMgPSB0eENvbXBpbGVyLnRvcExldmVsU2lnbmFscyhtb2RlbCwgc2VsQ21wdCwgc2lnbmFscyk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBuZWVkc1VuaXQgPSB0cnVlO1xuICB9KTtcblxuICBpZiAobmVlZHNVbml0KSB7XG4gICAgY29uc3QgaGFzVW5pdCA9IHNpZ25hbHMuZmlsdGVyKChzKSA9PiBzLm5hbWUgPT09ICd1bml0Jyk7XG4gICAgaWYgKCEoaGFzVW5pdC5sZW5ndGgpKSB7XG4gICAgICBzaWduYWxzLnVuc2hpZnQoe1xuICAgICAgICBuYW1lOiAndW5pdCcsXG4gICAgICAgIHZhbHVlOiB7fSxcbiAgICAgICAgb246IFt7ZXZlbnRzOiAnbW91c2Vtb3ZlJywgdXBkYXRlOiAnaXNUdXBsZShncm91cCgpKSA/IGdyb3VwKCkgOiB1bml0J31dXG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc2lnbmFscztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VtYmxlVW5pdFNlbGVjdGlvbkRhdGEobW9kZWw6IFVuaXRNb2RlbCwgZGF0YTogVmdEYXRhW10pOiBWZ0RhdGFbXSB7XG4gIGZvckVhY2hTZWxlY3Rpb24obW9kZWwsIHNlbENtcHQgPT4ge1xuICAgIGNvbnN0IGNvbnRhaW5zID0gZGF0YS5maWx0ZXIoKGQpID0+IGQubmFtZSA9PT0gc2VsQ21wdC5uYW1lICsgU1RPUkUpO1xuICAgIGlmICghY29udGFpbnMubGVuZ3RoKSB7XG4gICAgICBkYXRhLnB1c2goe25hbWU6IHNlbENtcHQubmFtZSArIFNUT1JFfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VtYmxlVW5pdFNlbGVjdGlvbk1hcmtzKG1vZGVsOiBVbml0TW9kZWwsIG1hcmtzOiBhbnlbXSk6IGFueVtdIHtcbiAgZm9yRWFjaFNlbGVjdGlvbihtb2RlbCwgKHNlbENtcHQsIHNlbENvbXBpbGVyKSA9PiB7XG4gICAgbWFya3MgPSBzZWxDb21waWxlci5tYXJrcyA/IHNlbENvbXBpbGVyLm1hcmtzKG1vZGVsLCBzZWxDbXB0LCBtYXJrcykgOiBtYXJrcztcbiAgICBmb3JFYWNoVHJhbnNmb3JtKHNlbENtcHQsICh0eENvbXBpbGVyKSA9PiB7XG4gICAgICBpZiAodHhDb21waWxlci5tYXJrcykge1xuICAgICAgICBtYXJrcyA9IHR4Q29tcGlsZXIubWFya3MobW9kZWwsIHNlbENtcHQsIG1hcmtzKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgcmV0dXJuIG1hcmtzO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gYXNzZW1ibGVMYXllclNlbGVjdGlvbk1hcmtzKG1vZGVsOiBMYXllck1vZGVsLCBtYXJrczogYW55W10pOiBhbnlbXSB7XG4gIG1vZGVsLmNoaWxkcmVuLmZvckVhY2goY2hpbGQgPT4ge1xuICAgIGlmIChpc1VuaXRNb2RlbChjaGlsZCkpIHtcbiAgICAgIG1hcmtzID0gYXNzZW1ibGVVbml0U2VsZWN0aW9uTWFya3MoY2hpbGQsIG1hcmtzKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBtYXJrcztcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdGlvblByZWRpY2F0ZShtb2RlbDogTW9kZWwsIHNlbGVjdGlvbnM6IExvZ2ljYWxPcGVyYW5kPHN0cmluZz4sIGRmbm9kZT86IERhdGFGbG93Tm9kZSk6IHN0cmluZyB7XG4gIGNvbnN0IHN0b3Jlczogc3RyaW5nW10gPSBbXTtcbiAgZnVuY3Rpb24gZXhwcihuYW1lOiBzdHJpbmcpOiBzdHJpbmcge1xuICAgIGNvbnN0IHZuYW1lID0gdmFyTmFtZShuYW1lKTtcbiAgICBjb25zdCBzZWxDbXB0ID0gbW9kZWwuZ2V0U2VsZWN0aW9uQ29tcG9uZW50KHZuYW1lLCBuYW1lKTtcbiAgICBjb25zdCBzdG9yZSA9IHN0cmluZ1ZhbHVlKHZuYW1lICsgU1RPUkUpO1xuXG4gICAgaWYgKHNlbENtcHQudGltZVVuaXQpIHtcbiAgICAgIGNvbnN0IGNoaWxkID0gZGZub2RlIHx8IG1vZGVsLmNvbXBvbmVudC5kYXRhLnJhdztcbiAgICAgIGNvbnN0IHR1bm9kZSA9IHNlbENtcHQudGltZVVuaXQuY2xvbmUoKTtcbiAgICAgIGlmIChjaGlsZC5wYXJlbnQpIHtcbiAgICAgICAgdHVub2RlLmluc2VydEFzUGFyZW50T2YoY2hpbGQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gdHVub2RlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChzZWxDbXB0LmVtcHR5ICE9PSAnbm9uZScpIHtcbiAgICAgIHN0b3Jlcy5wdXNoKHN0b3JlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gY29tcGlsZXIoc2VsQ21wdC50eXBlKS5wcmVkaWNhdGUgKyBgKCR7c3RvcmV9LCBkYXR1bWAgK1xuICAgICAgKHNlbENtcHQucmVzb2x2ZSA9PT0gJ2dsb2JhbCcgPyAnKScgOiBgLCAke3N0cmluZ1ZhbHVlKHNlbENtcHQucmVzb2x2ZSl9KWApO1xuICB9XG5cbiAgY29uc3QgcHJlZGljYXRlU3RyID0gbG9naWNhbEV4cHIoc2VsZWN0aW9ucywgZXhwcik7XG4gIHJldHVybiAoc3RvcmVzLmxlbmd0aFxuICAgID8gJyEoJyArIHN0b3Jlcy5tYXAoKHMpID0+IGBsZW5ndGgoZGF0YSgke3N9KSlgKS5qb2luKCcgfHwgJykgKyAnKSB8fCAnXG4gICAgOiAnJ1xuICApICsgYCgke3ByZWRpY2F0ZVN0cn0pYDtcbn1cblxuLy8gU2VsZWN0aW9ucyBhcmUgcGFyc2VkIF9hZnRlcl8gc2NhbGVzLiBJZiBhIHNjYWxlIGRvbWFpbiBpcyBzZXQgdG9cbi8vIHVzZSBhIHNlbGVjdGlvbiwgdGhlIFNFTEVDVElPTl9ET01BSU4gY29uc3RhbnQgaXMgdXNlZCBhcyB0aGVcbi8vIGRvbWFpblJhdy5zaWduYWwgZHVyaW5nIHNjYWxlLnBhcnNlIGFuZCB0aGVuIHJlcGxhY2VkIHdpdGggdGhlIG5lY2Vzc2FyeVxuLy8gc2VsZWN0aW9uIGV4cHJlc3Npb24gZnVuY3Rpb24gZHVyaW5nIHNjYWxlLmFzc2VtYmxlLiBUbyBub3QgcG9sbHV0ZSB0aGVcbi8vIHR5cGUgc2lnbmF0dXJlcyB0byBhY2NvdW50IGZvciB0aGlzIHNldHVwLCB0aGUgc2VsZWN0aW9uIGRvbWFpbiBkZWZpbml0aW9uXG4vLyBpcyBjb2VyY2VkIHRvIGEgc3RyaW5nIGFuZCBhcHBlbmRlZCB0byBTRUxFQ1RJT05fRE9NQUlOLlxuZXhwb3J0IGZ1bmN0aW9uIGlzUmF3U2VsZWN0aW9uRG9tYWluKGRvbWFpblJhdzogVmdTaWduYWxSZWYpIHtcbiAgcmV0dXJuIGRvbWFpblJhdy5zaWduYWwuaW5kZXhPZihTRUxFQ1RJT05fRE9NQUlOKSA+PSAwO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlbGVjdGlvblNjYWxlRG9tYWluKG1vZGVsOiBNb2RlbCwgZG9tYWluUmF3OiBWZ1NpZ25hbFJlZik6IFZnU2lnbmFsUmVmIHtcbiAgY29uc3Qgc2VsRG9tYWluID0gSlNPTi5wYXJzZShkb21haW5SYXcuc2lnbmFsLnJlcGxhY2UoU0VMRUNUSU9OX0RPTUFJTiwgJycpKTtcbiAgY29uc3QgbmFtZSA9IHZhck5hbWUoc2VsRG9tYWluLnNlbGVjdGlvbik7XG5cbiAgbGV0IHNlbENtcHQgPSBtb2RlbC5jb21wb25lbnQuc2VsZWN0aW9uICYmIG1vZGVsLmNvbXBvbmVudC5zZWxlY3Rpb25bbmFtZV07XG4gIGlmIChzZWxDbXB0KSB7XG4gICAgd2FybignVXNlIFwiYmluZFwiOiBcInNjYWxlc1wiIHRvIHNldHVwIGEgYmluZGluZyBmb3Igc2NhbGVzIGFuZCBzZWxlY3Rpb25zIHdpdGhpbiB0aGUgc2FtZSB2aWV3LicpO1xuICB9IGVsc2Uge1xuICAgIHNlbENtcHQgPSBtb2RlbC5nZXRTZWxlY3Rpb25Db21wb25lbnQobmFtZSwgc2VsRG9tYWluLnNlbGVjdGlvbik7XG4gICAgaWYgKCFzZWxEb21haW4uZW5jb2RpbmcgJiYgIXNlbERvbWFpbi5maWVsZCkge1xuICAgICAgc2VsRG9tYWluLmZpZWxkID0gc2VsQ21wdC5wcm9qZWN0WzBdLmZpZWxkO1xuICAgICAgaWYgKHNlbENtcHQucHJvamVjdC5sZW5ndGggPiAxKSB7XG4gICAgICAgIHdhcm4oJ0EgXCJmaWVsZFwiIG9yIFwiZW5jb2RpbmdcIiBtdXN0IGJlIHNwZWNpZmllZCB3aGVuIHVzaW5nIGEgc2VsZWN0aW9uIGFzIGEgc2NhbGUgZG9tYWluLiAnICtcbiAgICAgICAgYFVzaW5nIFwiZmllbGRcIjogJHtzdHJpbmdWYWx1ZShzZWxEb21haW4uZmllbGQpfS5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNpZ25hbDogY29tcGlsZXIoc2VsQ21wdC50eXBlKS5zY2FsZURvbWFpbiArXG4gICAgICAgIGAoJHtzdHJpbmdWYWx1ZShuYW1lICsgU1RPUkUpfSwgJHtzdHJpbmdWYWx1ZShzZWxEb21haW4uZW5jb2RpbmcgfHwgbnVsbCl9LCBgICtcbiAgICAgICAgICBzdHJpbmdWYWx1ZShzZWxEb21haW4uZmllbGQgfHwgbnVsbCkgK1xuICAgICAgICAgIChzZWxDbXB0LnJlc29sdmUgPT09ICdnbG9iYWwnID8gJyknIDogYCwgJHtzdHJpbmdWYWx1ZShzZWxDbXB0LnJlc29sdmUpfSlgKVxuICAgIH07XG4gIH1cblxuICByZXR1cm4ge3NpZ25hbDogJ251bGwnfTtcbn1cblxuLy8gVXRpbGl0eSBmdW5jdGlvbnNcblxuZnVuY3Rpb24gZm9yRWFjaFNlbGVjdGlvbihtb2RlbDogTW9kZWwsIGNiOiAoc2VsQ21wdDogU2VsZWN0aW9uQ29tcG9uZW50LCBzZWxDb21waWxlcjogU2VsZWN0aW9uQ29tcGlsZXIpID0+IHZvaWQpIHtcbiAgY29uc3Qgc2VsZWN0aW9ucyA9IG1vZGVsLmNvbXBvbmVudC5zZWxlY3Rpb247XG4gIGZvciAoY29uc3QgbmFtZSBpbiBzZWxlY3Rpb25zKSB7XG4gICAgaWYgKHNlbGVjdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgIGNvbnN0IHNlbCA9IHNlbGVjdGlvbnNbbmFtZV07XG4gICAgICBjYihzZWwsIGNvbXBpbGVyKHNlbC50eXBlKSk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVyKHR5cGU6IFNlbGVjdGlvblR5cGUpOiBTZWxlY3Rpb25Db21waWxlciB7XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3NpbmdsZSc6XG4gICAgICByZXR1cm4gc2luZ2xlQ29tcGlsZXI7XG4gICAgY2FzZSAnbXVsdGknOlxuICAgICAgcmV0dXJuIG11bHRpQ29tcGlsZXI7XG4gICAgY2FzZSAnaW50ZXJ2YWwnOlxuICAgICAgcmV0dXJuIGludGVydmFsQ29tcGlsZXI7XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0TW9kZWwobW9kZWw6IE1vZGVsKTogRmFjZXRNb2RlbCB7XG4gIGxldCBwYXJlbnQgPSBtb2RlbC5wYXJlbnQ7XG4gIHdoaWxlIChwYXJlbnQpIHtcbiAgICBpZiAoaXNGYWNldE1vZGVsKHBhcmVudCkpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICB9XG5cbiAgcmV0dXJuIHBhcmVudCBhcyBGYWNldE1vZGVsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gdW5pdE5hbWUobW9kZWw6IE1vZGVsKSB7XG4gIGxldCBuYW1lID0gc3RyaW5nVmFsdWUobW9kZWwubmFtZSk7XG4gIGNvbnN0IGZhY2V0ID0gZ2V0RmFjZXRNb2RlbChtb2RlbCk7XG4gIGlmIChmYWNldCkge1xuICAgIG5hbWUgKz0gKGZhY2V0LmZhY2V0LnJvdyA/IGAgKyAnXycgKyAoJHthY2Nlc3NQYXRoV2l0aERhdHVtKGZhY2V0LnZnRmllbGQoJ3JvdycpLCAnZmFjZXQnKX0pYCA6ICcnKVxuICAgICAgKyAoZmFjZXQuZmFjZXQuY29sdW1uID8gYCArICdfJyArICgke2FjY2Vzc1BhdGhXaXRoRGF0dW0oZmFjZXQudmdGaWVsZCgnY29sdW1uJyksICdmYWNldCcpfSlgIDogJycpO1xuICB9XG4gIHJldHVybiBuYW1lO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gcmVxdWlyZXNTZWxlY3Rpb25JZChtb2RlbDogTW9kZWwpIHtcbiAgbGV0IGlkZW50aWZpZXIgPSBmYWxzZTtcbiAgZm9yRWFjaFNlbGVjdGlvbihtb2RlbCwgKHNlbENtcHQpID0+IHtcbiAgICBpZGVudGlmaWVyID0gaWRlbnRpZmllciB8fCBzZWxDbXB0LnByb2plY3Quc29tZSgocHJvaikgPT4gcHJvai5maWVsZCA9PT0gU0VMRUNUSU9OX0lEKTtcbiAgfSk7XG4gIHJldHVybiBpZGVudGlmaWVyO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gY2hhbm5lbFNpZ25hbE5hbWUoc2VsQ21wdDogU2VsZWN0aW9uQ29tcG9uZW50LCBjaGFubmVsOiBDaGFubmVsLCByYW5nZTogJ3Zpc3VhbCcgfCAnZGF0YScpIHtcbiAgY29uc3Qgc2dOYW1lcyA9IHNlbENtcHQuX3NpZ25hbE5hbWVzIHx8IChzZWxDbXB0Ll9zaWduYWxOYW1lcyA9IHt9KTtcbiAgaWYgKHNnTmFtZXNbY2hhbm5lbF0gJiYgc2dOYW1lc1tjaGFubmVsXVtyYW5nZV0pIHtcbiAgICByZXR1cm4gc2dOYW1lc1tjaGFubmVsXVtyYW5nZV07XG4gIH1cblxuICBzZ05hbWVzW2NoYW5uZWxdID0gc2dOYW1lc1tjaGFubmVsXSB8fCB7fTtcbiAgY29uc3QgYmFzZW5hbWUgPSB2YXJOYW1lKHNlbENtcHQubmFtZSArICdfJyArIChyYW5nZSA9PT0gJ3Zpc3VhbCcgPyBjaGFubmVsIDogc2VsQ21wdC5maWVsZHNbY2hhbm5lbF0pKTtcbiAgbGV0IG5hbWUgPSBiYXNlbmFtZTtcbiAgbGV0IGNvdW50ZXIgPSAxO1xuICB3aGlsZSAoc2dOYW1lc1tuYW1lXSkge1xuICAgIG5hbWUgPSBgJHtiYXNlbmFtZX1fJHtjb3VudGVyKyt9YDtcbiAgfVxuXG4gIHJldHVybiAoc2dOYW1lc1tuYW1lXSA9IHNnTmFtZXNbY2hhbm5lbF1bcmFuZ2VdID0gbmFtZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBwb3NpdGlvbmFsUHJvamVjdGlvbnMoc2VsQ21wdDogU2VsZWN0aW9uQ29tcG9uZW50KSB7XG4gIGxldCB4OlByb2plY3RDb21wb25lbnQgPSBudWxsO1xuICBsZXQgeGk6bnVtYmVyID0gbnVsbDtcbiAgbGV0IHk6UHJvamVjdENvbXBvbmVudCA9IG51bGw7XG4gIGxldCB5aTogbnVtYmVyID0gbnVsbDtcblxuICBzZWxDbXB0LnByb2plY3QuZm9yRWFjaCgocCwgaSkgPT4ge1xuICAgIGlmIChwLmNoYW5uZWwgPT09IFgpIHtcbiAgICAgIHggPSBwO1xuICAgICAgeGkgPSBpO1xuICAgIH0gZWxzZSBpZiAocC5jaGFubmVsID09PSBZKSB7XG4gICAgICB5ID0gcDtcbiAgICAgIHlpID0gaTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4ge3gsIHhpLCB5LCB5aX07XG59XG4iXX0=