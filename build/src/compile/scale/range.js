import { isNumber } from 'vega-util';
import { COLOR, FILL, OPACITY, SCALE_CHANNELS, SHAPE, SIZE, STROKE, X, Y } from '../../channel';
import * as log from '../../log';
import { channelScalePropertyIncompatability, isExtendedScheme, scaleTypeSupportProperty, } from '../../scale';
import { hasContinuousDomain } from '../../scale';
import * as util from '../../util';
import { isVgRangeStep } from '../../vega.schema';
import { isUnitModel } from '../model';
import { makeExplicit, makeImplicit } from '../split';
import { parseNonUnitScaleProperty } from './properties';
export var RANGE_PROPERTIES = ['range', 'rangeStep', 'scheme'];
export function parseScaleRange(model) {
    if (isUnitModel(model)) {
        parseUnitScaleRange(model);
    }
    else {
        parseNonUnitScaleProperty(model, 'range');
    }
}
function parseUnitScaleRange(model) {
    var localScaleComponents = model.component.scales;
    // use SCALE_CHANNELS instead of scales[channel] to ensure that x, y come first!
    SCALE_CHANNELS.forEach(function (channel) {
        var localScaleCmpt = localScaleComponents[channel];
        if (!localScaleCmpt) {
            return;
        }
        var mergedScaleCmpt = model.getScaleComponent(channel);
        var specifiedScale = model.specifiedScales[channel];
        var fieldDef = model.fieldDef(channel);
        // Read if there is a specified width/height
        var sizeType = channel === 'x' ? 'width' : channel === 'y' ? 'height' : undefined;
        var sizeSpecified = sizeType ? !!model.component.layoutSize.get(sizeType) : undefined;
        var scaleType = mergedScaleCmpt.get('type');
        // if autosize is fit, size cannot be data driven
        var rangeStep = util.contains(['point', 'band'], scaleType) || !!specifiedScale.rangeStep;
        if (sizeType && model.fit && !sizeSpecified && rangeStep) {
            log.warn(log.message.CANNOT_FIX_RANGE_STEP_WITH_FIT);
            sizeSpecified = true;
        }
        var xyRangeSteps = getXYRangeStep(model);
        var rangeWithExplicit = parseRangeForChannel(channel, scaleType, fieldDef.type, specifiedScale, model.config, localScaleCmpt.get('zero'), model.mark, sizeSpecified, model.getName(sizeType), xyRangeSteps);
        localScaleCmpt.setWithExplicit('range', rangeWithExplicit);
    });
}
function getXYRangeStep(model) {
    var xyRangeSteps = [];
    var xScale = model.getScaleComponent('x');
    var xRange = xScale && xScale.get('range');
    if (xRange && isVgRangeStep(xRange) && isNumber(xRange.step)) {
        xyRangeSteps.push(xRange.step);
    }
    var yScale = model.getScaleComponent('y');
    var yRange = yScale && yScale.get('range');
    if (yRange && isVgRangeStep(yRange) && isNumber(yRange.step)) {
        xyRangeSteps.push(yRange.step);
    }
    return xyRangeSteps;
}
/**
 * Return mixins that includes one of the range properties (range, rangeStep, scheme).
 */
export function parseRangeForChannel(channel, scaleType, type, specifiedScale, config, zero, mark, sizeSpecified, sizeSignal, xyRangeSteps) {
    var noRangeStep = sizeSpecified || specifiedScale.rangeStep === null;
    // Check if any of the range properties is specified.
    // If so, check if it is compatible and make sure that we only output one of the properties
    for (var _i = 0, RANGE_PROPERTIES_1 = RANGE_PROPERTIES; _i < RANGE_PROPERTIES_1.length; _i++) {
        var property = RANGE_PROPERTIES_1[_i];
        if (specifiedScale[property] !== undefined) {
            var supportedByScaleType = scaleTypeSupportProperty(scaleType, property);
            var channelIncompatability = channelScalePropertyIncompatability(channel, property);
            if (!supportedByScaleType) {
                log.warn(log.message.scalePropertyNotWorkWithScaleType(scaleType, property, channel));
            }
            else if (channelIncompatability) { // channel
                log.warn(channelIncompatability);
            }
            else {
                switch (property) {
                    case 'range':
                        return makeExplicit(specifiedScale[property]);
                    case 'scheme':
                        return makeExplicit(parseScheme(specifiedScale[property]));
                    case 'rangeStep':
                        var rangeStep = specifiedScale[property];
                        if (rangeStep !== null) {
                            if (!sizeSpecified) {
                                return makeExplicit({ step: rangeStep });
                            }
                            else {
                                // If top-level size is specified, we ignore specified rangeStep.
                                log.warn(log.message.rangeStepDropped(channel));
                            }
                        }
                }
            }
        }
    }
    return makeImplicit(defaultRange(channel, scaleType, type, config, zero, mark, sizeSignal, xyRangeSteps, noRangeStep));
}
function parseScheme(scheme) {
    if (isExtendedScheme(scheme)) {
        var r = { scheme: scheme.name };
        if (scheme.count) {
            r.count = scheme.count;
        }
        if (scheme.extent) {
            r.extent = scheme.extent;
        }
        return r;
    }
    return { scheme: scheme };
}
export function defaultRange(channel, scaleType, type, config, zero, mark, sizeSignal, xyRangeSteps, noRangeStep) {
    switch (channel) {
        case X:
        case Y:
            if (util.contains(['point', 'band'], scaleType) && !noRangeStep) {
                if (channel === X && mark === 'text') {
                    if (config.scale.textXRangeStep) {
                        return { step: config.scale.textXRangeStep };
                    }
                }
                else {
                    if (config.scale.rangeStep) {
                        return { step: config.scale.rangeStep };
                    }
                }
            }
            // If range step is null, use zero to width or height.
            // Note that these range signals are temporary
            // as they can be merged and renamed.
            // (We do not have the right size signal here since parseLayoutSize() happens after parseScale().)
            // We will later replace these temporary names with
            // the final name in assembleScaleRange()
            if (channel === Y && hasContinuousDomain(scaleType)) {
                // For y continuous scale, we have to start from the height as the bottom part has the max value.
                return [{ signal: sizeSignal }, 0];
            }
            else {
                return [0, { signal: sizeSignal }];
            }
        case SIZE:
            // TODO: support custom rangeMin, rangeMax
            var rangeMin = sizeRangeMin(mark, zero, config);
            var rangeMax = sizeRangeMax(mark, xyRangeSteps, config);
            return [rangeMin, rangeMax];
        case SHAPE:
            return 'symbol';
        case COLOR:
        case FILL:
        case STROKE:
            if (scaleType === 'ordinal') {
                // Only nominal data uses ordinal scale by default
                return type === 'nominal' ? 'category' : 'ordinal';
            }
            return mark === 'rect' || mark === 'geoshape' ? 'heatmap' : 'ramp';
        case OPACITY:
            // TODO: support custom rangeMin, rangeMax
            return [config.scale.minOpacity, config.scale.maxOpacity];
    }
    /* istanbul ignore next: should never reach here */
    throw new Error("Scale range undefined for channel " + channel);
}
function sizeRangeMin(mark, zero, config) {
    if (zero) {
        return 0;
    }
    switch (mark) {
        case 'bar':
        case 'tick':
            return config.scale.minBandSize;
        case 'line':
        case 'trail':
        case 'rule':
            return config.scale.minStrokeWidth;
        case 'text':
            return config.scale.minFontSize;
        case 'point':
        case 'square':
        case 'circle':
            return config.scale.minSize;
    }
    /* istanbul ignore next: should never reach here */
    // sizeRangeMin not implemented for the mark
    throw new Error(log.message.incompatibleChannel('size', mark));
}
function sizeRangeMax(mark, xyRangeSteps, config) {
    var scaleConfig = config.scale;
    switch (mark) {
        case 'bar':
        case 'tick':
            if (config.scale.maxBandSize !== undefined) {
                return config.scale.maxBandSize;
            }
            return minXYRangeStep(xyRangeSteps, config.scale) - 1;
        case 'line':
        case 'trail':
        case 'rule':
            return config.scale.maxStrokeWidth;
        case 'text':
            return config.scale.maxFontSize;
        case 'point':
        case 'square':
        case 'circle':
            if (config.scale.maxSize) {
                return config.scale.maxSize;
            }
            // FIXME this case totally should be refactored
            var pointStep = minXYRangeStep(xyRangeSteps, scaleConfig);
            return (pointStep - 2) * (pointStep - 2);
    }
    /* istanbul ignore next: should never reach here */
    // sizeRangeMax not implemented for the mark
    throw new Error(log.message.incompatibleChannel('size', mark));
}
/**
 * @returns {number} Range step of x or y or minimum between the two if both are ordinal scale.
 */
function minXYRangeStep(xyRangeSteps, scaleConfig) {
    if (xyRangeSteps.length > 0) {
        return Math.min.apply(null, xyRangeSteps);
    }
    if (scaleConfig.rangeStep) {
        return scaleConfig.rangeStep;
    }
    return 21; // FIXME: re-evaluate the default value here.
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmFuZ2UuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9zcmMvY29tcGlsZS9zY2FsZS9yYW5nZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUMsUUFBUSxFQUFDLE1BQU0sV0FBVyxDQUFDO0FBRW5DLE9BQU8sRUFBVSxLQUFLLEVBQUUsSUFBSSxFQUFFLE9BQU8sRUFBRSxjQUFjLEVBQWdCLEtBQUssRUFBRSxJQUFJLEVBQUUsTUFBTSxFQUFFLENBQUMsRUFBRSxDQUFDLEVBQUMsTUFBTSxlQUFlLENBQUM7QUFFckgsT0FBTyxLQUFLLEdBQUcsTUFBTSxXQUFXLENBQUM7QUFFakMsT0FBTyxFQUNMLG1DQUFtQyxFQUNuQyxnQkFBZ0IsRUFLaEIsd0JBQXdCLEdBRXpCLE1BQU0sYUFBYSxDQUFDO0FBQ3JCLE9BQU8sRUFBQyxtQkFBbUIsRUFBQyxNQUFNLGFBQWEsQ0FBQztBQUVoRCxPQUFPLEtBQUssSUFBSSxNQUFNLFlBQVksQ0FBQztBQUNuQyxPQUFPLEVBQUMsYUFBYSxFQUFvQixNQUFNLG1CQUFtQixDQUFDO0FBQ25FLE9BQU8sRUFBQyxXQUFXLEVBQVEsTUFBTSxVQUFVLENBQUM7QUFDNUMsT0FBTyxFQUFXLFlBQVksRUFBRSxZQUFZLEVBQUMsTUFBTSxVQUFVLENBQUM7QUFHOUQsT0FBTyxFQUFDLHlCQUF5QixFQUFDLE1BQU0sY0FBYyxDQUFDO0FBS3ZELE1BQU0sQ0FBQyxJQUFNLGdCQUFnQixHQUFvQixDQUFDLE9BQU8sRUFBRSxXQUFXLEVBQUUsUUFBUSxDQUFDLENBQUM7QUFHbEYsTUFBTSwwQkFBMEIsS0FBWTtJQUMxQyxJQUFJLFdBQVcsQ0FBQyxLQUFLLENBQUMsRUFBRTtRQUN0QixtQkFBbUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztLQUM1QjtTQUFNO1FBQ0wseUJBQXlCLENBQUMsS0FBSyxFQUFFLE9BQU8sQ0FBQyxDQUFDO0tBQzNDO0FBQ0gsQ0FBQztBQUVELDZCQUE2QixLQUFn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Qy9DLElBQU0sU0FBUyxHQUFHLGNBQWMsQ0FBQyxZQUFZLEVBQUUsV0FBVyxDQUFDLENBQUM7WUFDNUQsT0FBTyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsR0FBRyxDQUFDLFNBQVMsR0FBRyxDQUFDLENBQUMsQ0FBQztLQUM1QztJQUNELG1EQUFtRDtJQUNuRCw0Q0FBNEM7SUFDNUMsTUFBTSxJQUFJLEtBQUssQ0FBQyxHQUFHLENBQUMsT0FBTyxDQUFDLG1CQUFtQixDQUFDLE1BQU0sRUFBRSxJQUFJLENBQUMsQ0FBQyxDQUFDO0FBQ2pFLENBQUM7QUFFRDs7R0FFRztBQUNILHdCQUF3QixZQUFzQixFQUFFLFdBQXdCO0lBQ3RFLElBQUksWUFBWSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDM0IsT0FBTyxJQUFJLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxJQUFJLEVBQUUsWUFBWSxDQUFDLENBQUM7S0FDM0M7SUFDRCxJQUFJLFdBQVcsQ0FBQyxTQUFTLEVBQUU7UUFDekIsT0FBTyxXQUFXLENBQUMsU0FBUyxDQUFDO0tBQzlCO0lBQ0QsT0FBTyxFQUFFLENBQUMsQ0FBQyw2Q0FBNkM7QUFDMUQsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7aXNOdW1iZXJ9IGZyb20gJ3ZlZ2EtdXRpbCc7XG5cbmltcG9ydCB7Q2hhbm5lbCwgQ09MT1IsIEZJTEwsIE9QQUNJVFksIFNDQUxFX0NIQU5ORUxTLCBTY2FsZUNoYW5uZWwsIFNIQVBFLCBTSVpFLCBTVFJPS0UsIFgsIFl9IGZyb20gJy4uLy4uL2NoYW5uZWwnO1xuaW1wb3J0IHtDb25maWd9IGZyb20gJy4uLy4uL2NvbmZpZyc7XG5pbXBvcnQgKiBhcyBsb2cgZnJvbSAnLi4vLi4vbG9nJztcbmltcG9ydCB7TWFya30gZnJvbSAnLi4vLi4vbWFyayc7XG5pbXBvcnQge1xuICBjaGFubmVsU2NhbGVQcm9wZXJ0eUluY29tcGF0YWJpbGl0eSxcbiAgaXNFeHRlbmRlZFNjaGVtZSxcbiAgUmFuZ2UsXG4gIFNjYWxlLFxuICBTY2FsZUNvbmZpZyxcbiAgU2NhbGVUeXBlLFxuICBzY2FsZVR5cGVTdXBwb3J0UHJvcGVydHksXG4gIFNjaGVtZSxcbn0gZnJvbSAnLi4vLi4vc2NhbGUnO1xuaW1wb3J0IHtoYXNDb250aW51b3VzRG9tYWlufSBmcm9tICcuLi8uLi9zY2FsZSc7XG5pbXBvcnQge1R5cGV9IGZyb20gJy4uLy4uL3R5cGUnO1xuaW1wb3J0ICogYXMgdXRpbCBmcm9tICcuLi8uLi91dGlsJztcbmltcG9ydCB7aXNWZ1JhbmdlU3RlcCwgVmdSYW5nZSwgVmdTY2hlbWV9IGZyb20gJy4uLy4uL3ZlZ2Euc2NoZW1hJztcbmltcG9ydCB7aXNVbml0TW9kZWwsIE1vZGVsfSBmcm9tICcuLi9tb2RlbCc7XG5pbXBvcnQge0V4cGxpY2l0LCBtYWtlRXhwbGljaXQsIG1ha2VJbXBsaWNpdH0gZnJvbSAnLi4vc3BsaXQnO1xuaW1wb3J0IHtVbml0TW9kZWx9IGZyb20gJy4uL3VuaXQnO1xuaW1wb3J0IHtTY2FsZUNvbXBvbmVudEluZGV4fSBmcm9tICcuL2NvbXBvbmVudCc7XG5pbXBvcnQge3BhcnNlTm9uVW5pdFNjYWxlUHJvcGVydHl9IGZyb20gJy4vcHJvcGVydGllcyc7XG5cblxuZXhwb3J0IHR5cGUgUmFuZ2VNaXhpbnMgPSB7cmFuZ2U6IFJhbmdlfSB8IHtyYW5nZVN0ZXA6IG51bWJlcn0gfCB7c2NoZW1lOiBTY2hlbWV9O1xuXG5leHBvcnQgY29uc3QgUkFOR0VfUFJPUEVSVElFUzogKGtleW9mIFNjYWxlKVtdID0gWydyYW5nZScsICdyYW5nZVN0ZXAnLCAnc2NoZW1lJ107XG5cblxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlU2NhbGVSYW5nZShtb2RlbDogTW9kZWwpIHtcbiAgaWYgKGlzVW5pdE1vZGVsKG1vZGVsKSkge1xuICAgIHBhcnNlVW5pdFNjYWxlUmFuZ2UobW9kZWwpO1xuICB9IGVsc2Uge1xuICAgIHBhcnNlTm9uVW5pdFNjYWxlUHJvcGVydHkobW9kZWwsICdyYW5nZScpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlVW5pdFNjYWxlUmFuZ2UobW9kZWw6IFVuaXRNb2RlbCkge1xuICBjb25zdCBsb2NhbFNjYWxlQ29tcG9uZW50czogU2NhbGVDb21wb25lbnRJbmRleCA9IG1vZGVsLmNvbXBvbmVudC5zY2FsZXM7XG5cbiAgLy8gdXNlIFNDQUxFX0NIQU5ORUxTIGluc3RlYWQgb2Ygc2NhbGVzW2NoYW5uZWxdIHRvIGVuc3VyZSB0aGF0IHgsIHkgY29tZSBmaXJzdCFcbiAgU0NBTEVfQ0hBTk5FTFMuZm9yRWFjaCgoY2hhbm5lbDogU2NhbGVDaGFubmVsKSA9PiB7XG4gICAgY29uc3QgbG9jYWxTY2FsZUNtcHQgPSBsb2NhbFNjYWxlQ29tcG9uZW50c1tjaGFubmVsXTtcbiAgICBpZiAoIWxvY2FsU2NhbGVDbXB0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZFNjYWxlQ21wdCA9IG1vZGVsLmdldFNjYWxlQ29tcG9uZW50KGNoYW5uZWwpO1xuXG5cbiAgICBjb25zdCBzcGVjaWZpZWRTY2FsZSA9IG1vZGVsLnNwZWNpZmllZFNjYWxlc1tjaGFubmVsXTtcbiAgICBjb25zdCBmaWVsZERlZiA9IG1vZGVsLmZpZWxkRGVmKGNoYW5uZWwpO1xuXG4gICAgLy8gUmVhZCBpZiB0aGVyZSBpcyBhIHNwZWNpZmllZCB3aWR0aC9oZWlnaHRcbiAgICBjb25zdCBzaXplVHlwZSA9IGNoYW5uZWwgPT09ICd4JyA/ICd3aWR0aCcgOiBjaGFubmVsID09PSAneScgPyAnaGVpZ2h0JyA6IHVuZGVmaW5lZDtcbiAgICBsZXQgc2l6ZVNwZWNpZmllZCA9IHNpemVUeXBlID8gISFtb2RlbC5jb21wb25lbnQubGF5b3V0U2l6ZS5nZXQoc2l6ZVR5cGUpIDogdW5kZWZpbmVkO1xuXG4gICAgY29uc3Qgc2NhbGVUeXBlID0gbWVyZ2VkU2NhbGVDbXB0LmdldCgndHlwZScpO1xuXG4gICAgLy8gaWYgYXV0b3NpemUgaXMgZml0LCBzaXplIGNhbm5vdCBiZSBkYXRhIGRyaXZlblxuICAgIGNvbnN0IHJhbmdlU3RlcCA9IHV0aWwuY29udGFpbnMoWydwb2ludCcsICdiYW5kJ10sIHNjYWxlVHlwZSkgfHwgISFzcGVjaWZpZWRTY2FsZS5yYW5nZVN0ZXA7XG4gICAgaWYgKHNpemVUeXBlICYmIG1vZGVsLmZpdCAmJiAhc2l6ZVNwZWNpZmllZCAmJiByYW5nZVN0ZXApIHtcbiAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLkNBTk5PVF9GSVhfUkFOR0VfU1RFUF9XSVRIX0ZJVCk7XG4gICAgICBzaXplU3BlY2lmaWVkID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBjb25zdCB4eVJhbmdlU3RlcHMgPSBnZXRYWVJhbmdlU3RlcChtb2RlbCk7XG5cbiAgICBjb25zdCByYW5nZVdpdGhFeHBsaWNpdCA9IHBhcnNlUmFuZ2VGb3JDaGFubmVsKFxuICAgICAgY2hhbm5lbCwgc2NhbGVUeXBlLCBmaWVsZERlZi50eXBlLCBzcGVjaWZpZWRTY2FsZSwgbW9kZWwuY29uZmlnLFxuICAgICAgbG9jYWxTY2FsZUNtcHQuZ2V0KCd6ZXJvJyksIG1vZGVsLm1hcmssIHNpemVTcGVjaWZpZWQsIG1vZGVsLmdldE5hbWUoc2l6ZVR5cGUpLCB4eVJhbmdlU3RlcHNcbiAgICApO1xuXG4gICAgbG9jYWxTY2FsZUNtcHQuc2V0V2l0aEV4cGxpY2l0KCdyYW5nZScsIHJhbmdlV2l0aEV4cGxpY2l0KTtcbiAgfSk7XG59XG5cbmZ1bmN0aW9uIGdldFhZUmFuZ2VTdGVwKG1vZGVsOiBVbml0TW9kZWwpIHtcbiAgY29uc3QgeHlSYW5nZVN0ZXBzOiBudW1iZXJbXSA9IFtdO1xuXG4gIGNvbnN0IHhTY2FsZSA9IG1vZGVsLmdldFNjYWxlQ29tcG9uZW50KCd4Jyk7XG4gIGNvbnN0IHhSYW5nZSA9IHhTY2FsZSAmJiB4U2NhbGUuZ2V0KCdyYW5nZScpO1xuICBpZiAoeFJhbmdlICYmIGlzVmdSYW5nZVN0ZXAoeFJhbmdlKSAmJiBpc051bWJlcih4UmFuZ2Uuc3RlcCkpIHtcbiAgICB4eVJhbmdlU3RlcHMucHVzaCh4UmFuZ2Uuc3RlcCk7XG4gIH1cblxuICBjb25zdCB5U2NhbGUgPSBtb2RlbC5nZXRTY2FsZUNvbXBvbmVudCgneScpO1xuICBjb25zdCB5UmFuZ2UgPSB5U2NhbGUgJiYgeVNjYWxlLmdldCgncmFuZ2UnKTtcbiAgaWYgKHlSYW5nZSAmJiBpc1ZnUmFuZ2VTdGVwKHlSYW5nZSkgJiYgaXNOdW1iZXIoeVJhbmdlLnN0ZXApKSB7XG4gICAgeHlSYW5nZVN0ZXBzLnB1c2goeVJhbmdlLnN0ZXApO1xuICB9XG5cbiAgcmV0dXJuIHh5UmFuZ2VTdGVwcztcbn1cblxuLyoqXG4gKiBSZXR1cm4gbWl4aW5zIHRoYXQgaW5jbHVkZXMgb25lIG9mIHRoZSByYW5nZSBwcm9wZXJ0aWVzIChyYW5nZSwgcmFuZ2VTdGVwLCBzY2hlbWUpLlxuICovXG5leHBvcnQgZnVuY3Rpb24gcGFyc2VSYW5nZUZvckNoYW5uZWwoXG4gICAgY2hhbm5lbDogQ2hhbm5lbCwgc2NhbGVUeXBlOiBTY2FsZVR5cGUsIHR5cGU6IFR5cGUsIHNwZWNpZmllZFNjYWxlOiBTY2FsZSwgY29uZmlnOiBDb25maWcsXG4gICAgemVybzogYm9vbGVhbiwgbWFyazogTWFyaywgc2l6ZVNwZWNpZmllZDogYm9vbGVhbiwgc2l6ZVNpZ25hbDogc3RyaW5nLCB4eVJhbmdlU3RlcHM6IG51bWJlcltdXG4gICk6IEV4cGxpY2l0PFZnUmFuZ2U+IHtcblxuICBjb25zdCBub1JhbmdlU3RlcCA9IHNpemVTcGVjaWZpZWQgfHwgc3BlY2lmaWVkU2NhbGUucmFuZ2VTdGVwID09PSBudWxsO1xuXG4gIC8vIENoZWNrIGlmIGFueSBvZiB0aGUgcmFuZ2UgcHJvcGVydGllcyBpcyBzcGVjaWZpZWQuXG4gIC8vIElmIHNvLCBjaGVjayBpZiBpdCBpcyBjb21wYXRpYmxlIGFuZCBtYWtlIHN1cmUgdGhhdCB3ZSBvbmx5IG91dHB1dCBvbmUgb2YgdGhlIHByb3BlcnRpZXNcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBvZiBSQU5HRV9QUk9QRVJUSUVTKSB7XG4gICAgaWYgKHNwZWNpZmllZFNjYWxlW3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb25zdCBzdXBwb3J0ZWRCeVNjYWxlVHlwZSA9IHNjYWxlVHlwZVN1cHBvcnRQcm9wZXJ0eShzY2FsZVR5cGUsIHByb3BlcnR5KTtcbiAgICAgIGNvbnN0IGNoYW5uZWxJbmNvbXBhdGFiaWxpdHkgPSBjaGFubmVsU2NhbGVQcm9wZXJ0eUluY29tcGF0YWJpbGl0eShjaGFubmVsLCBwcm9wZXJ0eSk7XG4gICAgICBpZiAoIXN1cHBvcnRlZEJ5U2NhbGVUeXBlKSB7XG4gICAgICAgIGxvZy53YXJuKGxvZy5tZXNzYWdlLnNjYWxlUHJvcGVydHlOb3RXb3JrV2l0aFNjYWxlVHlwZShzY2FsZVR5cGUsIHByb3BlcnR5LCBjaGFubmVsKSk7XG4gICAgICB9IGVsc2UgaWYgKGNoYW5uZWxJbmNvbXBhdGFiaWxpdHkpIHsgLy8gY2hhbm5lbFxuICAgICAgICBsb2cud2FybihjaGFubmVsSW5jb21wYXRhYmlsaXR5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN3aXRjaCAocHJvcGVydHkpIHtcbiAgICAgICAgICBjYXNlICdyYW5nZSc6XG4gICAgICAgICAgICByZXR1cm4gbWFrZUV4cGxpY2l0KHNwZWNpZmllZFNjYWxlW3Byb3BlcnR5XSk7XG4gICAgICAgICAgY2FzZSAnc2NoZW1lJzpcbiAgICAgICAgICAgIHJldHVybiBtYWtlRXhwbGljaXQocGFyc2VTY2hlbWUoc3BlY2lmaWVkU2NhbGVbcHJvcGVydHldKSk7XG4gICAgICAgICAgY2FzZSAncmFuZ2VTdGVwJzpcbiAgICAgICAgICAgIGNvbnN0IHJhbmdlU3RlcCA9IHNwZWNpZmllZFNjYWxlW3Byb3BlcnR5XTtcbiAgICAgICAgICAgIGlmIChyYW5nZVN0ZXAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKCFzaXplU3BlY2lmaWVkKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG1ha2VFeHBsaWNpdCh7c3RlcDogcmFuZ2VTdGVwfSk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdG9wLWxldmVsIHNpemUgaXMgc3BlY2lmaWVkLCB3ZSBpZ25vcmUgc3BlY2lmaWVkIHJhbmdlU3RlcC5cbiAgICAgICAgICAgICAgICBsb2cud2Fybihsb2cubWVzc2FnZS5yYW5nZVN0ZXBEcm9wcGVkKGNoYW5uZWwpKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtYWtlSW1wbGljaXQoXG4gICAgZGVmYXVsdFJhbmdlKFxuICAgICAgY2hhbm5lbCwgc2NhbGVUeXBlLCB0eXBlLCBjb25maWcsXG4gICAgICB6ZXJvLCBtYXJrLCBzaXplU2lnbmFsLCB4eVJhbmdlU3RlcHMsIG5vUmFuZ2VTdGVwXG4gICAgKVxuICApO1xufVxuXG5mdW5jdGlvbiBwYXJzZVNjaGVtZShzY2hlbWU6IFNjaGVtZSkge1xuICBpZiAoaXNFeHRlbmRlZFNjaGVtZShzY2hlbWUpKSB7XG4gICAgY29uc3QgcjogVmdTY2hlbWUgPSB7c2NoZW1lOiBzY2hlbWUubmFtZX07XG4gICAgaWYgKHNjaGVtZS5jb3VudCkge1xuICAgICAgci5jb3VudCA9IHNjaGVtZS5jb3VudDtcbiAgICB9XG4gICAgaWYgKHNjaGVtZS5leHRlbnQpIHtcbiAgICAgIHIuZXh0ZW50ID0gc2NoZW1lLmV4dGVudDtcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH1cbiAgcmV0dXJuIHtzY2hlbWU6IHNjaGVtZX07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBkZWZhdWx0UmFuZ2UoXG4gIGNoYW5uZWw6IENoYW5uZWwsIHNjYWxlVHlwZTogU2NhbGVUeXBlLCB0eXBlOiBUeXBlLCBjb25maWc6IENvbmZpZywgemVybzogYm9vbGVhbiwgbWFyazogTWFyayxcbiAgc2l6ZVNpZ25hbDogc3RyaW5nLCB4eVJhbmdlU3RlcHM6IG51bWJlcltdLCBub1JhbmdlU3RlcDogYm9vbGVhblxuKTogVmdSYW5nZSB7XG4gIHN3aXRjaCAoY2hhbm5lbCkge1xuICAgIGNhc2UgWDpcbiAgICBjYXNlIFk6XG4gICAgICBpZiAodXRpbC5jb250YWlucyhbJ3BvaW50JywgJ2JhbmQnXSwgc2NhbGVUeXBlKSAmJiAhbm9SYW5nZVN0ZXApIHtcbiAgICAgICAgaWYgKGNoYW5uZWwgPT09IFggJiYgbWFyayA9PT0gJ3RleHQnKSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy5zY2FsZS50ZXh0WFJhbmdlU3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGVwOiBjb25maWcuc2NhbGUudGV4dFhSYW5nZVN0ZXB9O1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoY29uZmlnLnNjYWxlLnJhbmdlU3RlcCkge1xuICAgICAgICAgICAgcmV0dXJuIHtzdGVwOiBjb25maWcuc2NhbGUucmFuZ2VTdGVwfTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSWYgcmFuZ2Ugc3RlcCBpcyBudWxsLCB1c2UgemVybyB0byB3aWR0aCBvciBoZWlnaHQuXG4gICAgICAvLyBOb3RlIHRoYXQgdGhlc2UgcmFuZ2Ugc2lnbmFscyBhcmUgdGVtcG9yYXJ5XG4gICAgICAvLyBhcyB0aGV5IGNhbiBiZSBtZXJnZWQgYW5kIHJlbmFtZWQuXG4gICAgICAvLyAoV2UgZG8gbm90IGhhdmUgdGhlIHJpZ2h0IHNpemUgc2lnbmFsIGhlcmUgc2luY2UgcGFyc2VMYXlvdXRTaXplKCkgaGFwcGVucyBhZnRlciBwYXJzZVNjYWxlKCkuKVxuICAgICAgLy8gV2Ugd2lsbCBsYXRlciByZXBsYWNlIHRoZXNlIHRlbXBvcmFyeSBuYW1lcyB3aXRoXG4gICAgICAvLyB0aGUgZmluYWwgbmFtZSBpbiBhc3NlbWJsZVNjYWxlUmFuZ2UoKVxuXG4gICAgICBpZiAoY2hhbm5lbCA9PT0gWSAmJiBoYXNDb250aW51b3VzRG9tYWluKHNjYWxlVHlwZSkpIHtcbiAgICAgICAgLy8gRm9yIHkgY29udGludW91cyBzY2FsZSwgd2UgaGF2ZSB0byBzdGFydCBmcm9tIHRoZSBoZWlnaHQgYXMgdGhlIGJvdHRvbSBwYXJ0IGhhcyB0aGUgbWF4IHZhbHVlLlxuICAgICAgICByZXR1cm4gW3tzaWduYWw6IHNpemVTaWduYWx9LCAwXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBbMCwge3NpZ25hbDogc2l6ZVNpZ25hbH1dO1xuICAgICAgfVxuICAgIGNhc2UgU0laRTpcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgY3VzdG9tIHJhbmdlTWluLCByYW5nZU1heFxuICAgICAgY29uc3QgcmFuZ2VNaW4gPSBzaXplUmFuZ2VNaW4obWFyaywgemVybywgY29uZmlnKTtcbiAgICAgIGNvbnN0IHJhbmdlTWF4ID0gc2l6ZVJhbmdlTWF4KG1hcmssIHh5UmFuZ2VTdGVwcywgY29uZmlnKTtcbiAgICAgIHJldHVybiBbcmFuZ2VNaW4sIHJhbmdlTWF4XTtcbiAgICBjYXNlIFNIQVBFOlxuICAgICAgcmV0dXJuICdzeW1ib2wnO1xuICAgIGNhc2UgQ09MT1I6XG4gICAgY2FzZSBGSUxMOlxuICAgIGNhc2UgU1RST0tFOlxuICAgICAgaWYgKHNjYWxlVHlwZSA9PT0gJ29yZGluYWwnKSB7XG4gICAgICAgIC8vIE9ubHkgbm9taW5hbCBkYXRhIHVzZXMgb3JkaW5hbCBzY2FsZSBieSBkZWZhdWx0XG4gICAgICAgIHJldHVybiB0eXBlID09PSAnbm9taW5hbCcgPyAnY2F0ZWdvcnknIDogJ29yZGluYWwnO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG1hcmsgPT09ICdyZWN0JyB8fCBtYXJrID09PSAnZ2Vvc2hhcGUnID8gJ2hlYXRtYXAnIDogJ3JhbXAnO1xuICAgIGNhc2UgT1BBQ0lUWTpcbiAgICAgIC8vIFRPRE86IHN1cHBvcnQgY3VzdG9tIHJhbmdlTWluLCByYW5nZU1heFxuICAgICAgcmV0dXJuIFtjb25maWcuc2NhbGUubWluT3BhY2l0eSwgY29uZmlnLnNjYWxlLm1heE9wYWNpdHldO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZSAqL1xuICB0aHJvdyBuZXcgRXJyb3IoYFNjYWxlIHJhbmdlIHVuZGVmaW5lZCBmb3IgY2hhbm5lbCAke2NoYW5uZWx9YCk7XG59XG5cbmZ1bmN0aW9uIHNpemVSYW5nZU1pbihtYXJrOiBNYXJrLCB6ZXJvOiBib29sZWFuLCBjb25maWc6IENvbmZpZykge1xuICBpZiAoemVybykge1xuICAgIHJldHVybiAwO1xuICB9XG4gIHN3aXRjaCAobWFyaykge1xuICAgIGNhc2UgJ2Jhcic6XG4gICAgY2FzZSAndGljayc6XG4gICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1pbkJhbmRTaXplO1xuICAgIGNhc2UgJ2xpbmUnOlxuICAgIGNhc2UgJ3RyYWlsJzpcbiAgICBjYXNlICdydWxlJzpcbiAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWluU3Ryb2tlV2lkdGg7XG4gICAgY2FzZSAndGV4dCc6XG4gICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1pbkZvbnRTaXplO1xuICAgIGNhc2UgJ3BvaW50JzpcbiAgICBjYXNlICdzcXVhcmUnOlxuICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1pblNpemU7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQ6IHNob3VsZCBuZXZlciByZWFjaCBoZXJlICovXG4gIC8vIHNpemVSYW5nZU1pbiBub3QgaW1wbGVtZW50ZWQgZm9yIHRoZSBtYXJrXG4gIHRocm93IG5ldyBFcnJvcihsb2cubWVzc2FnZS5pbmNvbXBhdGlibGVDaGFubmVsKCdzaXplJywgbWFyaykpO1xufVxuXG5mdW5jdGlvbiBzaXplUmFuZ2VNYXgobWFyazogTWFyaywgeHlSYW5nZVN0ZXBzOiBudW1iZXJbXSwgY29uZmlnOiBDb25maWcpIHtcbiAgY29uc3Qgc2NhbGVDb25maWcgPSBjb25maWcuc2NhbGU7XG4gIHN3aXRjaCAobWFyaykge1xuICAgIGNhc2UgJ2Jhcic6XG4gICAgY2FzZSAndGljayc6XG4gICAgICBpZiAoY29uZmlnLnNjYWxlLm1heEJhbmRTaXplICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5zY2FsZS5tYXhCYW5kU2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtaW5YWVJhbmdlU3RlcCh4eVJhbmdlU3RlcHMsIGNvbmZpZy5zY2FsZSkgLSAxO1xuICAgIGNhc2UgJ2xpbmUnOlxuICAgIGNhc2UgJ3RyYWlsJzpcbiAgICBjYXNlICdydWxlJzpcbiAgICAgIHJldHVybiBjb25maWcuc2NhbGUubWF4U3Ryb2tlV2lkdGg7XG4gICAgY2FzZSAndGV4dCc6XG4gICAgICByZXR1cm4gY29uZmlnLnNjYWxlLm1heEZvbnRTaXplO1xuICAgIGNhc2UgJ3BvaW50JzpcbiAgICBjYXNlICdzcXVhcmUnOlxuICAgIGNhc2UgJ2NpcmNsZSc6XG4gICAgICBpZiAoY29uZmlnLnNjYWxlLm1heFNpemUpIHtcbiAgICAgICAgcmV0dXJuIGNvbmZpZy5zY2FsZS5tYXhTaXplO1xuICAgICAgfVxuXG4gICAgICAvLyBGSVhNRSB0aGlzIGNhc2UgdG90YWxseSBzaG91bGQgYmUgcmVmYWN0b3JlZFxuICAgICAgY29uc3QgcG9pbnRTdGVwID0gbWluWFlSYW5nZVN0ZXAoeHlSYW5nZVN0ZXBzLCBzY2FsZUNvbmZpZyk7XG4gICAgICByZXR1cm4gKHBvaW50U3RlcCAtIDIpICogKHBvaW50U3RlcCAtIDIpO1xuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0OiBzaG91bGQgbmV2ZXIgcmVhY2ggaGVyZSAqL1xuICAvLyBzaXplUmFuZ2VNYXggbm90IGltcGxlbWVudGVkIGZvciB0aGUgbWFya1xuICB0aHJvdyBuZXcgRXJyb3IobG9nLm1lc3NhZ2UuaW5jb21wYXRpYmxlQ2hhbm5lbCgnc2l6ZScsIG1hcmspKTtcbn1cblxuLyoqXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBSYW5nZSBzdGVwIG9mIHggb3IgeSBvciBtaW5pbXVtIGJldHdlZW4gdGhlIHR3byBpZiBib3RoIGFyZSBvcmRpbmFsIHNjYWxlLlxuICovXG5mdW5jdGlvbiBtaW5YWVJhbmdlU3RlcCh4eVJhbmdlU3RlcHM6IG51bWJlcltdLCBzY2FsZUNvbmZpZzogU2NhbGVDb25maWcpOiBudW1iZXIge1xuICBpZiAoeHlSYW5nZVN0ZXBzLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gTWF0aC5taW4uYXBwbHkobnVsbCwgeHlSYW5nZVN0ZXBzKTtcbiAgfVxuICBpZiAoc2NhbGVDb25maWcucmFuZ2VTdGVwKSB7XG4gICAgcmV0dXJuIHNjYWxlQ29uZmlnLnJhbmdlU3RlcDtcbiAgfVxuICByZXR1cm4gMjE7IC8vIEZJWE1FOiByZS1ldmFsdWF0ZSB0aGUgZGVmYXVsdCB2YWx1ZSBoZXJlLlxufVxuIl19